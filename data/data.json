[
  {
    "id": "2021_exam01",
    "instruction": "今天，小 Y 與小 P 來到了 APCS 國。在這個國家中，總共有兩家生產糖果的工廠，他們姑且稱為工廠 A 與工廠 B。\n\n在生產糖果的過程中，需要投入 APCS 國特產的糖果原料：AC。而隨著投入的 AC 量不同，這兩個工廠生產出來的糖果的美麗程度不盡相同。如果他們分配 $x$ 個 AC 到工廠 A，可以獲得到的美麗程度值是 $beauty_A = -A_1 \\times x^2 + A_2 \\times x - A_3$。如果他們分配 $y$ 個 AC 到工廠 B，可以獲得到的美麗程度是 $beauty_B = \\lceil \\frac{B_1}{101 - y} \\rceil + \\lceil \\frac{B_2}{y + 1} \\rceil$。在這之中，$A_1, A_2, A_3, B_1, B_2$ 都是已知的非負整數，而 $\\lceil z \\rceil$ 代表第一個不小於 $z$ 的整數。\n\n現在，小 Y 與小 P 手上總共握有 $N$ 個 AC，他們想要把這些 AC 分配給兩個工廠，讓這兩個工廠可以得到的美麗程度總和最大。也就是說，他們希望計算出來的 $beauty_A + beauty_B$ 最大。\n\n而由於給予過多的 AC 可能會造成反效果，小 Y 跟小 P 不一定要把那 $N$ 個 AC 全部分配給那兩個工廠。\n\n現在，給你 $N, A_1, A_2, A_3, B_1, B_2$，請你寫一個程式，計算出最大可能的美麗程度總和。\n\n輸入只有一行，包含六個非負整數 $N, A_1, A_2, A_3, B_1, B_2 (0 \\leq N, A_1, A_2, A_3, B_1, B_2 \\leq 100)$，分別代表小 Y 與小 P 擁有的 AC 數量，以及代表工廠的那五個參數。\n\n輸出一個整數，代表最大的美麗程度總和。也就是說，最大的 $beauty_A + beauty_B$。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main () {\n  int n, a1, a2, a3, b1, b2;\n  cin >> n >> a1 >> a2 >> a3 >> b1 >> b2;\n  int ans = -1000000000;  // note that the answer might be negative\n  for (int x = 0; x <= n; ++x) {\n    for (int y = 0; y <= n - x; ++y) {\n      ans = max(ans, -a1 * x * x + a2 * x - a3 +\n                     (b1 + (101 - y) - 1) / (101 - y) + \n                     (b2 + (y + 1) - 1) / (y + 1));\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "id": "2021_exam02",
    "instruction": "今天，小 Y 與小 P 來到了 APCS 國。在這個國家中，總共有 $N$ 個城鎮（城鎮以 $1$ 到 $N$ 編號），每個城鎮都有恰好一個寶石，而每個寶石都可以用一個數字，代表他們的美麗程度。第 $i$ 個城鎮的寶石的美麗程度，他們以 $a_i$ 來表示。\n\n接下來，小 Y 與小 P 會對這些城鎮做一些研究，內容分別如下：\n\n1. 增加美麗度：小 Y 與小 P 會選擇兩個數字 $x, y$，並且把城鎮 $x, x + 1, \\dots, y - 1, y$ 的寶石的美麗程度都加上一個正整數 $z$。\n2. 寶石反轉：小 Y 與小 P 會選擇兩個數字 $x, y$，並且對調城鎮 $x$ 與城鎮 $y$ 的寶石、城鎮 $x + 1$ 與城鎮 $y - 1$ 的寶石、$\\dots$，以此類推。\n3. 詢問：小 Y 與小 P 會選擇兩個數字 $x, y$，他們會問城鎮 $x, x + 1, \\dots, y$ 的寶石中，美麗程度的最大值是多少。\n\n上面那些研究中，他們會按照順序執行 $Q$ 個研究，並且至少包含一個詢問研究。\n\n現在，給你這些資訊，針對每個詢問研究，請你輸出相對應的答案。\n\n輸入的第一行包含兩個正整數 $N, Q(1 \\leq N, Q \\leq 1000)$，分別代表 APCS 國的城鎮數量，以及進行的研究數量。\n\n接下來的一行，包含 $N$ 個正整數 $a_1, a_2, \\dots, a_N(1 \\leq a_i \\leq 1000)$，$a_i$ 代表第 $i$ 個城鎮的寶石的美麗程度。\n\n接下來的 $Q$ 行，第 $i$ 行代表第 $i$ 個研究的內容。第 $i$ 行的第一個正整數為 $t_i$，代表第 $i$ 個研究的種類。\n\n* 如果 $t_i = 1$，代表這是一個增加美麗度的研究。接下來會有三個正整數 $x_i, y_i, z_i$，代表小 Y 與小 P 想要把城鎮 $x_i, x_i + 1, \\dots, y_i$ 的寶石的美麗程度增加 $z_i$。\n* 如果 $t_i = 2$，代表這是一個寶石反轉的研究。接下來會有兩個正整數 $x_i, y_i$，代表小 Y 與小 P 想要對調城鎮 $x_i$ 與城鎮 $y_i$ 的寶石、城鎮 $x_i + 1$ 與城鎮 $y_i - 1$ 的寶石，$\\dots$，以此類推。\n* 如果 $t_i = 3$，代表這是一個詢問的研究。接下來會有兩個正整數 $x_i, y_i$，代表小 Y 與小 P 想要知道城鎮 $x_i, x_i + 1, \\dots, y_i - 1, y_i$ 中，寶石裡面最大的美麗程度的值是多少。\n\n題目保證 $1 \\leq t_i \\leq 3, 1 \\leq x_i \\leq y_i \\leq N, 1 \\leq z_i \\leq 1000$。\n\n對於每個詢問的研究，請輸出一個數字於一行，代表那個詢問研究的答案。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main () {\n  int n, q; cin >> n >> q;\n  vector<int> a(n + 1);\n  for (int i = 1; i <= n; ++i) {\n    cin >> a[i];\n  }\n  for (int i = 1; i <= q; ++i) {\n    int t; cin >> t;\n    if (t == 1) {\n      int x, y, z; cin >> x >> y >> z;\n      for (int j = x; j <= y; ++j) {\n        a[j] += z;\n      }\n    }\n    else if (t == 2) {\n      int x, y; cin >> x >> y;\n      reverse(a.begin() + x, a.begin() + y + 1);\n    }\n    else {\n      int x, y; cin >> x >> y;\n      cout << *max_element(a.begin() + x, a.begin() + y + 1) << endl;\n    }\n  }\n}\n\n"
  },
  {
    "id": "2021_exam03",
    "instruction": "今天，小 Y 與小 P 來到了 APCS 國。一進入這個國家後，他們在路上，看到了一份寫著密文的文件，以及一本字典。\n\n在 APCS 國裡面，通用的語言是 APCS 語。這個語言是由是由小寫字母去除 `aeiou` 構成。小 Y 與小 P 撿到的字典中，是一個 APCS 與對應到英文的字典，每個 APCS 語至多只會有一個英文的對應。\n\n而經過 87 天的努力，小 Y 與小 P 終於發現要怎麼破解這個密文了。他們要依序做以下三件事情：\n\n1. 把密文中所有的英文字母做出 $K$ 的偏移。比如說，當偏移量 $K = 3$ 的時候，字母 `a` 會被替換成字母 `d`，字母 `b` 會被替換成字母 `e`、`x` 會被替換成字母 `a`，以此類推。\n2. 把經過上一點處理過後的字串裡面的 `aeiou` 這五個字母通通換成空格。題目保證經過上一步處理的字串中，不會有兩個連續的 `aeiou`，並且第一個、最後一個字母也不會是 `aeiou`。\n3. 經過上一點處理後，被空格隔開的文字就是 APCS 語。小 Y 與小 P 需要藉由查字典，來把 APCS 語還原成英文。題目保證每個 APCS 語都有出現在字典中。\n\n而經過以上三部處理後的句子，就是 APCS 語翻譯到英文的結果。\n\n當小 Y 與小 P 通靈出這個解密技巧後，他們覺得解密的過程太累了，於是他們想要請你寫一個程式，來幫助他們解密。\n\n輸入的第一行包含兩個正整數 $N, K(1 \\leq N \\leq 1000, 0 \\leq K \\leq 25)$，代表 APCS 語到英文的字典的大小（字典裡面的字數），以及進行第一步解密的偏移量。\n\n接下來的 $N$ 行，第 $i$ 行包含兩個以空白隔開的英文小寫字串 $s_i, t_i$，代表 APCS 語中的 $s_i$ 這個字轉換後會變成 $t_i$。題目保證 $s_i, t_i$ 只包含小寫英文字母，並且 $s_i, t_i$ 的長度會介於 $[1, 10]$ 之間。此外，所有的 $s_i$ 皆不會重複。\n\n接下來的一行，包含一個字串 $c$，代表小 Y 與小 P 撿到的密文。這個字串也只包含小寫英文字母，並且長度介於 $[1, 10000]$ 之間。\n\n請輸出一個字串於一行，代表解密過後的英文。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool okay(char c) {\n  if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n    return true;\n  }\n  return false;\n}\n\nint main () {\n  int n, k; cin >> n >> k;\n  map<string, string> mp;\n  for (int i = 1; i <= n; ++i) {\n    string a, b; cin >> a >> b;\n    mp[a] = b;\n  }\n  string cipher; cin >> cipher;\n  for (char &c : cipher) {\n    c = (c - 'a' + k) % 26 + 'a';\n    if (okay(c)) {\n      c = ' ';\n    }\n  }\n  cipher += \" \";\n  string tmp = \"\";\n  vector<string> sol;\n  for (char c : cipher) {\n    if (c == ' ') {\n      sol.push_back(mp[tmp]);\n      tmp = \"\";\n    }\n    else {\n      tmp.push_back(c);\n    }\n  }\n  for (int i = 0; i < (int)sol.size(); ++i) {\n    cout << sol[i] << \" \\n\"[i == (int)sol.size() - 1];\n  }\n}\n\n"
  },
  {
    "id": "2021_exam04",
    "instruction": "今天，小 Y 與小 P 來到了 APCS 國。在這個國家中，他們發現了一個大小為 $N \\times M$ 的草皮，位於 $(i, j)$ 的草的高度為 $a_{i, j}$。草皮的西北角為 $(1, 1)$，東南角為 $(N, M)$。\n\n接著，他們發現，在這個國家裡面，總共有 $K$ 個掃地機器人，來清理這些草皮。\n\n在接著下去看題目之前，小 Y 與小 P 想先定義以下東西：\n\n1. 如果從 $(i, j)$ 往北走一格，會走到 $(i - 1, j)$。\n2. 如果從 $(i, j)$ 往東走一格，會走到 $(i, j + 1)$。\n3. 如果從 $(i, j)$ 往南走一格，會走到 $(i + 1, j)$。\n4. 如果從 $(i, j)$ 往西走一格，會走到 $(i, j - 1)$。\n5. 如果格子的位置不在 $(1, 1)$ 到 $(N, M)$ 之間，我們稱為這個格子出界了。\n\n在這 $k$ 個掃地機器人中，總共有兩種型態：\n\n1. A 型機器人：在這種機器人中，人類會直接告訴機器人他們要依序行走的方向（用東南西北表示），他們只需要按照那些指令行走即可。在這過程中，如果會有一個指令導致機器人所在的格子出界，則機器人會忽略那個指令，並且停留在原地。\n2. B 型機器人：這種機器人會自動偵測周圍四個方位（東南西北）的格子的草高度，機器人會選擇高度最高的格子行走。如果有很多個格子的高度一樣，機器人會按照東南西北的順序，來選擇自己要前往的位置。機器人會優先往東邊走，再來往南邊，以此類推。小 Y 與小 P 會給定這種機器人執行上述指令的次數。\n\n而每當機器人執行完一個指令後（不包含一開始的傳送），他會在當前的個格子的草的高度扣掉 $1$，如果那個格子的草的高度已經為 $0$ 的話，則什麼事情都不會發生。\n\n現在，小 Y 與小 P 想把那 $K$ 個機器人依序傳送到指定的位置，並且讓他們開始執行指令。當一個機器人執行完所有指令後，小 Y 與小 P 才會把下一個機器人傳送到指定的位置上。小 Y 與小 P 很好奇，當那些機器人把指令執行完後，每個位置的草的高度分別是多少。\n\n輸入的第一行包含三個正整數 $N, M, K(2 \\leq N, M \\leq 300, 1 \\leq K \\leq 10)$，分別代表草皮的大小為 $N \\times M$，並且小 Y 與小 P 將派出 $K$ 個機器人。\n\n接下來的 $N$ 行，第 $i$ 行包含 $M$ 個整數，第 $i$ 行第 $j$ 個整數為 $a_{i, j}(0 \\leq a_{i, j} \\leq 100)$，代表位於 $(i, j)$ 這個格子上面的草的高度。\n\n接下來的 $K$ 行，第 $i$ 行代表第 $i$ 個機器人。前三個正整數為 $t_i, x_i, y_i(1 \\leq t_i \\leq 2, 1 \\leq x_i \\leq N, 1 \\leq y_i \\leq M)$，分別代表這個機器人的種類，以及他一開始會被傳送到的地點。\n\n* 如果 $t_i = 1$，代表這是一個 A 型機器人。輸入接下來會包含一個字串 $s_i$，代表這個 A 型機器人收到的指令。$s_i$ 是一個由 `NESW` 構成的字串，並且長度介於 $[1, 1000]$ 之間。機器人會根據這個字串，由頭向尾執行指令。`NESW` 分別對應到往北、往東、往南、往西走一格。\n* 如果 $t_i = 2$，代表這是一個 B 型機器人。輸入接下來會包含一個正整數 $c_i(1 \\leq c_i \\leq 1000)$，代表這個 B 型機器人需要執行指令的次數。\n\n請輸出 $N$ 行，每行包含 $M$ 個整數，第 $i$ 行第 $j$ 個整數代表 $(i, j)$ 這個格子在經過所有的操作之後的最終高度。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a[306][306];\n\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n\nint main () {\n  int n, m, k; cin >> n >> m >> k;\n  memset(a, -1, sizeof(a));\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      cin >> a[i][j];\n    }\n  }\n  map<char, int> mp;\n  mp['N'] = 3;\n  mp['E'] = 0;\n  mp['S'] = 1;\n  mp['W'] = 2;\n  while (k--) {\n    int t, x, y; cin >> t >> x >> y;\n    if (t == 1) {\n      string s; cin >> s;\n      for (char c : s) {\n        int _ = mp[c];\n        x += dx[_], y += dy[_];\n        if (a[x][y] == -1) {\n          x -= dx[_], y -= dy[_];\n        }\n        a[x][y] = max(0, a[x][y] - 1);\n      }\n    }\n    else {\n      int _k; cin >> _k;\n      while (_k--) {\n        int mx = -1;\n        for (int _ = 0; _ < 4; ++_) {\n          mx = max(mx, a[x + dx[_]][y + dy[_]]);\n        }\n        for (int _ = 0; _ < 4; ++_) {\n          if (mx == a[x + dx[_]][y + dy[_]]) {\n            x += dx[_], y += dy[_];\n            break;\n          }\n        }\n        a[x][y] = max(0, a[x][y] - 1);\n      }\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      cout << a[i][j] << \" \\n\"[j == m];\n    }\n  }\n}\n\n"
  },
  {
    "id": "2022_exam01",
    "instruction": "小明是一間藥房的老闆。在疫情嚴峻的時期，他每天早上都會跟指揮中心索取一些快篩。下午的時候，開始會有客人來藥房購買快篩，而他會在每天晚上清點快篩的庫存，並決定隔天早上要跟指揮中心索取快篩的數量。\n\n具體來說，在接下來的 $N$ 天內，小明每天早上都會跟指揮中心索取一些快篩。在第一天的早上，小明會索取 $X$ 個快篩，從第二天開始，索取的數量會根據前一天的庫存而定（後面會提到是怎麼決定的）。\n\n接著，每天的下午都會有一些客人來購買快篩。在第 $i$ 天中，總共會有 $a_i$ 個客人來購買快篩，每個客人會購買恰好一個快篩。而小明會拿早上索取的快篩和庫存的快篩來提供給客人。只要藥局裡面還有快篩（不論是早上索取的，還是庫存），小明就會提供給客人。不管客人有沒有拿到快篩，他們都會離開藥局，不會留在藥局裡面。\n\n最後，每天晚上小明會檢查剩餘的快篩數量，來決定隔天索取的快篩量。假設今天早上小明跟指揮中心索取 $Y$ 個快篩。如果庫存還留下至少一個快篩的話，那隔天早上小明會跟指揮中心索取 $\\max(Y - 1, 0)$ 個快篩（也就是說，如果小明當天早上沒跟指揮中心索取快篩，那他隔天也不會索取，否則會索取 $Y - 1$ 個快篩），如果庫存是空的話，那小明隔天會跟指揮中心索取 $Y + 1$ 個快篩。\n\n而這邊的快篩是可以放很久的，不用擔心快篩會過期的問題。\n\n現在，小明蒐集了以上的資訊，他打算請你告訴他，一共有多少個客人可以成功拿到快篩，以及在第 $N$ 天晚上的庫存數量。\n\n輸入的第一行包含兩個正整數 $N, X$，代表接下來的天數，以及第一天早上小明會跟指揮中心索取的快篩數量。\n\n接下來的一行，包含 $N$ 個整數 $a_1, a_2, \\dots, a_N$，$a_i$ 代表第 $i$ 天來購買快篩的人數。\n\n* $1 \\leq N \\leq 100$\n* $1 \\leq X \\leq 100$\n* $0 \\leq a_i \\leq 200$\n\n請在一行中輸出兩個整數，第一個整數代表有多少客人可以成功購買快篩，第二個整數代表第 $N$ 天晚上的庫存數量，兩個整數中間請用一個空白隔開。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n, x; cin >> n >> x;\n  int ans1 = 0, ans2 = 0;\n  for (int i = 1; i <= n; ++i) {\n    int a; cin >> a;\n    ans2 += x;\n    int ok = min(ans2, a);\n    ans1 += ok;\n    ans2 -= ok;\n    if (ans2 <= 0) x++;\n    else x = max(x - 1, 0);\n  }\n  cout << ans1 << ' ' << ans2 << endl;\n}\n\n"
  },
  {
    "id": "2022_exam02",
    "instruction": "小華是開心國小的班導師。在疫情期間，學生們會因為染疫而需要請防疫假，而小華需要精準的知道每個學生的出席狀況。\n\n教室裡面總共有 $N$ 排，每排共有 $M$ 個座位，總共有 $N \\times M$ 個座位。在第零天的晚上，小華已經掌握了每個座位學生的出席狀況。第 $i$ 排第 $j$ 個座位的同學的出席狀況會用 $a_{i, j}$ 來表示，代表他會在第 $a_{i, j}$ 天早上來學校上課。\n\n而在接下來的 $Q$ 天，每天晚上小華都會收到當天同學的染疫狀況。在第 $i$ 天他會收到 $K_i$ 個染疫同學的座位。染疫同學不論染疫當天早上是否有來學校，都需要從隔天開始連續請四天的防疫假，在染疫當天的後五天早上才能來學校。如果染疫同學當天早上有來學校，他的座位的周圍九空格（前、後、左、右、左前、左後、右前、右後，可以參考題序最後面的圖！）的同學當天早上有來學校的話，該同學需要從隔天開始連續請兩天的防疫假。\n\n已知在小華觀察的這段時間，同學們沒有在請防疫假的話，都會準時來學校上課，並且同學們也只會請防疫假，不會請其他類別的假。\n\n由於開心國小的病毒比較特殊，因此一個人是有可能多次染疫，而小華因為已經打了 2022 劑疫苗了，所以小華絕對不會染疫。\n\n在收到這些資訊後，小華很好奇，在第 $Q + 1$ 天的早上，總共會有多少個同學來教室上課。\n\n![](https://i.imgur.com/Lvnsipy.png)\n\n在上圖中，藍色位置的九宮格是綠色的位置，而粉紅色位置的九宮格是橘色的位置。\n\n輸入的第一行包含三個正整數 $N, M, Q$，分別代表教室位置的排數，每排的座位數量，以及小華需要觀察的天數。\n\n接下來的 $N$ 行，每行包含 $M$ 個正整數，第 $i$ 行第 $j$ 個正整數為 $a_{i, j}$，代表第 $i$ 排第 $j$ 個座位的同學會在第 $a_{i, j}$ 天早上開始來學校上課。\n\n輸入的接下來包含著 $Q$ 天的資訊。第 $i$ 天的資訊的第一行會是一個整數 $K_i$，代表在第 $i$ 天共有 $K_i$ 個同學染疫。接下來的 $K_i$ 行，每行會包含兩個正整數 $x, y$，代表座位是第 $x$ 排第 $y$ 個位置的同學在該天染疫。\n\n* $1 \\leq N, M \\leq 50$\n* $1 \\leq Q \\leq 50$\n* $1 \\leq a_{i, j} \\leq 5$\n* $0 \\leq K_i \\leq NM$\n* $1 \\leq x \\leq N, 1 \\leq y \\leq M$\n* 在同一天的資訊中，保證不會有相同的座標\n\n輸出一個整數於一行，代表在第 $Q + 1$ 天早上的時候，小華可以看到的同學數量。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 56;\nint a[N][N];\nint b[N][N];\n\nint main() {\n  int n, m, q; cin >> n >> m >> q;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      cin >> a[i][j];\n    }\n  }\n  for (int c = 1; c <= q; ++c) {\n    int kk; cin >> kk;\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 1; j <= m; ++j) {\n        b[i][j] = a[i][j];\n      }\n    }\n    while (kk--) {\n      int x, y; cin >> x >> y;\n      b[x][y] = c + 5;\n      if (a[x][y] <= c) {\n        // at school\n        int dx[8] = {1, 1, 1, 0, 0, -1, -1, -1};\n        int dy[8] = {1, 0, -1, 1, -1, 1, 0, -1};\n        for (int k = 0; k < 8; ++k) {\n          int nx = x + dx[k], ny = y + dy[k];\n          if (1 <= nx && nx <= n && 1 <= ny && ny <= m) {\n            if (a[nx][ny] <= c) {\n              b[nx][ny] = max(b[nx][ny], c + 3);\n            }\n          }\n        }\n      }\n    }\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 1; j <= m; ++j) {\n        a[i][j] = b[i][j];\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      if (a[i][j] <= q + 1) {\n        ++ans;\n      }\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "id": "2022_exam03",
    "instruction": "小王是快樂國的國王。快樂國總共有 $N$ 個城鎮（城鎮編號為 $1, 2, 3, \\dots, N$），並且有 $N - 1$ 條雙向道路連接著這些城鎮。每個城鎮都可以藉由這 $N - 1$ 條雙向道路到達其他所有的城鎮，而每條雙向道路的長度都是一公里。\n\n現在，小王決定在 $M$ 個城鎮設置緊急避難所，這些城鎮的編號為 $a_1, a_2, \\dots, a_M$。而決定好這些緊急避難所的位置後，小王決定算出，對於每個城鎮，該城鎮抵達最近的緊急避難所需要的距離。假設第 $i$ 個城鎮到達最近的緊急避難所需要 $h_i$ 公里，小王希望算出 $\\sum_{i = 1}^{N} h_i$ 的值（也就是所有 $h_i$ 的總和），來當作評估市政的參考。\n\n只要進入到設置有緊急避難所的城鎮，就算成功進入緊急避難所，而如果該城鎮本來就有設置緊急避難所的話，那該城鎮的 $h_i$ 值為 $0$。\n\n注意到 $\\sum_{i = 1}^{N} h_i$ 這個數字有可能超過 `int` 整數儲存的範圍！\n\n輸入的第一行包含兩個正整數 $N, M$，分別代表快樂國的城鎮數量，以及緊急避難所的數量。\n\n接下來的 $N - 1$ 行，每行包含兩個正整數 $u_i, v_i$，代表城鎮 $u_i$ 跟城鎮 $v_i$ 中間有一條長度為一公里的雙向道路連通。\n\n接下來的一行，包含 $M$ 個正整數 $a_1, a_2, \\dots, a_M$，代表有設置緊急避難所的城鎮編號。\n\n* $1 \\leq N \\leq 2 \\times 10^5$\n* $1 \\leq M \\leq N$\n* $1 \\leq u_i, v_i \\leq N, u_i \\neq v_i$\n* $1 \\leq a_i \\leq N$，保證所有 $a_i$ 都相異。\n* 保證任意城鎮都可以藉由雙向道路到達其他城鎮。\n\n輸出 $\\sum_{i = 1}^{N} h_i$ 於一行。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200006;\nvector<int> G[N];\nint dis[N];\n\nint main() {\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m; cin >> n >> m;\n  for (int i = 1; i <= n - 1; ++i) {\n    int x, y; cin >> x >> y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  memset(dis, -1, sizeof(dis));\n  queue<int> que;\n  for (int i = 1; i <= m; ++i) {\n    int x; cin >> x;\n    dis[x] = 0;\n    que.push(x);\n  }\n  while (!que.empty()) {\n    int t = que.front(); que.pop();\n    for (int i : G[t]) {\n      if (dis[i] == -1) {\n        dis[i] = dis[t] + 1;\n        que.push(i);\n      }\n    }\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    ans += dis[i];\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "id": "2022_exam04",
    "instruction": "小樂是一名魔法師，他可以藉由使用一些咒語，來獲得黃金。\n\n具體來說，小樂現在有 $10^9$ 個魔法元素，依序編號為 $1$ 到 $10^9$ ，每個魔法元素恰好各有一個。同時，小樂也學會了 $N$ 個咒語，第 $i$ 咒語需要使用編號 $l_i, l_i + 1, \\dots, r_i$ 的魔法元素，每個魔法元素都需要恰好一個。如果成功蒐集到這些元素後，小樂可以施展魔法，變出 $w_i$ 個黃金。\n\n現在，小樂希望變出盡量多的黃金，現在請你告訴他，最多可以變出多少黃金。\n\n注意到可以變出的黃金數量有可能超過 `int` 整數儲存的範圍！\n\n輸入的第一行包含一個正整數 $N$，代表小樂學會的咒語數量。\n\n接下來的 $N$ 行，每行包含三個正整數 $l_i, r_i, w_i$，代表第 $i$ 個咒語需要用到魔法元素 $l_i, l_i + 1, \\dots, r_i$，並且可以獲得 $w_i$ 個黃金。\n\n* $1 \\leq N \\leq 2 \\times 10^5$\n* $1 \\leq l_i \\leq r_i \\leq 10^9$\n* $1 \\leq w_i \\leq 10^9$\n\n輸出一個整數，代表小樂可以最多可以變出的黃金數量。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 200006;\n\nstruct Seg {\n  ll l, r, w;\n  Seg(){}\n  Seg(ll _l, ll _r, ll _w): l(_l), r(_r), w(_w){}\n};\n\nbool operator<(const Seg &s1, const Seg &s2) {\n  return s1.r < s2.r;\n}\n\nSeg segs[N];\nll dp[N];\nint rr[N];\n\nint main() {\n  int n; cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    cin >> segs[i].l >> segs[i].r >> segs[i].w;\n  }\n  sort(segs + 1, segs + n + 1);\n  for (int i = 1; i <= n; ++i) {\n    rr[i] = segs[i].r;\n  }\n  for (int i = 1; i <= n; ++i) {\n    dp[i] = dp[i - 1];\n    int _l = (lower_bound(rr, rr + n + 1, segs[i].l) - rr) - 1;\n    dp[i] = max(dp[i], dp[_l] + segs[i].w);\n  }\n  cout << dp[n] << endl;\n}\n\n"
  },
  {
    "id": "2darray01",
    "instruction": "第一次看到多維陣列的小明驚訝地嘴巴都合不起來，他的腦袋瞬間增加了一個維度。\n\n「啊，所以貪食蛇的地圖不是一堆一維陣列，原來可以用一個二維陣列達成啊！」\n\n小明馬上想到，這樣終於可以讓他的貪食蛇在地圖上自由的爬行了\n\n先不論小明究竟寫了多可怕的貪食蛇程式碼，可以請你寫一個程式模擬貪食蛇爬整個地圖嗎？\n\n\n\n假設貪食蛇會從左上角出發向右爬，碰到牆壁就會迴轉並且 S 形走完整張地圖。\n\n例如：\n\n<img src=\"https://i.loli.net/2021/06/30/HoYqB3aiykbjVWr.png\" style=\"zoom:50%;\" align=\"left\"/>\n\n輸入只有一行，包含兩個以單一空格隔開的整數 $n,m(1\\le n,m\\le100)$，代表這是一個 $n$ 列 $m$ 行的地圖。\n\n輸出共有 $n$ 行，每行有 $m$ 個以空格隔開的正整數，代表貪食蛇 S 形走訪的順序。貪食蛇只有在碰到牆壁時才會轉彎。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, m, map[100][100] = {}, cnt = 1;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        if (i % 2 == 0) {\n            for (int j = 0; j < m; j++) {\n                map[i][j] = cnt++;\n            }\n        }\n        else {\n            for (int j = m-1; j >= 0; j--) {\n                map[i][j] = cnt++;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cout << map[i][j] << ' ';\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "id": "2darray02",
    "instruction": "有一天小明與小華在教室裡上數學課\n\n「矩陣的乘法吼，也可以用連加的符號以及矩陣元素 $a_{ij},b_{ij}$ 表示」老師在講台上口沫橫飛地講著。\n\n「咦？這樣不就可以使用迴圈計算矩陣 $AB$ 的乘積了嗎！」小明興奮地回頭對小華說著，殊不知小華早已睡倒在桌上不省人事。\n\n於是小明想請你幫他完成這個程式，這樣他才有時間叫小華起床。\n\n\n\n- 已知矩陣 $A$ 的大小為 $m\\times n$，矩陣 $B$ 的大小為 $n\\times p$。矩陣的乘積只有當 $A$ 的行數等於 $B$ 的列數時才有定義，此時相乘得到的矩陣 $AB$ 的大小為 $m\\times p$。\n- 請實作一個程式，讀入二矩陣 $A,B$ 並輸出其相乘的結果。若矩陣 $A,B$ 的相乘沒有定義（即當 $A$ 的行數不等於 $B$ 的列數時）請輸出 `no answer`。\n\n<img src=\"https://i.loli.net/2021/06/29/sOPcvJLergVpjNS.png\" style=\"zoom:40%;\" />\n\n（圖片截自維基百科：[https://zh.wikipedia.org/zh-tw/矩陣乘法](https://zh.wikipedia.org/zh-tw/矩陣乘法)）\n\n\n輸入的第一行包含四個正整數 $r_1,c_1,r_2,c_2(1\\le r_1,c_1,r_2,c_2 \\le 100)$，其中 $r_1,c_1$ 代表矩陣 $A$ 的列數與行數、$r_2,c_2$ 代表矩陣 $B$ 的列數與行數。接下來的 $r_1$ 行每行有 $c_1$ 個整數，代表一個 $r_1\\times c_1$ 的矩陣 $A$。再來的 $r_2$ 行每行有 $c_2$ 個數字，代表一個 $r_2\\times c_2$ 的矩陣 $B$。所有 $A,B$ 的矩陣元素皆滿足 $-1000\\le a_{ij},b_{ij}\\le 1000$。\n\n若矩陣 $A,B$ 的乘法沒有定義（即 $c_1\\neq r_2$），請輸出 `no answer` 於一行。\n\n否則請輸出 $r_1$ 行，每行有 $c_2$ 個整數（第 $i$ 行第 $j$ 個代表元素 $(AB)_{ij}$，$1\\le i\\le r_1,1\\le j\\le c_2$），代表矩陣 $A,B$ 相乘的結果 $AB$（大小為 $r_1\\times c_2$）。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint r1, c1, r2, c2;\n\tint A[101][101], B[101][101], C[101][101];\n\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tif (c1 != r2) {\n\t\tcout << \"no answer\" << endl;\n\t}\n\telse {\n\t\tfor (int i = 1; i <= r1; i++) {\n\t\t\tfor (int j = 1; j <= c1; j++) {\n\t\t\t\tcin >> A[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= r2; i++) {\n\t\t\tfor (int j = 1; j <= c2; j++) {\n\t\t\t\tcin >> B[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= r1; i++) {\n\t\t\tfor (int j = 1; j <= c2; j++) {\n\t\t\t\tC[i][j] = 0;\n\t\t\t\tfor (int k = 1; k <= c1; k++) {\n\t\t\t\t\tC[i][j] += A[i][k] * B[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= r1; i++) {\n\t\t\tfor (int j = 1; j <= c2; j++) {\n\t\t\t\tcout << C[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "id": "2darray03",
    "instruction": "小明看著他的貪食蛇 S 形的在地圖上爬行，他看得非常高興，不知不覺中就看了好幾個小時。\n\n這時小明忽然又想到他在玩貪食蛇時，有時會喜歡貼著邊爬行，好像可以拿到比較高的分數\n\n「好像還有別的爬法！」喜歡貪食蛇的小明蹦蹦跳跳地說。\n\n\n\n你可以幫小明寫一個螺旋走法的貪食蛇嗎？這樣他又可以再跟自己的蛇玩好幾個小時。\n\n示意圖：\n\n![](https://i.loli.net/2021/06/30/l2hnA9fdaqYBpvI.png)\n\n假設貪食蛇會從右上角出發向下爬，碰到牆壁或是自己就會向右轉並且走完整張地圖。\n\n輸入只有一行，該行只有一個整數 $n(1\\le n<100,n$ 是奇數$)$，代表這是一個 $n$ 列 $n$ 行的地圖。\n\n輸出共有 $n$ 行，每行有 $n$ 個以空格隔開的正整數，代表貪食蛇走訪的順序。\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, map[99][99] = {}, x, y, cnt = 1, dir = 0;\n    // (dx, dy) represents down, left, up, right\n    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, -1, 0, 1};\n    cin >> n;\n    x = 0;\n    y = n-1;\n    while (1) {\n        map[x][y] = cnt++;\n        if (cnt > n*n) break;\n        if (0 <= x+dx[dir] && x+dx[dir] < n &&\n            0 <= y+dy[dir] && y+dy[dir] < n && map[x+dx[dir]][y+dy[dir]] == 0) {\n            x += dx[dir];\n            y += dy[dir];\n        }\n        else {\n            dir = (dir + 1) % 4;\n            x += dx[dir];\n            y += dy[dir];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << map[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "id": "2darray04",
    "instruction": "小賴老師有次在台大的新體裡面看到有兩個人在打壁球，身為排球隊一員的他運動神經十分發達，他也對壁球這項運動十分感興趣。\n\n於是在某個禮拜天下午去看了場壁球的比賽，那場比賽總共有 $n$ 個人參加，採用一對一單挑的競賽模式，且每位選手皆會和其他選手各比過一場。小賴老師一邊看比賽一邊抄下了整場比賽的比分，回家之後他想分析這些資料，統計出勝場數最多的選手，並希望有朝一日能向他請教壁球的技術。\n\n你能幫小賴老師寫一個計算勝場數的程式嗎？\n\n輸入總共有 $n+1$ 行。\n\n第一行有一個數字 $n(2\\le n\\le 100)$，代表參加這場壁球比賽的總人數。\n\n接下來的 $n$ 行每行有 $n$ 個數字，代表一個 $n\\times n$ 的表格 $T$ 紀錄比賽得分。$T_{i,j}(0\\le T_{ij} \\le 100)$ 表示「編號 $i$ 的選手與編號 $j$ 的選手的那場比賽中選手 $i$ 得到的分數」，因為自己跟自己不會比，所以 $T_{i,i}=0,(0\\le i<n)$。\n\n例如 $n=3$ 時表格為：\n\n```\n0 3 6\n2 0 4\n1 4 0\n```\n\n- 0 號選手 v.s. 1 號選手比數為：$T_{0,1}:T_{1,0}=3:2$，為 0 號選手勝出\n- 0 號選手 v.s. 2 號選手比數為：$T_{0,2}:T_{2,0}=6:1$，為 0 號選手勝出\n- 1 號選手 v.s. 2 號選手比數為：$T_{1,2}:T_{2,1}=4:4$，平手不計入勝場數\n\n依此類推，輸出應為 `2 0 0`。\n\n輸出一行 $n$ 個以單一空格分開的整數 $n_i$，表示編號 $i$ 選手的勝場數。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, T[100][100];\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> T[i][j];\n        }\n    }\n\n    int ans[100] = {};\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (T[i][j] > T[j][i])\n                ans[i]++;\n            else if (T[i][j] < T[j][i])\n                ans[j]++;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << ans[i] << ' ';\n    }\n    cout << endl;\n}\n"
  },
  {
    "id": "2darray05",
    "instruction": "學完了二維陣列後，小明興高采烈地回家，書包往沙發上一丟就馬上打開他的電腦。點了兩下螢幕上的草地方塊，打開了某款小明最喜歡的沙盒遊戲。這款沙盒遊戲最大的特點就是整張地圖皆是由一個個方塊所構成！\n\n但那天小明發現他在遊戲中的家被調皮的朋友倒了水進去，整個家充滿了一坑坑的水窪。生氣的小明決定向那位調皮的朋友索賠，依被水蓋過的土地面積計價！\n\n已知小明的家為一個 $n\\times m$ 的矩形，給定家中每格對應的高度，第 $i$ 列第 $j$ 行的那格所對應的高度為 $h_{i,j}(0\\le i<n,0\\le j<m)$。調皮的朋友倒了 $L$ 單位的水進去，假設水會先平均分佈於最低的那層，如果最低的那層被水淹滿後還有多餘的水，就會再平均覆蓋在次低的那層。如圖所示，方格內顯示的數字是該格的高度：\n\n![](https://cdn.discordapp.com/attachments/745238738132795473/1134543468899880970/1.png)\n\n請你幫小明寫個程式計算淹水的區域。\n\n輸入總共有 $1+n$ 行。第一行包含三個以單一空格隔開的正整數 $n,m,L(1\\le n,m\\le100,0\\le L\\le2^{31}-1)$，代表小明家的長寬，以及朋友倒入 $L$ 單位的水。接下來有 $n$ 行，每行有 $m$ 個整數 $h_{i,j}(0\\le h_{i,j}\\le100)$ 代表該格的高度。\n\n請輸出整張 $n\\times m$ 的地圖。輸出共有 $n$ 行，每行有 $m$ 個整數 `0` 或 `1` 代表該格淹水的情況。若 $h_{i,j}$ 被水淹過請輸出 `1`，否則請輸出 `0`。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, m, h[100][100], L;\n    int heightCnt[101];\n    cin >> n >> m >> L;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> h[i][j];\n            heightCnt[h[i][j]]++;\n        }\n    }\n    for (int i = 1; i < 101; i++) {\n        heightCnt[i] += heightCnt[i-1];\n    }\n\n    int filled = 0, level = 0;\n    while (filled < L && level <= 100) {\n        filled += heightCnt[level];\n        level += 1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (h[i][j] >= level) cout << 0 << ' ';\n            else cout << 1 << ' ';\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "id": "2darray06",
    "instruction": "矩陣是將一群元素整齊地排列成一個矩形，在矩陣中的橫排稱為列（row），直排稱為行（column），其中以 $X_{ij}$ 來表示矩陣 $X$ 中的第 $i$ 列第 $j$ 行的元素。如圖一中，$X_{32}=6$。\n\n我們可以對矩陣定義兩種操作如下：\n\n- **翻轉**：即第一列與最後一列交換、第二列與倒數第二列交換、... 依此類推。\n- **旋轉**：將矩陣以順時針方向轉 $90$ 度。\n\n例如：矩陣 $X$ 翻轉後可得到 $Y$，將矩陣 $Y$ 再旋轉後可得到 $Z$。\n\n![](https://i.loli.net/2021/06/30/lr98AbSRDNBozwP.png)\n\n一個矩陣 $A$ 可以經過一連串的**旋轉**與**翻轉**操作後，轉換成新矩陣 $B$。如圖二中，$A$ 經過翻轉與兩次旋轉後，可以得到 $B$。給定矩陣 $B$ 和一連串的操作，請算出原始的矩陣 $A$。\n\n![](https://i.loli.net/2021/06/30/jzxVM85l1PD2WmC.png)\n\n第一行有三個正整數 $R,C,M(1\\le R,C,M\\le 10)$。\n\n接下來 $R$ 行（line）是矩陣 $B$ 的內容，每一行（line）都包含 $C$ 個正整數，其中的第 $i$ 行第 $j$ 個數字代表矩陣 $B_{ij}$ 的值。\n\n在矩陣內容後的一行有 $M$ 個整數，表示對矩陣 $A$ 進行的操作。第 $k$ 個整數 $m_k$ 代表第 $k$ 個操作，如果 $m_k=0$ 則代表旋轉，$m_k=1$ 代表翻轉。\n\n同一行的數字之間都是一個空白間隔，且矩陣內容 $B_{ij}$ 符合 $0\\le B_{ij}\\le9$。\n\n輸出包含兩個部分。\n\n第一個部分有一行，包含兩個正整數 $R'$ 和 $C'$ 以一個空白隔開，分別代表矩陣 $A$ 的列數和行數。\n\n接下來有 $R'$ 行，每一行都包含 $C'$ 個正整數，且每一行的整數之間以一個空白隔開，其中第 $i$ 行的第 $j$ 個數字代表矩陣 $A_{ij}$ 的值。\n\n每一行的最後一個數字後並無空白。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int R, C, M, b[10][10], oper[10], temp[10][10];\n    cin >> R >> C >> M;\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            cin >> b[i][j];\n        }\n    }\n    for (int i = M-1; i >= 0; i--) {\n        cin >> oper[i];\n    }\n    for (int m = 0; m < M; m++) {\n        if (oper[m] == 0) {  // rotate counterclockwise\n            for (int i = 0; i < C; i++) {\n                for (int j = 0; j < R; j++) {\n                    temp[i][j] = b[j][C-1-i];\n                }\n            }\n\n            for (int i = 0; i < C; i++) {\n                for (int j = 0; j < R; j++) {\n                    b[i][j] = temp[i][j];\n                }\n            }\n            swap(R, C);\n        }\n        else {  // flip\n            for (int i = 0; i < R/2; i++) {\n                for (int j = 0; j < C; j++) {\n                    swap(b[i][j], b[R-1-i][j]);\n                }\n            }\n        }\n    }\n\n    cout << R << ' ' << C << endl;\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            cout << b[i][j] << ' ';\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "id": "2darray07",
    "instruction": "給定 $N$ 群數字,每群都恰有 $M$ 個正整數。若從每群數字中各選擇一個數字（假設第 $i$ 群所選出數字為 $t_i$），將所選出的 $N$ 個數字加總即可得總和 $S = t_1+t_2+\\dots+t_N$。請寫程式計算 $S$ 的最大值（最大總和），並判斷各群所選出的數字是否可以整除 $S$。\n\n範例測資一說明：挑選的數字依序是 $5, 6, 1$，總和 $S=12$。而此三數中可整除 $S$ 的是 $6$ 與 $1$，$6$ 在第二群，$1$ 在第三群所以先輸出 $6$ 再輸出 $1$。注意，$1$ 雖然也出現在第一群，但它不是第一群中挑出的數字，所以順序是先 $6$ 後 $1$。\n\n範例測資二說明：挑選的數字依序是 $6,9,7,9$，總和 $S=31$。而此四數中沒有可整除 $S$ 的，所以第二行輸出 `-1`。\n\n第一行有兩個正整數 $N$ 和 $M,1\\le N\\le20,1\\le M\\le20$。\n接下來的 $N$ 行，每一行各有 $M$ 個正整數 $x_i$ ，代表一群整數，數字與數字間有一個空格，且 $1\\le i\\le M$，以及 $1\\le x_i\\le256$。\n\n第一行輸出最大總和 $S$。\n第二行按照被選擇數字所屬群的順序，輸出可以整除 $S$ 的被選擇數字，數字與數字間以一個空格隔開；若 $N$ 個被選擇數字都不能整除 $S$，就輸出 `-1`。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, m, nums[20][20], select[20]={}, sum=0;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> nums[i][j];\n            select[i] = max(select[i], nums[i][j]);\n        }\n        sum += select[i];\n    }\n\n    cout << sum << endl;\n    int found = 0;\n    for (int i = 0; i < n; i++) {\n        if (sum % select[i] == 0) {\n            found = 1;\n            cout << select[i] << ' ';\n        }\n    }\n    if (found == 0) cout << \"-1\";\n    cout << endl;\n}\n"
  },
  {
    "id": "2darray08",
    "instruction": "$R×C$ 的平面上有一些城市，每天每個城市會向每個它相鄰的城市遷移 $\\frac{\\text{人數}}{k}$ 個人（整數除法，無條件捨去），請模擬出 $m$ 天之後的結果，輸出人數最少及最多的城市人數。\n\n城市人數若為 $−1$ 則代表該位置並非城市，不能由任何城市遷移至此。\n\n下圖是第一筆範例測資模擬的結果。\n\n<img src=\"https://zerojudge.tw/ShowImage?id=1601\" alt=\"sca\" style=\"zoom:40%;\" />\n\n輸入的第一行包含四個正整數 $R,C,k,m,(1\\le R,C,m\\le50,4\\le k\\le50)$。\n\n接下來包含 $R$ 行，每行包含 $C$ 個整數，對於第 $i$ 行的第 $j$ 個整數 $a_{i,j}(−1\\le a_{i,j}\\le100)$，如果是 $-1$ 表示這個座標沒有城市，否則表示這個座標的城市人數數量，保證是非負整數。\n\n第一行，輸出一個整數，代表在 $m$ 天之後，人數最少的城市的人數。\n\n第二行，輸出一個整數，代表在 $m$ 天之後，人數最多的城市的人數。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int R, C, k, m, p[50][50], delta[50][50]={};\n    cin >> R >> C >> k >> m;\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            cin >> p[i][j];\n        }\n    }\n    while (m--) {\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < C; j++) {\n                if (p[i][j] == -1)\n                    continue;\n                if (i-1 >= 0 && p[i-1][j] != -1) {\n                    delta[i-1][j] += p[i][j]/k;\n                    delta[i][j] -= p[i][j]/k;\n                }\n                if (i+1 < R && p[i+1][j] != -1) {\n                    delta[i+1][j] += p[i][j]/k;\n                    delta[i][j] -= p[i][j]/k;\n                }\n                if (j-1 >= 0 && p[i][j-1] != -1) {\n                    delta[i][j-1] += p[i][j]/k;\n                    delta[i][j] -= p[i][j]/k;\n                }\n                if (j+1 < C && p[i][j+1] != -1) {\n                    delta[i][j+1] += p[i][j]/k;\n                    delta[i][j] -= p[i][j]/k;\n                }\n            }\n        }\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < C; j++) {\n                if (p[i][j] == -1)\n                    continue;\n                p[i][j] += delta[i][j];\n                delta[i][j] = 0;\n            }\n        }\n    }\n    int maxn = 0, minn = 1<<30;\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            if (p[i][j] == -1)\n                continue;\n            maxn = max(maxn, p[i][j]);\n            minn = min(minn, p[i][j]);\n        }\n    }\n    cout << minn << endl << maxn << endl;\n}\n"
  },
  {
    "id": "2darray09",
    "instruction": "有一個方格棋盤，棋盤的每一個格子裡都標示了一個整數，而且這些整數都是不相同的。現在有一個機器人在此方格棋盤上行動，每一次機器人只會移動到目前所在位置的上下左右四個相鄰格子中的一格。機器人的起點是數字最小的格子，每次移動會在可以走的位置中挑選數字最小的格子，但是機器人永遠都不會走到他曾經走過的格子，當然他也不會走到範圍之外。當無路可走的時候，機器人就會停下來。輸入方格棋盤中每個格子的數字，請模擬機器人走過的路徑，並輸出機器人走過的格子的數字總和。\n\n以下是一個例子，輸入的 $4\\times5$ 的方格內的數字如圖中所標示。在本例子中，機器人的起點會是 `1`，所走的路徑是 `1`→`4`→`6`→`7`→`13`→`20`→`21`→`29`→`30`。走到 `30` 的時候已經無路可走，所以機器人就停止了，而經過的數字總和是 `131`。\n\n![](https://i.loli.net/2021/07/05/sgCqjRS2xY9aPKc.png)\n\n\n輸入的第一行是兩個不超過 $100$ 的正整數 $m$ 與 $n$，代表是一個 $m\\times n$ 的方格棋盤，接下來有 $m$ 行，每行 $n$ 個數字，分別是方格棋盤由上而下，由左而右的數字。方格內的數字皆為不超過 $100,000$ 的非負整數，同一行數字之間以空白間隔。\n\n輸出機器人走過的格子中數字的總和。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, m, map[100][100], minn = 100010, x=0, y=0, visited[100][100] = {};\n    int sum = 0;\n    cin >> n >> m;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> map[i][j];\n            if (map[i][j] < minn) {\n                x = i;\n                y = j;\n                minn = map[i][j];\n            }\n        }\n    }\n    sum += map[x][y];\n    visited[x][y] = 1;\n\n    int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\n    while (1) {\n        int dir[4] = {}; // up, down, left, right\n        if (x-1 >= 0 && visited[x-1][y] == 0) dir[0] = 1;\n        if (x+1 < n && visited[x+1][y] == 0) dir[1] = 1;\n        if (y-1 >= 0 && visited[x][y-1] == 0) dir[2] = 1;\n        if (y+1 < m && visited[x][y+1] == 0) dir[3] = 1;\n\n        int xdir = -1, ydir = -1;\n        for (int i = 0; i < 4; i++) {\n            if (dir[i] == 0)\n                continue;\n            if (xdir == -1 && ydir == -1) {\n                xdir = dx[i];\n                ydir = dy[i];\n            }\n            else if (map[x+dx[i]][y+dy[i]] < map[x+xdir][y+ydir]) {\n                xdir = dx[i];\n                ydir = dy[i];\n            }\n        }\n\n        if (xdir == -1 && ydir == -1)\n            break;\n\n        x += xdir;\n        y += ydir;\n        sum += map[x][y];\n        visited[x][y] = 1;\n    }\n    cout << sum << \"\\n\";\n}\n"
  },
  {
    "id": "2darray10",
    "instruction": "探險家千里在走了上百里的路途後，終於找到了傳說中埋藏寶藏的遺跡，為了走入遺跡，找到寶藏，千里必須破解層層關卡：\n每一道關卡都有一枚主教棋以及一張有大小為 $n\\times m$ 的魔法棋盤，魔法棋盤上的每個格子都有一個正整數，代表該格子的魔力值，根據石碑上的說明，千里必須將主教放在棋盤上的某個方格，使得主教攻擊範圍內的總魔力值最大化才可以破解關卡，主教的攻擊範圍是對角線上的所有位置，特別注意放置主教的那個格子也算在主教的攻擊範圍內。危險的是，如果千里放錯的話就會被夜光閃亮亮復仇鬼吃掉。\n身為一個路過的好心人，你決定告訴千里魔力值總和的最大值作為提示。\n以下是主教的攻擊範圍的圖示：\n<center>\n    <img src=\"https://i.imgur.com/jp7caJI.png\" width=\"20%\">\n</center>\n\n第一行包含一個正整數 $t\\ (1\\le t\\le 1000)$ 代表測資的數量。\n每一筆測資的第一行包含兩個正整數 $n, m\\ (1\\le n, m\\le 200)$ 代表棋盤的大小。\n接下來的 $n$ 行，每一行都包含 $m$ 個數字，分別是方格棋盤由上而下，由左而右的魔力值，魔力值皆為不超過 $10^6$ 的非負整數，同一行的數字之間以空白分隔。\n此外，所有測資的 $n\\times m$ 的總和不會超過 $40000$\n\n對於每一筆測資請輸出一個整數，代表該筆測資中，主教攻擊範圍內的魔力值總和的最大值，每筆測資的輸出之間以換行分隔。\n\n",
    "output": "#include <bits/stdc++.h>\n\n#define MAX_SIZE 200\n\nusing namespace std;\n\nint board[MAX_SIZE][MAX_SIZE] = {};\n\nint in_board(int n, int m, int x, int y) {\n    return (x >= 0 and x < n and y >= 0 and y < m);\n}\n\nint get_sum(int n, int m, int x, int y, int dx, int dy) {\n    int curr_x = x + dx, curr_y = y + dy;\n    int ret = 0;\n    \n    while (in_board(n, m, curr_x, curr_y)) {\n        ret += board[curr_x][curr_y];\n        curr_x += dx;\n        curr_y += dy;\n    }\n\n    return ret;\n} \n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, m;\n        int ans = 0;\n        cin >> n >> m;\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                cin >> board[i][j];\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int sum = board[i][j];\n                sum += get_sum(n, m, i, j, 1, 1);\n                sum += get_sum(n, m, i, j, 1, -1);\n                sum += get_sum(n, m, i, j, -1, 1);\n                sum += get_sum(n, m, i, j, -1, -1);\n                ans = max(ans, sum);\n            }\n        }\n\n        cout << ans << \"\\n\";\n    }\n}\n"
  },
  {
    "id": "2darray11",
    "instruction": "小德是個物理學家，最近在研究關於自由落體的物理問題：\n\n他有一個 $n \\times m$ 的矩陣，方陣之中有三種元素：\n- `.` 代表沒有東西\n- `*` 是石頭\n- `o` 是一種特殊、可以飄浮在空中的障礙物\n\n由於地心引力的影響，石頭會一直往下掉，直到掉到最底下那一排、遇到障礙物、或是遇到一顆已經無法在往下移動的石頭為止。\n\n現在小德隨意地排列了矩陣裡的元素，你可以幫助他模擬地心引力作用結束後的狀態嗎？\n\n第一行包含一個正整數 $t\\ (1 \\le t \\le 100)$，代表測資的數量。\n\n每一筆測資的第一行包含兩個整數 $n, m\\ (1\\le n,m\\le 50)$ 代表矩陣的大小。\n\n接下來的 $n$ 行中，每行有 $m$ 個字元，每一個字元皆為 `.`、`*`、`o` 三者之一，分別代表沒東西、石頭與障礙物。\n\n對每一筆測資請輸出矩陣最後的模樣，格式比照輸入，每筆測資的輸出之間以換行分隔。\n\n",
    "output": "#include <bits/stdc++.h>\n\n#define MAX_SIZE 50\n#define AIR '.'\n#define STONE '*'\n#define OBSTACLE 'o'\n\nusing namespace std;\n\nchar board[MAX_SIZE][MAX_SIZE];\n\nint in_board(int n, int x) {\n    return (x >= 0 and x < n);\n}\n\nvoid fall(int n, int x, int y) {\n    int curr_x = x + 1;\n    while (in_board(n, curr_x) and board[curr_x][y] != OBSTACLE and board[curr_x][y] != STONE) {\n        curr_x++;\n    }\n    char tmp = board[x][y];\n    board[x][y] = board[curr_x - 1][y];\n    board[curr_x - 1][y] = tmp;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                cin >> board[i][j];\n            }\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = 0; j < m; ++j) {\n                if (board[i][j] == STONE) {\n                    fall(n, i, j);\n                }\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                cout << board[i][j];\n            }\n            cout << endl;\n        }\n    }\n}\n"
  },
  {
    "id": "2darray12",
    "instruction": "在深海底中，有一大片深海平原，平原上住著許多生物\n生物學家發現，可以將平原劃分成細小的方格，每一個方格上面最多只能有一個浮游生物\n每一方格上的生物生存與否，與相鄰的8格方格點息息相關\n以下是生物學家經過數十年的觀察與歸納發現的規則：\n若該方格上有浮游生物：\n\n- 少於兩個鄰居，則一小時後會因孤單而死\n- 恰有兩個/三個鄰居，則繼續生存下去\n- 多於三個鄰居，則一小時後會太擁擠而死亡\n\n若一個方格點上沒有浮游：\n\n- 若恰有三個鄰居有活著的浮游生物，則一小時後該格會長出一隻浮游生物\n\n生物學家對於整理出這幾條生命的規則感到驕傲，但若想知道一大段時間之後的生物分佈情況就需要借助電腦來模擬了！\n\n註：每ㄧ格的演變都是同時進行，某一格的第$t+1$小時狀態只需考慮某一格鄰居們在第$t$小時的狀態。\n註：只需關注這$n \\times n$的範圍即可，可以假設範圍之外是無止盡的深淵\n\n\n輸入有$n+1$行，第一行包含兩個以單一空格隔開的整數 $1\\le n<100,0\\le r< 1000$，<br>\n分別代表該深海平原一邊有$n$格方格，<br>\n以及希望得到$r$小時後的生物分佈情況。<br>\n\n輸出$n$行，每一行有$n$個數字(0或1)，以單個空格分開，結尾不用空格並且需要換行。\n\n",
    "output": "#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint count_nei(int **board,int n,int i,int j){\n    int ret = 0;\n    if(i>0 && j>0 && board[i-1][j-1]==1) ret++;\n    if(i>0 && board[i-1][j]==1) ret++;\n    if(i>0 && j<n-1 && board[i-1][j+1]==1) ret++;\n    if(j>0 && board[i][j-1] == 1) ret++;\n    if(j<n-1 && board[i][j+1] == 1) ret++;\n    if(i<n-1 && j>0 && board[i+1][j-1]) ret++;\n    if(i<n-1 && board[i+1][j]) ret++;\n    if(i<n-1 && j<n-1 && board[i+1][j+1]) ret++;\n    return ret;\n}\nvoid swap_ptr(int ***a,int ***b){\n    int **tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\nint main() {\n    int n,k;\n    scanf(\"%d%d\",&n,&k);\n    int **board = (int**)malloc(sizeof(int*)*n);\n    for(int i = 0;i<n;i++){\n        board[i] = (int*)malloc(sizeof(int)*n);\n        memset(board[i],0,sizeof(int)*n);\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            scanf(\"%d\",&board[i][j]);\n        }\n    }\n    int **ret = (int**)malloc(sizeof(int*)*n);\n    for(int i = 0;i<n;i++){\n        ret[i] = (int*)malloc(sizeof(int)*n);\n        // memcpy(ret[i],board[i],sizeof(int)*n);\n    }\n    int c=0;\n    for(int l=0;l<k;l++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                c = count_nei(board,n,i,j);\n                if(board[i][j]==1){\n                    if(c<2||c>3) ret[i][j] = 0;\n                    else ret[i][j] = 1;\n                }else{\n                    if(c == 3) ret[i][j] = 1;\n                    else ret[i][j] = 0;\n                }\n            }\n        }\n        // printf(\"%p %p\\n\",board,ret);\n        swap_ptr(&board,&ret);\n        // printf(\"%p %p\\n\",board,ret);\n\n    }\n    // printf(\"%d %d\\n\",n,k);\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            printf(\"%d\",board[i][j]);\n            if(j!=n-1) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n}\n"
  },
  {
    "id": "2darray13",
    "instruction": "小竹開了一間賓果店，然而總是有人會作弊導致其他客人不開心。為了避免不小心把獎金給了作弊的人，小竹希望你幫他寫一個可以判斷哪些人會在第幾輪獲勝的程式。\n\n跟一般的賓果一樣，最先連成一直線、橫線或對角線的人就獲勝，可以有多個人在同一輪獲勝。\n\n輸入第一行有兩個數字 $N, M$，$N$ 代表玩家人數，$M$ 代表賓果盤的寬度。\n\n接下來每 $M + 1$ 行裡，第一行是每個玩家的名字，第二到 $M+1$ 行是該玩家的賓果盤。\n\n最後一行有 $M^2$ 個數字，代表數字被開出的順序。\n\n賓果的數字範圍是 $1$ 到 $M^2$。\n\n限制：\n- $1 \\leq N \\leq 10$\n- $1 \\leq M \\leq 256$\n- $1 \\leq \\textrm{len}(\\textrm{名字}) \\leq 64$\n\n請輸出一行，內容包括導致獲勝的數字，以及獲勝的人的名字 (如果不只一人，以輸入的順序輸出)，並以空格分隔數字與名字。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main ()\n{\n    ios_base::sync_with_stdio(0), cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n\n    string name[10]; int num_to_index[10][256 * 256 + 1];\n    for (int i = 0; i < n; i++)\n    {\n        cin >> name[i];\n        for (int j = 0; j < m * m; j++)\n        {\n            int x;\n            cin >> x;\n            num_to_index[i][x] = j;\n        }\n    }\n\n    int hori[10][256] = {}, verti[10][256] = {}, cross[10][2] = {}, x;\n    bool win[10] = {}, has_win = false;\n    for (int i = 0; i < m * m; i++)\n    {\n        cin >> x;\n        for (int j = 0; j < n; j++)\n        {\n            int target = num_to_index[j][x];\n            \n            hori[j][target / m]++;\n            if (hori[j][target / m] == m) win[j] = true, has_win = true;\n\n            verti[j][target % m]++;\n            if (verti[j][target % m] == m) win[j] = true, has_win = true;\n\n            if (!(target % (m + 1)))\n            {\n                cross[j][0]++;\n                if (cross[j][0] == m) win[j] = true, has_win = true;\n            }\n\n            if (!(target % (m - 1)) && target && target != m * m - 1)\n            {\n                cross[j][1]++;\n                if (cross[j][1] == m) win[j] = true, has_win = true;\n            }\n        }\n\n        if (has_win)\n        {\n            cout << x;\n            for (int j = 0; j < n; j++)\n            {\n                if (win[j])\n                {\n                    cout << ' ' << name[j];\n                }\n            }\n            cout << '\\n';\n            break;\n        }\n    }\n}"
  },
  {
    "id": "3darray01",
    "instruction": "小明有天在路上差點踩死了一隻螞蟻，這時他忽然想到他的暑假作業好像要寫觀察報告\n\n「太好了，那我就來養螞蟻吧！」小明將這隻可憐的螞蟻帶回家並放在一個充滿土的長方形的容器內\n\n過了幾天後他發現螞蟻居然自己鑽土做出了一個隧道！根據小明的觀察螞蟻在這個充滿土的容器內鑽了一個沒有岔路的隧道，並且在隧道底藏了一顆糖果。\n\n已知此容器有的入口在 $(0,0,0)$，從入口出發順著沒有岔路的隧道走到底就可以發現糖果。\n\n請你寫一個程式幫小明找到這個糖果在哪裡。\n\n輸入第一行有三個以單一空格隔開的正整數 $n,m,k(1\\le n,m,k\\le 50)$ 代表此長方形容器的大小。\n\n接下來共有 $n$ 組 $m\\times k$ 的數字表示此 3D 立體地圖的每一層。此地圖皆由 `0` 與 `1` 構成。`0` 代表隧道，`1` 代表土。\n\n每組由 $m$ 行數字組成，每行有 $k$ 個以空白隔開的數字 `0` 或 `1`。\n\n第 $i$ 組中，第 $j$ 行的第 $k$ 個數字代表座標 $(i-1,j-1,k-1)$ 為隧道或土。\n\n以 $n=m=k=5$ 為例。此輸入代表有五層，$(0,0,0)$ 必為第二行第一個數字：\n\n```\n5 5 5\n0 0 1 1 1\n1 0 1 1 1\n1 0 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n(輸入中不會有此空行)\n1 1 1 1 1\n1 1 0 1 1\n1 0 0 1 1\n1 1 1 1 1\n1 1 1 1 1\n(輸入中不會有此空行)\n1 1 1 1 1\n1 1 0 0 1\n1 1 1 0 1\n1 1 0 0 1\n1 1 1 1 1\n(輸入中不會有此空行)\n1 1 1 1 1\n0 0 1 1 1\n0 1 1 1 1\n1 1 0 1 1\n1 1 1 1 1\n(輸入中不會有此空行)\n1 1 1 1 1\n1 1 1 1 1\n0 1 1 1 1\n0 0 0 1 1\n1 1 1 1 1\n```\n\n此輸入等價於下圖：\n\n![](https://i.loli.net/2021/07/03/tWiHCGEPVbZcAgr.png)\n\n輸出三個以空格隔開的整數 $n_i,m_i,k_i$ 代表糖果的位置（即隧道終點）。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int map[50][50][50];\n    int N, M, K;\n    cin >> N >> M >> K;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            for (int l = 0; l < K; l++) {\n                cin >> map[i][j][l];\n            }\n        }\n    }\n\n    int n = 0, m = 0, k = 0;\n    while (1) {\n        map[n][m][k] = 1;\n        if (n-1 >= 0 && map[n-1][m][k] == 0) {  // go up\n            n = n-1;\n        }\n        else if (n+1 < N && map[n+1][m][k] == 0) {  // go down\n            n = n+1;\n        }\n        else if (m-1 >= 0 && map[n][m-1][k] == 0) {  // go forward\n            m = m-1;\n        }\n        else if (m+1 < M && map[n][m+1][k] == 0) {  // go backward\n            m = m+1;\n        }\n        else if (k-1 >= 0 && map[n][m][k-1] == 0) {  // go left\n            k = k-1;\n        }\n        else if (k+1 < K && map[n][m][k+1] == 0) {  // go right\n            k = k+1;\n        }\n        else\n            break;\n    }\n    cout << n << ' ' << m << ' ' << k << endl;\n}\n"
  },
  {
    "id": "3darray02",
    "instruction": "給定一個 $n\\times m(1\\le n,m\\le 50)$ 的 RGB 圖檔，每格像素以三個 $0 \\sim 255$ 的整數表示。請你實做一個功能將圖中某個指定顏色周圍曼哈頓距離**小於等於** $d(1\\le d\\le 10)$ 的格子皆設為透明，並輸出一個 $n\\times m$ 的 `01` 矩陣代表結果，`1` 代表透明，`0` 代表非透明。指定的顏色一樣以三個 $0 \\sim 255$ 的整數表示（R、G、B）。\n\n![](https://i.loli.net/2021/07/07/9HtUuWqe7lyv4N6.png)\n\n曼哈頓與歐幾里得距離： 曼哈頓距離的定義是只能水平和垂直移動時的最短距離。如圖，紅、藍與黃線皆為符合水平垂直條件的路徑，且都擁有一樣長度（$10$），因為這是所有方法中最短的所以曼哈頓距離為 $10$ ，而綠線則是歐幾里得距離的走法，長度為 $5\\sqrt{2}\\approx 7.07$ 。（截自維基百科）\n\n![](https://i.loli.net/2021/07/07/HSgpxLr6VybdMj1.png)\n\n第一行有六個以單一空格分開的整數 $n,m,d,r_0,g_0,b_0$ 表示此圖檔的大小為 $n$ 列 $m$ 行，給定的曼哈頓距離為 $d$，指定的顏色為 $(r_0,g_0,b_0)$。\n\n接下來的 $3n$ 行（line），每行有 $m$ 個 $0 \\sim 255$ 的整數代表這個圖檔，前 $n$ 行每行代表 R 的值，再接著的 $n$ 行代表 G 值，最後 $n$ 行代表 B 值。\n\n輸出共有 $n$ 行，每行有 $m$ 個 `0` 或 `1` 的整數表示透明的情況。`1` 代表透明，`0` 代表非透明。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint abs(int x) {\n    return x<0?-x:x;\n}\n\nvoid fill(int ans[50][50], int n, int m, int d, int x, int y) {\n    for (int i = -d; i <= d; i++) {\n        for (int j = -d; j <=d; j++) {\n            if (abs(i)+abs(j) <= d && 0 <= x+i && x+i < n && 0 <= y+j && y+j < m)\n                ans[x+i][y+j] = 1;\n        }\n    }\n}\n\nint main() {\n    int n, m, d, color[3], graph[50][50][3], ans[50][50]={};\n    cin >> n >> m >> d >> color[0] >> color[1] >> color[2];\n    for (int k = 0; k < 3; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                cin >> graph[i][j][k];\n            }\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int k = 0; k < 3; k++) {\n                if (graph[i][j][k] != color[k])\n                    break;\n                if (k == 2)\n                    fill(ans, n, m, d, i, j);\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cout << ans[i][j] << ' ';\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "id": "3darray03",
    "instruction": "隨著科技日新月異，臺鴨電的鄭麗芳研究員研發了一款「正立方體萬向導體裝置」，<br>\n這個正立方體由 $n \\times n \\times n$ 個晶格排成邊長為 $n$ 的立方體。每一個晶格都可以是合格的或是壞掉的。<br>\n只要該正立方體內，有一條直線上都是能正常運作的小晶格材料，<br>\n那麼，這個裝置就能正常運作<br>\n我們的任務就是要檢視這個立方體中，有幾條由 $n$ 個格子組成的直線上的小晶格材料都是合格的<br>\n註：直線除了 x, y, z 軸方向上的直線外，也包含 xy/yz/xz 平面上的斜線 (也就是沿著 xy/yz/xz 平面的其中一個切面上的斜線，不是只有表面上的），及立方體的四個對角線\n\n輸入有$1+n^2$行，第一行包含一個數字$3 \\le n \\le 10$，代表立方體裝置的邊長<br>\n接下來的$n^2$行，每行包含$n$個數字(只會是0或1，代表該晶格是壞掉的(0)，或是合格的(1))，數字之間由一個空格分隔，每$n$行代表一層的晶格狀況，總共有$n$層<br>\n\n\n輸出一行一個整數$m$，代表有幾條長度為n的直線上都是合格的晶格體\n\n",
    "output": "#include <iostream>\n#include <bitset>\nusing namespace std;\n\nint main() {\n    int n;\n    scanf(\"%d\",&n);\n    int ***cube = (int ***)malloc(sizeof(int**)*n);\n    for(int i = 0;i<n;i++){\n        cube[i] = (int **)malloc(sizeof(int*)*n);\n        for(int j = 0;j<n;j++){\n            cube[i][j] = (int *)malloc(sizeof(int)*n);\n        }\n    }\n    for(int i = 0;i<n;i++){\n        for(int j = 0;j<n;j++){\n            for(int k = 0;k<n;k++){\n                scanf(\"%d\",&cube[i][j][k]);\n            }\n        }\n    }\n    int ret = 0,tmp=1;\n    int dir[13][3] = \n    {\n        {0,0,1},\n        {0,1,0},\n        {1,0,0},\n        {1,1,0},\n        {1,0,1},\n        {0,1,1},\n        {1,-1,0},\n        {1,0,-1},\n        {0,1,-1},\n        {1,1,1},\n        {-1,1,1},\n        {1,-1,1},\n        {1,1,-1}\n    };\n    int cur[3]={0,0,0};\n    // Check 0 0 1/0 1 0/1 0 0\n    for(int l = 0;l<3;l++){\n        for(int i = 0;i<n;i++){\n            for(int j = 0;j<n;j++){\n                tmp = 1;\n                if(l == 0){\n                    cur[0] = i;cur[1] = j;cur[2] = 0;\n                }else if(l==1){\n                    cur[0] = i;cur[1] = 0;cur[2] = j;\n                }else{\n                    cur[0] = 0;cur[1] = i;cur[2] = j;\n                }\n                for(int k = 0;k<n;k++){\n                    tmp*=cube[cur[0]][cur[1]][cur[2]];\n                    cur[0]+=dir[l][0];\n                    cur[1]+=dir[l][1];\n                    cur[2]+=dir[l][2];\n                }\n                ret+=tmp;\n            }\n        }\n    }\n    // cout<< ret<<endl;\n\n    // check 1 1 0/1 0 1 /0 1 1 /1 -1 0/1 0 -1/0 1 -1 \n    for(int l = 3;l<9;l++){\n        for(int i = 0;i<n;i++){\n            tmp = 1;\n            for(int j = 0;j<3;j++){\n                if(dir[l][j]==0) cur[j] = i;\n                if(dir[l][j]==1) cur[j] = 0;\n                if(dir[l][j]==-1) cur[j] = n-1;\n            }\n            for(int k = 0;k<n;k++){\n                tmp*=cube[cur[0]][cur[1]][cur[2]];\n                cur[0]+=dir[l][0];\n                cur[1]+=dir[l][1];\n                cur[2]+=dir[l][2];\n            }\n            ret+=tmp;\n        }\n    }\n    // check 1 1 1 /-1 1 1 /1 -1 1/1 1 -1 \n    // cout<< ret<<endl;\n\n    for(int l = 9;l<13;l++){\n        tmp = 1;\n        for(int j = 0;j<3;j++){\n            if(dir[l][j]==1) cur[j] = 0;\n            if(dir[l][j]==-1) cur[j] = n-1;\n        }\n        // printf(\"checking dir %d %d %d\\n cur: %d %d %d\\n\",dir[l][0],dir[l][1],dir[l][2],cur[0],cur[1],cur[2]);\n\n        for(int k = 0;k<n;k++){\n            tmp*=cube[cur[0]][cur[1]][cur[2]];\n            cur[0]+=dir[l][0];\n            cur[1]+=dir[l][1];\n            cur[2]+=dir[l][2];\n        }\n        ret+=tmp;\n    }\n    cout<< ret<<endl;\n\n\n    \n\n\n\n\n}\n"
  },
  {
    "id": "array01",
    "instruction": "剛學會陣列的小明想用程式來算費氏數列，但他卡住了，你可以幫幫他嗎？\n\n現在給你一個正整數 $N$，請你照順序輸出費氏數列前 $N$ 項，並用空白分隔。費氏數列的定義如下（以下用 $fib_i$ 代表費氏數列第 $i$ 項）：\n\n$$\nfib_i=\n\\begin{cases}\n1 &, i = 1 \\newline\n1 &, i = 2 \\newline\nfib_{i-2} + fib_{i-1} &,  \\text{otherwise} \\newline\n\\end{cases}\n$$\n\n輸入只有一行，包含一個正整數 $N$，代表你要輸出費氏數列的前 $N$ 項。\n\n* $1\\le N\\le 45$\n\n請輸出一行由空格分開的整數，代表費氏數列的前 $N$ 項。\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint fib[45 + 5];\n\nint main() {\n\tint n; cin >> n;\n\t// 計算\n\tfib[1] = 1, fib[2] = 1;\n\tfor (int i = 3; i <= n; i++) {\n\t\tfib[i] = fib[i - 2] + fib[i - 1];\n\t}\n\t// 輸出\n\tfor (int i = 1; i <= n; i++) {\n\t\tcout << fib[i];\n\t\tif (i < n) cout << ' ';\n\t\telse cout << '\\n';\n\t}\n}\n"
  },
  {
    "id": "array02",
    "instruction": "給你兩個長度為 $N$ 的數列 $A_1, A_2, \\dots, A_N$ 和 $B_1, B_2, \\dots, B_N$，請計算他們的內積。兩個數列的內積定義為 $A_1\\cdot B_1 + A_2\\cdot B_2 + \\dots + A_N\\cdot B_N$，也就是兩兩相乘之和。\n\n輸入一共三行。第一行有一個數字 $N$，代表數列 $A$ 和數列 $B$\t的長度。第二行有 $N$ 個用空白分隔的數字，代表 $A_1\\space A_2\\dots\\space A_N$。第三行有 $N$ 個用空白分隔的數字，代表 $B_1\\space B_2\\dots\\space B_N$。\n\n* $-1000\\le A_i \\le 1000$\n* $1 \\le N\\le 1000$\n\n請輸出一個數字，代表內積的結果。\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint A[1005], B[1005];\n\nint main() {\n\tint N; cin >> N;\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n\tfor (int i = 0; i < N; i++) cin >> B[i];\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++) ans += A[i] * B[i];\n\tcout << ans << endl;\n}\n"
  },
  {
    "id": "array03",
    "instruction": "某次小明在網路上看到了 Merge Sort 的演算法，他便興致勃勃地開始著手實作。他想先完成這個步驟：將兩條由小到大排序好的序列合併成一個有小排到大的序列。請你寫一個程式幫他完成這項操作。\n\n輸入共有三行。\n\n第一行，包含兩個以空格隔開的整數 $n,m(1\\le n,m\\le 10000)$，分別代表由小到大排好的序列 $a,b$ 的長度，序列 $a,b$ 的元素符合 $-10^6\\le a_i,b_i\\le 10^6$。\n\n第二行共有 $n$ 個整數，代表序列 $a$ 的內容。\n\n第三行共有 $m$ 個整數，代表序列 $b$ 的內容。\n\n輸出一行 $n+m$ 個整數，代表序列 $a,b$ 合併後的排序結果。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, m, a[10000], b[10000], ans[20000], idx = 0;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < m; i++) {\n        cin >> b[i];\n    }\n\n    int i = 0, j = 0;\n    while (i < n && j < m) {\n        if (a[i] < b[j]) ans[idx++] = a[i++];\n        else ans[idx++] = b[j++];\n    }\n    while (i < n) ans[idx++] = a[i++];\n    while (j < m) ans[idx++] = b[j++];\n    for (int k = 0; k < idx; k++) {\n        cout << ans[k] << \" \\n\"[k==idx-1];\n    }\n}\n"
  },
  {
    "id": "array04",
    "instruction": "給定一個正整數 $N$ ，請問 $1 \\sim N$ 中有幾個質數？\n輸入有一行，第一行有一個正整數代表題目中的 $N$。\n\n- $2 \\le N \\le 10^7$\n\n輸出有一行，包含一個正整數，代表 $1 \\sim N$ 中質數的數量。\n",
    "output": "/*input\n7\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=10000005;\n\nvector<int> p;\nbool isp[maxn];\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i = 2; i <= n; i++){\n\t\tif(!isp[i]) p.push_back(i);\n\t\tfor(int j = 0; i * p[j] <= n; j++){\n\t\t\tisp[i * p[j]] = 1;\n\t\t\tif(i % p[j] == 0) break;\n\t\t}\n\t}\n\tcout<<p.size()<<'\\n';\n}\n"
  },
  {
    "id": "array05",
    "instruction": "大部分的人第一次學習的排序演算法是 Bubble Sort，請大家使用巢狀迴圈，實做 Bubble Sort 的演算法。\n\n第一行輸入一個正整數 $n$，代表接下來會有幾個整數要你排序。\n第二行輸入這 $n$ 個整數，數字之間以空白分隔。\n\n* $1 \\leq n \\leq 1000$\n* 所有要排序的數字都在 `int` 範圍內\n\n輸出排序後的結果。\n\n",
    "output": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\tint n; \n\tint a[1000];\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tfor (int i = 0; i < n - 1; i++)\n\t\tfor (int j = 0; j < n - 1 - i; j++)\n\t\t\tif (a[j] > a[j + 1])\n\t\t\t\tswap(a[j], a[j + 1]);\n\n\tfor (int i = 0; i < n; i++) {\n        cout << a[i] << \" \\n\"[i == n-1];\n\t}\n}\n"
  },
  {
    "id": "array06",
    "instruction": "本題請實作 $N$ 位數 $\\overline{a_{N-1}a_{N-2}\\dots a_0}$ 和 $M$ 位數 $\\overline{b_{M-1}b_{M-2}\\dots b_0}$ 的加減法，保證運算結果仍為正整數。\n\n輸入第一行是三個空白分隔的正整數 $N, M, op$，分別代表第一和第二個數的位數，以及操作種類。當 $op = 0$ 時執行大數加法，當 $op = 1$ 時執行減法。\n第二行有 $N$ 個空白分隔的整數 $a_0, a_1, \\dots, a_{N-1}$ 代表第一個大數從低位到高位的數碼依序為何。\n第三行有 $M$ 個空白分隔的整數 $b_0, b_1, \\dots, b_{M-1}$ 代表第二個大數從低位到高位的數碼依序為何。\n\n輸入保證 $1\\le N, M\\le 100000$，$0\\le a_i, b_i\\le 9$，$a_{N-1}, b_{M-1}\\ne 0$。\n\n輸出一行若干個空白分隔的整數，表示運算後的答案。\n\n輸出的大數格式和輸入略同，每次由低位到高位依序輸出一個數碼，且首位數不得為 $0$。\n\n",
    "output": "#include <iostream>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nint a[maxn], b[maxn], ans[maxn];\nint main() {\n    int N, M, op = 0;\n    cin >> N >> M >> op;\n    for(int i = 0; i < N; i++) cin >> a[i];\n    for(int i = 0; i < M; i++) cin >> b[i];\n    if(op == 0) {\n        for(int i = 0; i < max(N, M); i++) ans[i] = a[i]+b[i];\n        for(int i = 0; i < N+M; i++) {\n            if(ans[i] >= 10) {\n                ans[i] -= 10;\n                ans[i+1]++;\n            }\n        }\n    }\n    if(op == 1) {\n        for(int i = 0; i < max(N, M); i++) ans[i] = a[i]-b[i];\n        for(int i = 0; i < N+M; i++) {\n            if(ans[i] < 0) {\n                ans[i] += 10;\n                ans[i+1]--;\n            }\n        }\n    }\n    int digit = N+M+10;\n    while(ans[digit] == 0) {\n        digit--;\n    }\n    for(int i = 0; i < digit; i++) cout << ans[i] << \" \";\n    cout << ans[digit] << endl;\n}\n"
  },
  {
    "id": "array07",
    "instruction": "一次考試中，於所有及格學生中獲取最低分數者最為幸運，反之，於所有不及格同學中，獲取最高分數者，可以說是最為不幸，而此二種分數，可以視為成績指標。\n\n請你設計一支程式，讀入全班成績（人數不固定），請對所有分數進行排序，並分別找出不及格中最高分數，以及及格中最低分數。\n\n當找不到最低及格分數，表示對於本次考試而言，這是一個不幸之班級，此時請你印出 `worst case`；反之，當找不到最高不及格分數時，請你印出 `best case`。\n\n（註：假設及格分數為 $60$）。\n\n第一行輸入學生人數，第二行為各學生分數（$0\\sim 100$ 間），分數與分數之間以一個空白間格。\n每一筆測資的學生人數為 $1\\sim 20$ 的整數。\n\n每筆測資輸出三行。\n\n第一行由小而大印出所有成績，兩數字之間以一個空白間格，最後一個數字後無空白；\n第二行印出最高不及格分數，如果全數及格時，於此行印出 `best case`；\n第三行印出最低及格分數，如果全數不及格時，於此行印出 `worst case`。\n\n",
    "output": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\tint n; \n\tint a[20];\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a, a+n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << a[i] << \" \\n\"[i == n-1];\n\t}\n\n\tint pass_idx = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] >= 60) {\n\t\t\tpass_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pass_idx == 0) {\n\t\tcout << \"best case\\n\";\n\t}\n\telse {\n\t\tcout << a[pass_idx - 1] << \"\\n\";\n\t}\n\n\tif (pass_idx == n) {\n\t\tcout << \"worst case\\n\";\n\t}\n\telse {\n\t\tcout << a[pass_idx] << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "id": "array08",
    "instruction": "給定 $n$ 個骰子排成一列，一開始都是點數 $1$ 朝上，點數 $4$ 朝前，點數 $2$ 朝右 (如下圖所示)，另外骰子的展開圖如下下圖所示。\n\n![](https://i.imgur.com/CdoUMc0.png)![](https://i.imgur.com/1L6ezur.png)\n\n接下來有 $m$ 次修改操作，每個操作包含兩個整數 $a$, $b$ \n\n若 $a$, $b$ 都是正整數，交換編號 $a$ 與編號 $b$ 的骰子的位置。 ($a$ 可能等於 $b$)\n若 $b$ 為 $-1$，將編號 $a$ 的骰子向前旋轉。 (點數 $1$ 朝上 $\\rightarrow$ 點數 $3$ 朝上)\n若 $b$ 為 $-2$，將編號 $a$ 的骰子向右旋轉。 (點數 $1$ 朝上 $\\rightarrow$ 點數 $5$ 朝上)\n在 $m$ 次操作結束之後，依序輸出編號 $1$ 到編號 $n$ 的骰子朝上的點數。\n\n第一行包含兩個正整數 $n$, $m$。\n\n接下來 $m$ 行每行有兩個整數，第 $i$ 行的兩個正整數表示第 $i$ 次操作。\n\n$1\\le n\\le 20$\n$1\\le m\\le 100$\n在一行輸出 $n$ 個數字以空格分隔，第 $i$ 個數字表示編號 $i$ 的骰子最後朝上的點數。\n",
    "output": "#include<bits/stdc++.h>\nusing namespace std;\n\nint up[21], migi[21], front[21];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n,m,a,b;\n    cin >> n >> m;\n    for(int i=1;i<=n;i++){\n        up[i] = 1;\n        front[i] = 4;\n        migi[i] = 2;\n    }\n    for(int i=1;i<=m;i++){\n        cin >> a >> b;\n        if(b == -1) {\n            int t = up[a];\n            up[a] = 7-front[a];\n            front[a] = t;\n        }\n        else if(b == -2) {\n            int t = up[a];\n            up[a] = 7-migi[a];\n            migi[a] = t;\n        }\n        else {\n            swap(up[a],up[b]);\n            swap(migi[a],migi[b]);\n            swap(front[a],front[b]);\n        }\n    }\n    for(int i=1;i<=n;i++) cout << up[i] << \" \\n\"[i==n];\n}"
  },
  {
    "id": "array09",
    "instruction": "盧卡斯數是一個很像斐波那契數的數列。但是，最初兩個盧卡斯數是 $L_0 = 2$ 和 $L_1 = 1$，而不是 $0$ 和 $1$。所以，盧卡斯數的性質與斐波那契數的性質有些不同。\n\n盧卡斯數可以定義如下：\n$$\nL_n = L(n) = \\begin{cases}\n2, & \\text{if }n = 0\\\\\\\n1, & \\text{if }n = 1\\\\\\\nL(n-1)+L(n-2), & \\text{if }n > 1\\\\\\\n\\end{cases}\n$$\n\n現在給你一個數字 $n$，請你求出 $L(n) \\mod 1000000007$ 的結果\n\n一行包含一個非負整數 $n$\n$n<100000$\n\n一行包含一個數字代表 $L(n) \\mod 1000000007$ 的結果\n",
    "output": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    if(n == 0) {\n        cout << 2 << '\\n';\n        return 0;\n    }\n    int a = 1, b = 2;\n    for(int i=1;i<n;i++){\n        int t = a;\n        a = (a+b)%mod;\n        b = t;\n    } \n    cout << a << '\\n';\n}"
  },
  {
    "id": "dc01",
    "instruction": "請你實作基於分治法的 $O(N \\log N)$ 合併排序法。\n\n本題目的是排序練習，請不要使用 `std::sort`, `std::nth_element` 等任何對排序有直接或間接幫助的 STL 函式。\n\n輸入第一行是一個正整數 $N$。\n第二行有 $N$ 個數字 $a_1, a_2, \\dots, a_N$，代表待排序的數字。\n\n輸入保證 $1\\le N\\le 2\\times 10^5$，$1\\le a_i\\le 10^9$。\n\n輸出一行 $N$ 個以空白分隔的整數，表示將輸入排序好的結果。\n\n",
    "output": "#include<vector>\n#include<iostream>\n\n// merge two sorted arrays\nstd::vector<int> merge(std::vector<int> a, std::vector<int> b){\n    std::vector<int> ret;\n    for(int i = 0, j = 0; i < a.size() || j < b.size();)\n        if(i < a.size() && (j == b.size() || a[i] < b[j]))\n             ret.push_back(a[i++]);\n        else ret.push_back(b[j++]);\n    return ret;\n}\n\nstd::vector<int> merge_sort(std::vector<int> a){\n    // base case\n    if(a.size() <= 1) return a;\n\n    // split a into two\n    std::vector<int> left, right;\n    for(int i = 0; i < a.size()/2; i++)\n        left.push_back(a[i]);\n    for(int i = a.size()/2; i < a.size(); i++)\n        right.push_back(a[i]);\n\n    return merge(merge_sort(left), merge_sort(right));\n}\n\nint main() {\n    // read input\n    int n;\n    std::cin >> n;\n    std::vector<int> a(n);\n    for(int i = 0; i < n; i++) std::cin >> a[i];\n\n    std::vector<int> b = merge_sort(a);\n\n    for(int i = 0; i < n; i++) std::cout << b[i] << \" \";\n    std::cout << std::endl;\n}\n"
  },
  {
    "id": "dc02",
    "instruction": "小宇和他大量的朋友在一條獨木舟上，所有人由前到後坐成一排，突然獨木舟前面進水了！為了平衡進水的重量，小宇一行人想要規劃座位讓體重較重的人坐後面。\n\n由於獨木舟狹窄，一次只能交換相鄰兩個人的位置。小宇希望最後由前到後所有人的體重是遞增排列的，並想知道所需要的交換位置次數。已知任兩個人體重都不相同。\n\n輸入第一行是一個整數 $N$，代表小宇一行人人數。\n\n第二行是 $N$ 個以空白相分隔的整數 $a_i$，代表由前到後每個人的重量。\n\n輸入保證 $2\\le N \\le 10^5$，$1\\le a_i\\le 10^9$，所有 $a_i$ 都相異。\n\n輸出一個整數，代表讓所有人由前到後重量遞增所需的交換次數。\n\n",
    "output": "#include<vector>\n#include<iostream>\n#include<utility>\n#include<cstdint>\n\n// data = {sorted array, # of inversions}\ntypedef std::pair<std::vector<int>, int64_t> data;\n\n// merge two data\ndata merge_inversion(data a, data b){\n    std::vector<int> ret;\n    int64_t cnt = a.second + b.second;\n    auto &aa = a.first, &bb = b.first;\n\n    for(int i = 0, j = 0; i < aa.size() || j < bb.size();)\n        if(i < aa.size() && (j == bb.size() || aa[i] <= bb[j]))\n             ret.push_back(aa[i++]), cnt += j;\n        else ret.push_back(bb[j++]);\n\n    return {ret, cnt};\n}\n\ndata count_inversion(std::vector<int> a){\n    // base case\n    if(a.size() <= 1) return {a, 0};\n\n    // split a into two\n    std::vector<int> left, right;\n    for(int i = 0; i < a.size()/2; i++)\n        left.push_back(a[i]);\n    for(int i = a.size()/2; i < a.size(); i++)\n        right.push_back(a[i]);\n\n    return merge_inversion(count_inversion(left),\n                           count_inversion(right));\n}\n\nint64_t get_inversion(std::vector<int> a){\n    return count_inversion(a).second;\n}\n\n\nint main() {\n    // read input\n    int n;\n    std::cin >> n;\n    std::vector<int> a(n);\n    for(int i = 0; i < n; i++) std::cin >> a[i];\n\n    std::cout << get_inversion(a) << std::endl;\n}\n"
  },
  {
    "id": "dc03",
    "instruction": "在一座戒備森嚴的碉堡中，有 $N$ 組每組 $2$ 人的士兵在守衛，其中第 $i$ 組士兵能力值排名第 $i$。碉堡的兩邊都有可能被攻擊，因此理想狀況下，一個穩定的碉堡防禦應該讓能力最強的人在內側，也就是排成 $N, N-1, \\dots, 2, 1, 1, 2, \\dots, N-1, N$。\n\n根據這個理論，將軍把每個士兵的穩定值定義為有多少組排名比自己大的士兵兩人在自己的異側，而碉堡防禦值為所有士兵的穩定值總和。例如：三組士兵排成 $1, 3, 2, 3, 1, 2$，他們穩定值分別為 $0, 0, 1, 0, 1, 0$，因此雕堡防禦值為 $2$。\n\n現在給一個士兵的排列，請你回答碉堡防禦值為和？\n\n輸入第一行是一個整數 $N$，表示有多少組士兵。\n\n輸入第二行是 $2N$ 個以空白分隔的整數 $a_i$，依序代表整排士兵的能力值排名。\n\n輸入保證 $1\\le a_i\\le N$，且每個數字恰出現兩次。\n\n對於 $20\\%$ 的測資，保證 $N\\le 1000$。\n對於剩下 $40\\%$ 的測資，保證 $N\\le 40000$。\n對於剩下 $40\\%$ 的測資，保證 $N\\le 100000$。\n\n輸出一行一個整數代表雕堡防禦值。\n\n",
    "output": "#include<vector>\n#include<iostream>\n#include<utility>\n#include<cstdint>\n#include<cassert>\n\n// vec = [{height, weight}]\n// first  visit: weight = -1\n// second visit: weight =  1\ntypedef std::vector<std::pair<int, int>> vec;\n\n// data = {sorted array, answer}\ntypedef std::pair<vec, int64_t> data;\n\n// merge two data\ndata merge_inversion(data a, data b){\n    vec ret;\n    int64_t cnt = a.second + b.second;\n    auto &aa = a.first, &bb = b.first;\n\n    for(int i = 0, j = 0; i < aa.size() || j < bb.size();)\n        if(i < aa.size() && (j == bb.size() || aa[i].first <= bb[j].first))\n             ret.push_back(aa[i]), cnt += j*aa[i].second, i++;\n        else ret.push_back(bb[j++]);\n\n    return {ret, cnt};\n}\n\ndata count_inversion(vec a){\n    // base case\n    if(a.size() <= 1) return {a, 0};\n\n    // split a into two\n    vec left, right;\n    for(int i = 0; i < a.size()/2; i++)\n        left.push_back(a[i]);\n    for(int i = a.size()/2; i < a.size(); i++)\n        right.push_back(a[i]);\n\n    return merge_inversion(count_inversion(left),\n                           count_inversion(right));\n}\n\nint64_t get_inversion(vec a){\n    return count_inversion(a).second;\n}\n\n\nint main() {\n    // read input\n    int n;\n    std::cin >> n;\n    vec a(2*n);\n    std::vector<bool> visited(n+1);\n    for(int i = 0; i < 2*n; i++){\n        std::cin >> a[i].first;\n        a[i].second = visited[a[i].first]?-1:1;\n        visited[a[i].first] = true;\n    }\n\n    std::cout << get_inversion(a) << std::endl;\n}\n"
  },
  {
    "id": "dc04",
    "instruction": "學姐最討厭逆序數對了！一個長度為 $N$ 且數字全部相異的數列 $[A_1, A_2,\\cdots, A_n]$ 如果有一個逆序數對 $(i,j)$，那對學姐造成的不舒服程度會是 $A_i + A_j$，一個數列對學姐造成的不舒服程度是所有逆序數對造成的不舒服程度的總和，請幫學姐計算一個數列的不舒服程度。\n\n輸入第一行有一個正整數 $N$，代表數列的長度。第二行有 $N$ 個以空格分隔的正整數 $A_1, A_2, \\cdots A_N$，代表詢問的陣列。\n\n- $1 \\le N \\le 3\\times 10^5$\n- $1 \\le A_i \\le 10^{7}$\n- $A_1, A_2, \\cdots, A_N$ 兩兩相異\n\n輸出一個整數，代表這個陣列的不舒服程度。\n",
    "output": "#include<vector>\n#include<iostream>\n#include<utility>\n#include<cstdint>\n\n// data = {sorted array, # of inversions}\ntypedef std::pair<std::vector<int>, int64_t> data;\n\n// merge two data\ndata merge_inversion(data a, data b){\n    std::vector<int> ret;\n    int64_t ans = a.second + b.second, bb_sum = 0;\n    auto &aa = a.first, &bb = b.first;\n\n    for(int i = 0, j = 0; i < aa.size() || j < bb.size();)\n        if(i < aa.size() && (j == bb.size() || aa[i] <= bb[j]))\n             ret.push_back(aa[i]), ans += (int64_t)j*aa[i] + bb_sum, i++;\n        else ret.push_back(bb[j]), bb_sum += bb[j], j++;\n\n    return {ret, ans};\n}\n\ndata count_inversion(std::vector<int> a){\n    // base case\n    if(a.size() <= 1) return {a, 0};\n\n    // split a into two\n    std::vector<int> left, right;\n    for(int i = 0; i < a.size()/2; i++)\n        left.push_back(a[i]);\n    for(int i = a.size()/2; i < a.size(); i++)\n        right.push_back(a[i]);\n\n    return merge_inversion(count_inversion(left),\n                           count_inversion(right));\n}\n\nint64_t get_inversion(std::vector<int> a){\n    return count_inversion(a).second;\n}\n\n\nint main() {\n    // read input\n    int n;\n    std::cin >> n;\n    std::vector<int> a(n);\n    for(int i = 0; i < n; i++) std::cin >> a[i];\n\n    std::cout << get_inversion(a) << std::endl;\n}\n"
  },
  {
    "id": "dc05",
    "instruction": "緯緯有透視眼，所以他可以看到所有刮刮卡能賺多少或是會虧多少。不過老闆發現緯緯行跡詭異，因此規定緯緯只能買連號的刮刮卡。現在緯緯決定找聰明的你合作，請幫他算出他最多能賺多少錢。\n\n註：由於緯緯已經被老闆盯上了，一張都不買的話老闆是不會放他出去的。\n\n輸入第一行有一個正整數 $N (1 \\leq N \\leq 10^5)$，代表有幾張刮刮卡。\n第二行有 $N$ 個數字 $a_{i} (-10^4 \\leq a_{i} \\leq 10^4)$，代表該刮刮卡的獎金減去成本。\n\n請輸出一個整數代表緯緯最多能賺到的錢。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAXN 100000\n\nint arr[MAXN];\n\nint maxarray (int left, int right)\n{\n\t// resursion stop\n\tif (left > right) return 0;\n\tif (left == right) return arr[left];\n\n\tint middle = (left + right) >> 1;\n\t\n\t// case: right of the left side and left of the right side\n\n\tint left_max = arr[middle], left_sum = arr[middle];\n\tfor (int i = middle - 1; i >= left; i--)\n\t{\n\t\tleft_sum += arr[i];\n\t\tleft_max = max(left_max, left_sum);\n\t}\n\n\tint right_max = arr[middle + 1], right_sum = arr[middle + 1];\n\tfor (int i = middle + 2; i <= right; i++)\n\t{\n\t\tright_sum += arr[i];\n\t\tright_max = max(right_max, right_sum);\n\t}\n\n\t// case: all in the left side and all in the right side\n\n\treturn max(max(left_max + right_max, maxarray(left, middle)), maxarray(middle + 1, right));\n}\n\nint main ()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> arr[i];\n\n\tcout << maxarray(0, n-1);\n}"
  },
  {
    "id": "dc06",
    "instruction": "在最近的字串課程裡，小普學習到了一個新的字串定義，那就是對等。對於兩個長度相同的字串 $A$ 與 $B$，若他們互相對等，則滿足以下兩種條件其中之一：\n1. $A$ 與 $B$ 完全相同  \n2. 若 $A$ 與 $B$ 的長度都是偶數，我們將字串 $A$ 從中間切開，分成兩長度相等的字串 $A_l$, $A_r$；同時也將字串 $B$ 從中間切開，分成兩長度相等的字串 $B_l$, $B_r$。則必定滿足下列其中一種情況：\n\n- $A_l$ 與 $B_l$ 對等，$A_r$ 與 $B_r$ 對等。\n- $A_l$ 與 $B_r$ 對等，$A_r$ 與 $B_l$ 對等。\n  \n\n講師們已經準備好了 $A$ 與 $B$ 當做上課例題，但小普忙著訓練他的神經網路，所以他把作業丟給你，相信聰明如你能幫他判斷兩字串是否對等。\n\n輸入包含兩行，分別是兩個長度相同的字串 $A$ 與 $B$，他們的長度都不超過 $1000000$ ，且只包含小寫英文字母\n若兩字串對等，輸出 ```YES```，否則輸出 ```NO```。\n\n",
    "output": "#include<cstring>\n#include<iostream>\nusing namespace std;\n\nstd::string get_smallest(std::string s) {\n\tif(s.size() % 2 == 1) return s;\n\tstd::string s1 = s.substr(0, s.size()/2);\n\tstd::string s2 = s.substr(s.size()/2);\n\ts1 = get_smallest(s1);\n\ts2 = get_smallest(s2);\n\tif(s1 < s2) return s1 + s2;\n\telse return s2 + s1;\n}\n\nint main() {\n\tstd::string s1,s2;\n\tcin >> s1 >> s2;\n\ts1 = get_smallest(s1);\n\ts2 = get_smallest(s2);\n\tif(s1 == s2) std::cout << \"YES\" << std::endl;\n\telse std::cout << \"NO\" << std::endl;\n}\n"
  },
  {
    "id": "dc07",
    "instruction": "五邊形是平面國中的一位地理學者。某日，他證明了某種特別的紅色山脈可以讓全國 GDP 變成 $3$ 倍，這種山脈因此被稱作好山脈。\n\n好山脈的定義如下：\n平面國中的山基於不明原因，都是寬為 $1$ 的矩形，所以一個山脈可以用數列 $m_1,m_2,...,m_n$ 來描述。\n要了解什麼是好山脈，要先了解什麼是 $k$ 階山脈，一個長度為 $N$ 的山脈是 $k$ 階山脈若且唯若以下兩者之一成立：\n\n- $N = 1$ 且 $m_1 = k$。\n- 存在正整數 $t$ 使得 $N = 2^t$ 且以下兩種情況其中之一成立：\n    - $m_1,m_2,...m_{N/2}$ 符合 $(k+1)$ 階好山脈的定義且 $m_{N/2+1}=m_{N/2+2}=....=m_N=k$。\n    - $m_1 = m_2 =...=m_{N/2} = k$ 且 $m_{N/2+1},m_{N/2+2},...,m_{N}$ 符合 $(k+1)$ 階好山脈的定義。\n\ne.g. $2\\ 3\\ 1\\ 1$ 是個 $1$ 階山脈。\n如果一個山脈是 $0$ 階山脈，那它就是好山脈。\n\n五邊形今天找到了一個長為 $2^t$ 的山脈，他知道改變一座山的高度要花一單位的錢，他想知道要把這座山變成好山脈要至少要花多少錢，請你寫個程式幫他算出答案。\n\n第一行有一個正整數 $N$ 代表山脈的長度，保證 $N$ 是 $2$ 的某個次方。\n第二行有 $N$ 個用空格分開的整數 $m_1,m_2,...,m_N$，代表山脈中的山的高度。\n\n- $1 \\le N \\le 2^{18} = 262144$\n- $0 \\le m_i \\le 18, \\forall i$\n\n最少要花多少錢才能把這座山脈變成好山脈。\n\n",
    "output": "#include<vector>\n#include<iostream>\nusing namespace std;\n\n// the cost of making 'a' 'lvl'-good.\nint solve(std::vector<int> a, int lvl) {\n    // base case\n\tif(a.size() == 1) return a[0] == lvl?0:1;\n\n    int left_cost = 0, right_cost = 0;\n    std::vector<int> left, right;\n    for(int i = 0; i < a.size()/2; i++){\n        left.push_back(a[i]);\n        if(a[i] != lvl) left_cost++;\n    }\n    for(int i = a.size()/2; i < a.size(); i++){\n        right.push_back(a[i]);\n        if(a[i] != lvl) right_cost++;\n    }\n\n    return min(left_cost  + solve(right, lvl+1),\n               right_cost + solve(left , lvl+1));\n}\n\nint main() {\n    // read input\n    int n;\n    std::cin >> n;\n    std::vector<int> a(n);\n    for(int i = 0; i < n; i++) std::cin >> a[i];\n\n    std::cout << solve(a, 0) << std::endl;\n}\n"
  },
  {
    "id": "dc08",
    "instruction": "桌上有 $N$ 個箱子排成一列，每個箱子的驚喜度分別為 $A_1, A_2, \\dots, A_N$，小 K 隨意選擇一個連續區段的所有箱子（可以只有一個箱子）。接著小 K 要打開選擇的箱子，假設區間內箱子的驚喜度是 $A_L, A_{L+1}, \\dots A_R$，定義開箱精彩度是 $\\min(A_L, A_{L+1}, \\dots, A_R)$。\n\n小 K 總共有 $\\frac{N(N+1)}{2}$ 種選擇方式，請你求出所有方式的開箱精彩度總和。\n\n輸入第一行是一個整數 $N$，表示箱子數量。\n接著一行是 $N$ 個空白分隔的整數 $A_1, A_2, \\dots, A_N$ 表示每個箱子的驚喜度。\n\n輸入保證 $1\\le N\\le 10^5$，$1\\le A_i\\le 10^9$。\n\n輸出一個整數表示開箱精彩度總和。\n\n",
    "output": "#include<vector>\n#include<iostream>\n#include<utility>\n#include<cstdint>\n\n// data = {sorted array, # of inversions}\ntypedef std::pair<std::vector<int>, int64_t> data;\n\n// merge two data\ndata merge_inversion(data a, data b){\n    std::vector<int> ret;\n    int64_t cnt = a.second + b.second;\n    auto &aa = a.first, &bb = b.first;\n\n    for(int i = 0, j = 0; i < aa.size() || j < bb.size();)\n        if(i < aa.size() && (j == bb.size() || aa[i] <= bb[j]))\n             ret.push_back(aa[i++]), cnt += j;\n        else ret.push_back(bb[j++]);\n\n    return {ret, cnt};\n}\n\nint64_t solve(std::vector<int> a){\n    // base case\n    if(a.size() == 0) return 0;\n    if(a.size() == 1) return a[0];\n\n    // split a into two\n    std::vector<int> left, right;\n    for(int i = a.size()/2-1; i >= 0; i--)\n        left.push_back(a[i]);\n    for(int i = a.size()/2; i < a.size(); i++)\n        right.push_back(a[i]);\n\n    // preprocess partial mins\n    std::vector<int> lmin = left, rmin = right;\n    for(int i = 1; i < rmin.size(); i++) rmin[i] = std::min(rmin[i-1], rmin[i]);\n    for(int i = 1; i < lmin.size(); i++) lmin[i] = std::min(lmin[i-1], lmin[i]);\n\n    int64_t ans = 0;\n\n    // if min occurs at the left\n    for(int i = 0, j = 0; i < left.size(); i++){\n        while(j < right.size() && rmin[j] >= lmin[i]) j++;\n        ans += (int64_t) lmin[i] * j; // [0, j) is the good region\n    }\n\n    // if strict min occurs at the right\n    for(int i = 0, j = 0; j < right.size(); j++) {\n        while(i < left.size() && lmin[i] > rmin[j]) i++;\n        ans += (int64_t) rmin[j] * i;\n    }\n\n    return ans + solve(left) + solve(right);\n}\n\n\nint main() {\n    // read input\n    int n;\n    std::cin >> n;\n    std::vector<int> a(n);\n    for(int i = 0; i < n; i++) std::cin >> a[i];\n\n    std::cout << solve(a) << std::endl;\n}\n"
  },
  {
    "id": "dc09",
    "instruction": "我看著坐在前面的同學，雖然沒有很壯碩的肩膀，但看著他的背影，心中浮現一股內斂強者的霸場，像是一座山。\n\n……不對，不只是像是，前面的同學太高了，根本就是一座山。\n\n教室內有一排 $n$ 個人的座位，由前往後從 $1$ 到 $N$ 編號，第 $i$ 個人坐下時的身高為 $h_i$ ，而且帶了高度為 $p_i$ 的座墊。若 $j$ 排在 $i$ 之前且 $j$ 的身高大於 $i$ 加了座墊的高度，也就是 $h_j > h_i + p_i$，則我們說 $j$ 是 $i$ 的「大山」。若 $j$ 是 $i$ 最後面的大山，則兩人之間的人數 $i−j−1$ 稱為第 $i$ 個人和山的距離 $S_i$ 。\n\n如果第 $i$ 個人沒有「大山」，則山的距離 $S_i = i-1$ ，也就是排在他之前全部的人數。\n\n舉例來說，假設 $N=5$，身高 $h$ 依序為 $[5,4,1,1,3]$ 而座墊的高度 $p$ 依序是 $[0,0,4,0,1]$ 。\n\n1. 編號 $1$ 的人前面沒有人，所以 $S_1=0$ 。\n2. $h_2+p_2=4$ ，而 $2$ 往前第一個大於 $4$ 的是 $h_1 = 5$ ，所以 $S_2 = 2 - 1 - 1 = 0$ 。\n3. $h_3+p_3=5$ ，前面沒有人的身高大於 $5$ ，所以 $S_3=2$ 。\n4. $h_4+p_4=1$ ， $h_2=4>1$ ，所以 $S_4=4–2–1=1$ 。\n5. $h_5+p_5=4$ ， $h_1=5>4$ ，所以 $S_5=5–1–1=3$ 。\n\n故 $S_i$ 總和為 $6$ 。\n\n輸入 $h$ 與 $p$ ，請計算 $\\sum _ {i = 1} ^ {N} {S_i}$ 。\n\n輸入第一行是一個整數 $N$。\n第二行有 $N$ 個正整數 $h_1 \\sim h_N$ 。\n第二行有 $N$ 個非負整數 $p_1 \\sim p_N$ 。\n\n輸入保證 $1\\le N\\le 2 \\cdot 10^5$，$1\\le h_i \\le 10 ^ 9, 0 \\le p_i \\le 10^9$ 。\n\n輸出一行一個整數表示 $\\sum _ {i = 1} ^ {N} {S_i}$ 。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(vector<pair<int, int>>& h, vector<pair<int, int>>& hp,\n\t\tvector<int>& ans, int lb, int rb) {\n\tif (lb + 1 == rb) return; // base case\n\tint mid = (lb + rb) / 2;\n\tsolve(h, hp, ans, lb, mid); // 遞迴解決子問題\n\tsolve(h, hp, ans, mid, rb);\n\n\t// 從大的開始看，對每一個 rp 都把左邊比他大的丟進去\n\tint lp = mid - 1, rp = rb - 1, cur_max_j = -1;\n\tfor (; rp >= mid; --rp) {\n\t\twhile (lp >= lb and h[lp].first > hp[rp].first) {\n\t\t\tcur_max_j = max(cur_max_j, h[lp].second);\n\t\t\tlp--;\n\t\t}\n\t\t// 不能直接 = ，要取最大值\n\t\t// 不然會蓋掉已經在子問題得到的答案\n\t\tans[hp[rp].second] = max(ans[hp[rp].second], cur_max_j);\n\t}\n\n\t// 用 STL 做合併排序\n\tinplace_merge(begin(h) + lb, begin(h) + mid, begin(h) + rb);\n\tinplace_merge(begin(hp) + lb, begin(hp) + mid, begin(hp) + rb);\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\t// 用 std::pair 存原本位置，更新答案用\n\tvector<pair<int, int>> h(n), hp(n);\n\t// ans[i]: 對於 i 來說滿足條件的最大 j\n\t// 將初始答案設成 -1 是為了方便計算\n\tvector<int> ans(n, -1);\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> h[i].first;\n\t\th[i].second = i;\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> hp[i].first;\n\t\thp[i].first += h[i].first;\n\t\thp[i].second = i;\n\t}\n\n\tsolve(h, hp, ans, 0, n);\n\n\t// 記得開 long long\n\t// 真的很重要\n\tlong long sum = 0ll;\n\tfor (int i = 0; i < n; ++i)\n\t\tsum += i - ans[i] - 1;\n\n\tcout << sum << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "id": "dc10",
    "instruction": "老方剛學習 C++ 程式語言，最近他學到一種叫做陣列的資料結構，他有一個長度為 $N$ 的陣列 $a_1, a_2, \\ldots, a_N$，他想知道給定整數 $x$，有多少數對 $(l, r)$ 滿足 $1 \\leq l \\leq r \\leq n$ 使得區間 $[l, r]$ 中的元素和小於 $x$，也就是 $a_l + a_{l + 1} + \\cdots + a_r < x$，這讓老方遇到了困難，請你幫助他完成任務。 \n\n輸入第一行包含兩個整數 $N, x (1 \\leq N \\leq 2 \\times 10^5, |x| \\leq 10^{14})$。\n輸入第二行包含 $N$ 個整數 $a_1, a_2, \\ldots, a_N (|a_i| \\leq 10^9)$。\n\n請輸出一個整數代表有多少區間的元素和小於 $x$。\n\n",
    "output": "#include<vector>\n#include<iostream>\n#include<utility>\n#include<cstdint>\n\n// data = {sorted array, # of inversions}\ntypedef std::pair<std::vector<int64_t>, int64_t> data;\n\n// merge two data\ndata merge(data a, data b, const int64_t k){\n    std::vector<int64_t> ret;\n    auto &aa = a.first, &bb = b.first;\n    int64_t ans = a.second + b.second;\n\n    // calculating answer\n    for(int i = 0, j = 0; j < bb.size(); j++){\n        while(i < aa.size() && bb[j] - aa[i] >= k) i++;\n        ans += aa.size()-i; // [i, aa.size()-1] is the good region\n    }\n\n    // merge-sorting\n    for(int i = 0, j = 0; i < aa.size() || j < bb.size();)\n        if(i < aa.size() && (j == bb.size() || aa[i] <= bb[j]))\n             ret.push_back(aa[i++]);\n        else ret.push_back(bb[j++]);\n\n    return {ret, ans};\n}\n\n// recieves partial sum\ndata solve(std::vector<int64_t> a, const int64_t k){\n    // base case\n    if(a.size() <= 1) return {a, 0};\n\n    // split a into two\n    std::vector<int64_t> left, right;\n    for(int i = 0; i < a.size()/2; i++)\n        left.push_back(a[i]);\n    for(int i = a.size()/2; i < a.size(); i++)\n        right.push_back(a[i]);\n\n    return merge(solve(left, k), solve(right, k), k);\n}\n\n\nint main() {\n    // read input\n    int n; int64_t k;\n    std::cin >> n >> k;\n    std::vector<int64_t> a(n+1);\n    for(int i = 1; i <= n; i++) std::cin >> a[i], a[i] += a[i-1];\n\n    std::cout << solve(a, k).second << std::endl;\n}\n"
  },
  {
    "id": "dc11",
    "instruction": "如果一個長度為 $N$ 的序列中，數字 $1$ 至 $N$ 皆恰好出現一次，這個序列就被稱作一個排列 (permutation)，例如：$[1], [3, 5, 4, 1, 2], [3, 1, 2]$ 都是排列，但 $[0], [2, 2], [4, 3, 1]$ 都不是。\n\n大陸人收到一個長度為 $N$ 的排列 $p_1, p_2, \\ldots, p_N$ 當作禮物，但比起排列，大陸人更喜歡樹，所以他決定將這個排列轉換成一棵二元樹，他的作法如下：\n\n- 選取當前序列中最大的元素 $x$ 當作根。\n- 所有在最大元素左邊的元素們會形成 $x$ 的左子樹，建構左子樹的方式與原來的樹相同，如果左邊沒有元素，那麼左子樹就是空的。\n- 所有在最大元素右邊的元素們會形成 $x$ 的右子樹，建構右子樹的方式與原來的樹相同，如果右邊沒有元素，那麼右子樹就是空的。\n\n以下是一個例子，考慮一個排列 $p = [3, 5, 2, 1, 4]$，一開始被拿來當根的元素是 $p_2 = 5$，左子樹和右子樹將分別由 $p[1 \\ldots 1] = [3]$ 與 $p[3 \\ldots 5] = [2, 1, 4]$ 建構而成，最後建構出來的二元樹如下：\n\n![](https://i.imgur.com/SYCmDb3.png)\n\n設 $d_i$ 代表節點 $p_i$ 的深度，也就是該點與樹根之間路徑邊的數量，請幫大陸人算出每個點的深度 $d_i$ 是多少。\n\n輸入第一行有一個正整數 $N (1 \\leq N \\leq 10^5)$，代表數列的長度。\n數入第二行包含 $N$ 個正整數，代表為一個長度為 $N$ 的排列 $p_1, p_2, \\ldots, p_N$。\n\n請在一行輸出 $N$ 個整數 $d_1, d_2, \\ldots, d_N$，代表 $N$ 個節點 $p_1, p_2, \\ldots, p_N$ 的深度。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int n; cin >> n;\n  vector<int> p(n + 1);\n  set<pair<int, int>> s;\n  for(int i = 1; i <= n; i++) cin >> p[i], s.insert(make_pair(p[i], i));\n  vector<int> ans(n + 1);\n  \n  function<void(int, int, int, set<pair<int, int>>&)> Solve = [&](int l, int r, int d, set<pair<int, int>> &s) {\n    if(l > r) return;\n    auto [x, id] = *prev(s.end());\n    ans[id] = d;\n\n    s.erase(prev(s.end()));\n    int l_sz = id - l, r_sz = r - id;\n    if(l_sz > r_sz) {\n      set<pair<int, int>> sr;\n      for(int i = id + 1; i <= r; i++) {\n        auto tmp = make_pair(p[i], i);\n        s.erase(tmp);\n        sr.insert(tmp);\n      }\n      Solve(l, id - 1, d + 1, s);\n      Solve(id + 1, r, d + 1, sr);\n    }\n    else {\n      set<pair<int, int>> sl;\n      for(int i = l; i < id; i++) {\n        auto tmp = make_pair(p[i], i);\n        s.erase(tmp);\n        sl.insert(tmp);\n      }\n      Solve(l, id - 1, d + 1, sl);\n      Solve(id + 1, r, d + 1, s);\n    }\n  };\n\n  Solve(1, n, 0, s);\n  for(int i = 1; i <= n; i++) cout << ans[i] << \" \\n\"[i == n];\n  return 0;\n}\n"
  },
  {
    "id": "dc12",
    "instruction": "每十年一次，來自世界各地頂尖的糕點師傅都會到東京的富士山來比劃自己的糕點程度，想要奪得「天下第一」的名號。在富士山上，有 $N$ 個糕點排成一排，會由來自當地的糕點師傅柳德 政男（りゅうめぐむ  まさお）主持評分，將第 $i$ 個糕點給 $x_i$ 分。接下來，他會隨機選擇兩個數字 $l,r(1 \\leq l \\leq r \\leq N)$，並且從編號 $l$ 的糕點看到編號 $r$ 的糕點。如果這些糕點內，有一個糕點的評分是**嚴格**高於區間內的所有其他糕點的評分的話，那這個糕點就會被選為「高點糕點」。\n\n請問有幾個選擇 $l,r$ 的方法使得這個區間有辦法選出一個「高點糕點」？\n\n輸出將有兩行。第一行有一個正整數 $N(1 \\leq N \\leq 10^5)$ 代表有幾個糕點。第二行有 $N$ 個數字，第 $i$ 個數字代表給第 $i$ 個糕點的評分 $x_i(1 \\leq x_i \\leq 10^9)$。\n\n請輸出一個數字，代表有幾個區間有辦法找出「高點糕點」。\n\n",
    "output": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#define ericxiao ios_base::sync_with_stdio(0);cin.tie(0);\nusing namespace std;\n\nconst int maxN = 1e5 + 326;\nint N, arr[maxN];\nlong long int ans;\n\nvoid solve(int l = 0, int r = N){\n    if((r - l) <= 1){\n        ans += r - l;\n        return;\n    }\n    int m = (l + r) / 2;\n    solve(l, m);\n    solve(m, r);\n    vector<int> lm, rm; //l/r monotone\n    //must encompass m - 1, m\n    //setting up l\\r m\n    lm.push_back(m - 1); \n    rm.push_back(m);\n    for(int i = m - 2; i >= l; i--) if(arr[i] >= arr[lm.back()]) lm.push_back(i);\n    lm.push_back(l - 1);\n    for(int i = m + 1; i < r; i++) if(arr[i] >= arr[rm.back()]) rm.push_back(i);\n    rm.push_back(r);\n    //left side is max\n    int cur = m, idx;\n    for(int i = 0; i < lm.size() - 1; i++){\n        idx = lm[i];\n        if(i && (arr[lm[i - 1]] == arr[lm[i]])) continue; //not unique\n        while(cur < r && arr[cur] < arr[idx]) cur++;\n        if(cur >= r || (cur > m && arr[cur - 1] < arr[idx])){\n            ans += (long long int)(lm[i] - lm[i + 1]) * (cur - m);\n        }\n    }\n    //right side is max\n    cur = m - 1;\n    for(int i = 0; i < rm.size() - 1; i++){\n        idx = rm[i];\n        if(i && (arr[rm[i]] == arr[rm[i - 1]])) continue; //not unique\n        while(cur >= l && arr[cur] < arr[idx]) cur--;\n        if(cur < l || (cur < m - 1 && arr[cur + 1] < arr[idx])){\n            ans += (long long int)(rm[i + 1] - rm[i]) * (m - 1 - cur);\n        }\n    }\n}\n\nint main() {\n\tericxiao\n    cin >> N;\n    for(int i = 0; i < N; i++) cin >> arr[i];\n    solve();\n    cout << ans << endl;\n}\n"
  },
  {
    "id": "dc13",
    "instruction": "小風生日將至，他收到 $N$ 件禮物，他幫每一件禮物都打上一個「美麗度」$t_i$，小風想選取一些禮物使得禮物的美麗度總和正好是他想要的值，他選取禮物的方式很特別，他會操作若干次（包含零次）以下的操作並選取禮物們：\n\n- 計算出 $mid = \\lfloor \\frac{max + min}{2} \\rfloor$，其中 $max$ 與 $min$ 分別代表目前剩餘禮物裡的美麗值的最大與最小值。\n- 將禮物分成兩堆，其中一堆的美麗值均不超過 $mid$，另一堆均超過 $mid$。\n- 留下其中一堆，把另一推排除掉。\n\n請你幫小風回答以下 $Q$ 則詢問，每一個詢問會有一個整數 $s_i$，小風想問你他能不能經過若干次以上操作讓剩餘的禮物美麗度總和恰為 $s_i$？\n\n輸入第一行包含兩個正整數 $N, Q (1 \\leq N, Q \\leq 10^5)$，分別代表禮物的數量與詢問的個數。\n輸入第二行有 $N$ 個正整數 $t_1, t_2, \\ldots, t_N (1 \\leq t_i \\leq 10^6)$，代表每個禮物的美麗度。\n接下來 $Q$ 行，第 $i$ 行有一個正整數 $s_i (1 \\leq t_i \\leq 10^9)$，代表第 $i$ 個詢問。\n\n一共輸出 $Q$ 行，每個詢問佔一行。對於第 $i$ 個詢問，若小風能夠讓禮物美麗度總和恰為 $s_i$，請輸出 `Yes`，否則請輸出 `No`。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int n, q; cin >> n >> q;\n  vector<int> a(n);\n  vector<long long> pre(n + 1);\n  for(int i = 0; i < n; i++) cin >> a[i];\n  sort(a.begin(), a.end());\n  for(int i = 1; i <= n; i++) pre[i] = pre[i - 1] + a[i - 1]; // [0, i)\n\n  set<long long> s;\n\n  auto Sum = [&](int l, int r)->long long { // [l, r)\n    return pre[r] - pre[l];\n  };\n  function<void(int, int)> Solve = [&](int l, int r) {\n    if(l == r) return;\n    s.insert(Sum(l, r));\n    int x = (a[l] + a[r - 1]) / 2;\n    int k = upper_bound(a.begin(), a.end(), x) - a.begin();\n    if(k <= l || k >= r) return;\n    Solve(l, k), Solve(k, r);\n  };\n\n  Solve(0, n);\n  while(q--) {\n    int x; cin >> x;\n    cout << (s.find(x) != s.end() ? \"Yes\" : \"No\") << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "id": "dc14",
    "instruction": "小普正在油漆行打工，今天他的任務是粉刷柵欄，柵欄由 $N$ 個寬度為一單位的柱子排成一列所組成，由左往右數來第 $i$ 根柱子的高度是 $a_i$ 單位。\n由於小普是個細心的油漆工，而他的油漆刷寬度剛好也是一單位，他規定自己每次只能橫向粉刷一排柵欄或著垂直粉刷一根柵欄，而且單次粉刷過程中，油漆刷都不能離開柵欄表面。\n舉例來說，假設組成柵欄的柱子高度依序為 ```2 2 1 2 1```，則其中一種粉刷方式為先橫向粉刷所有柵欄的第一層，再橫向粉刷第 $1$ 、 $2$ 根柵欄的第二層，最後在粉刷剩下的第 $4$ 根柵欄的第二層，總共需要 $3$ 次粉刷。\n小普希望能在滿足規定的前提下盡早回家，聰明如你能幫小普算出最少需要幾次粉刷，才能將整個柵欄都粉刷過一遍呢？\n輸入第一行為一個正整數 $N (1 \\leq N \\leq 100000)$，代表柵欄的寬度。\n輸入第二行包含 $N$ 個用空白分隔的正整數 $a_i (1 \\leq a_i \\leq 10^9)$，代表由左往右數來第 $i$ 根柱子的高度。\n\n輸出一個整數，代表最少需要幾次粉刷，才能將整個柵欄都粉刷過一遍。\n",
    "output": "#include<vector>\n#include<set>\n#include<iostream>\n#include<cassert>\n\ntypedef std::vector<int>::iterator it;\nstruct cmp{\n    bool operator()(const it& a, const it& b){\n        if(*a == *b) return a - b < 0; // tie breaker\n        else return *a < *b;\n    }\n};\ntypedef std::set<it, cmp> data;\n\n\ndata remove_from_set(data& st, it beg, it end){\n    data st2;\n    for(it i = beg; i != end; i++)\n        assert(st.find(i) != st.end()), st.erase(i), st2.insert(i);\n    return st2;\n}\n\nint solve(it beg, it end, data& st, int height){\n    if(beg == end) return 0;\n\n    int ans;\n\n    // finish off mid horizontally and recurse\n    it mid = *st.begin();\n    st.erase(mid);\n    if(mid-beg < end-mid){\n        data st2 = remove_from_set(st, beg, mid);\n        assert(int(st2.size()) == mid - beg); assert(int(st.size()) == end-mid-1);\n        ans = *mid - height + solve(beg, mid, st2, *mid) + solve(mid+1, end, st, *mid);\n    }else{\n        data st2 = remove_from_set(st, mid+1, end);\n        assert(int(st.size()) == mid - beg); assert(int(st2.size()) == end-mid-1);\n        ans = *mid - height + solve(beg, mid, st, *mid) + solve(mid+1, end, st2, *mid);\n    }\n    // if(1){\n    //     for(it i = beg; i != end; i++) std::cout << *i << \" \"; std::cout << std::endl;\n    //     std::cout << ans << std::endl << std::endl;\n    // }\n    return std::min<int>(ans, end-beg); // paint vertically\n}\n\nint main() {\n    // read input\n    int n;\n    std::cin >> n;\n    std::vector<int> a(n);\n    for(int i = 0; i < n; i++) std::cin >> a[i];\n\n    data d;\n    for(it i = a.begin(); i != a.end(); i++) d.insert(i);\n\n    std::cout << solve(a.begin(), a.end(), d, 0) << std::endl;\n}\n"
  },
  {
    "id": "dc15",
    "instruction": "在一座草原上遍佈著許多美麗的花朵，每一株花朵都可以用一個二維平面座標 $(x_i, y_i)$ 來代表他在草原上的位置。小風想要在這座廣闊無際的草原上蓋一棟房子，他想要偷偷用圍籬將一些花朵圍起來，這樣他就可以獨自欣賞這些美麗的花朵了。小風的圍籬可以用兩條鉛直線 $x = l, x = r$ 以及一條水平線 $y = a$ 來表示，在這三條直線圍起來向上無限延伸的矩形區域就是小風的家了，如圖為一個例子，其中 $p_1$ 在小風家內，而 $p_2$ 不在內，注意 $l, r, a$ 均可以為任意實數。\n\n![](https://i.imgur.com/27wz5Zf.png)\n\n小風想要知道幾種花朵們的集合是剛好可以被他為在圍欄裡的，因為小風一定要欣賞花朵，所以不可以沒有包住任何花朵，請你幫助他計算可能的數量。只要有一株花朵在其中一個集合而不在另一個集合中，這兩個集合就被視為相異的。\n\n以下為一個例子：四株花朵分別座落於 $(1, 1), (1, 2), (2, 1), (2, 2)$，一共有六種可能的集合，其中兩個集合恰包含一株花朵，三個集合恰包含兩株花朵，一個集合包含所有花朵。\n\n![](https://i.imgur.com/w1HzbCz.png)\n\n\n輸入第一行包含一個正整數 $N (1 \\leq N \\leq 2 \\times 10^5)$，代表草原上花朵的數量。\n接下來的 $N$ 行，第 $i$ 包含兩個整數 $x_i, y_i (1 \\leq x_i, y_i \\leq 10^9)$，代表第 $i$ 株花朵的座標位置。\n輸入保證所有花朵的座標街相異。\n\n請輸出一個整數代表有幾種可能的花朵集合可以被小風圍起來。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int n; cin >> n;\n  vector<pair<int, int>> p(n);\n  vector<int> vx;\n  for(int i = 0; i < n; i++) {\n    cin >> p[i].first >> p[i].second;\n    vx.push_back(p[i].first);\n  }\n  auto GetX = [&](int x) {\n    return lower_bound(vx.begin(), vx.end(), x) - vx.begin() + 1;\n  };\n  sort(vx.begin(), vx.end());\n  vx.resize(unique(vx.begin(), vx.end()) - vx.begin());\n  for(int i = 0; i < n; i++) p[i].first = GetX(p[i].first);\n\n  int m = int(vx.size());\n  vector<int> vis(m + 1);\n\n  sort(p.begin(), p.end(), [&](auto x, auto y) {\n      return x.first != y.first ? x.first < y.first : x.second > y.second;});\n\n  vector<int> bit(m + 1);\n  auto Add = [&](int x, int d) {\n    for(int i = x; i <= m; i += (i & -i)) bit[i] += d;\n  };\n  auto Query = [&](int x) {\n    int res = 0;\n    for(int i = x; i; i -= (i & -i)) res += bit[i];\n    return res;\n  };\n\n  long long ans = 0;\n  function<void(int, int)> Solve = [&](int l, int r) {\n    if(l >= r) return;\n\n    int mid = (l + r) >> 1;\n    int x_mid = p[mid].first;\n    int left_end, right_begin;\n    for(int i = l; i < r; i++) {\n      if(p[i].first == x_mid) {\n        Solve(l, left_end = i);\n        break;\n      }\n    }\n    for(int i = r - 1; i >= l; i--) {\n      if(p[i].first == x_mid) {\n        Solve(right_begin = i + 1, r);\n        break;\n      }\n    }\n\n    vector<pair<int, int>> vl, vm, vr;\n    for(int i = l; i < left_end; i++) vl.push_back(p[i]);\n    for(int i = left_end; i < right_begin; i++) vm.push_back(p[i]);\n    for(int i = right_begin; i < r; i++) vr.push_back(p[i]);\n\n    auto Merge = [&](vector<pair<int, int>> vl, vector<pair<int, int>> vr) {\n      vector<pair<int, int>> res;\n      int i = 0, j = 0;\n      while(i < int(vl.size()) && j < int(vr.size())) {\n        if(vl[i].second > vr[j].second) res.push_back(vl[i++]);\n        else res.push_back(vr[j++]);\n      }\n      while(i < int(vl.size())) res.push_back(vl[i++]);\n      while(j < int(vr.size())) res.push_back(vr[j++]);\n      return res;\n    };\n\n    vector<pair<int, int>> tmp = Merge(Merge(vl, vm), vr);\n    assert(int(tmp.size()) == r - l);\n    vector<int> op;\n\n    for(int i = 0, j = 0; i < int(tmp.size()); i = j) {\n      int l_pos = 0, r_pos = m + 1;\n\n      while(j < int(tmp.size()) && tmp[j].second == tmp[i].second) {\n        if(!vis[tmp[j].first]) {\n          Add(tmp[j].first, 1), vis[tmp[j].first] = 1;\n          op.push_back(tmp[j].first);\n        }\n        if(tmp[j].first <= x_mid) l_pos = max(l_pos, tmp[j].first);\n        if(tmp[j].first >= x_mid) r_pos = min(r_pos, tmp[j].first);\n        j++;\n      }\n\n      int l_num = Query(x_mid), r_num = Query(m) - Query(x_mid - 1);\n      int l_bad = l_num - Query(l_pos), r_bad = Query(r_pos - 1) - Query(x_mid - 1);\n      ans += 1LL * l_num * r_num - 1LL * l_bad * r_bad;\n    }\n    \n    for(auto x : op) Add(x, -1), vis[x] = 0;\n    for(int i = l; i < r; i++) p[i] = tmp[i - l];\n  };\n\n  Solve(0, n);\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "dc16",
    "instruction": "河豚國是一個由互相聯通的 $n$ 個點和 $n - 1$ 條邊所組成的無向圖。\n小 P 最近想要體驗壯遊，他希望能在河豚國找出最長的一條路徑。\n也就是從某個點出發，不重複的經過一些點直到另一個點（可以是起點），經過的邊長度總和盡量大。\n\n注意邊長度有可能是負的。 \n\n一行包含一個正整數 $n$\n接下來有 $n-1$ 行，每行包含兩個數字 $a$, $b$, $c$\n代表編號為 $a$ 的城市與編號為 $b$ 的城市中間有一條長度為 $c$ 的道路。\n\n$n \\le 1000000$\n$1 \\le a,b \\le n$\n$|c| \\le 1000000000$\n\n請輸出一個數字代表最大的「經過的邊長度總和」\n",
    "output": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6+5;\nlong long dp[N], ans = 0;\nvector<pair<int,int> > v[N];\nvoid dfs(int x,int fa) {\n    for(auto& pr : v[x]) if(pr.first != fa) {\n        dfs(pr.first, x);\n        ans = max(ans, dp[x]+dp[pr.first]+pr.second);\n        dp[x] = max(dp[x], dp[pr.first]+pr.second);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n,a,b,c;\n    cin >> n;\n    for(int i=1;i<=n-1;i++){\n        cin >> a >> b >> c;\n        v[a].emplace_back(b,c);\n        v[b].emplace_back(a,c);\n    }\n    dfs(1,1);\n    cout << ans << '\\n';\n}"
  },
  {
    "id": "dp01",
    "instruction": "小明已經厭倦了在數學課本中生活了，他決定去外面的世界闖一闖。出現在他面前的，是一座有 $N$ 階的樓梯。小明突然意識到他一次可以爬一階或兩階，「不…不行…我已經不是以前的我了……但我真的好想算我能用幾種方式爬上這樓梯…」，看來他老毛病又復發了，請你大發慈悲幫他算一下他可以用幾種不同方式爬上樓梯。\n\n一個整數 $N$ 代表樓梯有幾階。\n\n- $1 \\le N \\le 5 \\times 10^6$\n\n一次可以爬一階或兩階，有幾種方式爬上這樓梯，請輸出答案除以 $10^9+7$ 的餘數。\n\n",
    "output": "#include <iostream>\nusing namespace std;\nint main() {\n\tint N;\n\tcin >> N;\n\tint fn[2];\n\tfn[0] = 0;\n\tfn[1] = 1;\n\tfor(int i=0; i<N; i++)\n\t{\n\t\tint tmp = fn[1];\n\t\tfn[1] = fn[0] + fn[1];\n\t\tfn[1] %= 1000000007;\n\t\tfn[0] = tmp;\n\t}\n\tcout << fn[1] << endl;\n}\n"
  },
  {
    "id": "dp02",
    "instruction": "小波喜歡美食，他總共會遇到 $N$ 道依序上菜的美食，小波可以選擇其中的一些來品嚐。每道菜都有一個正整數的美味值，而小波希望他品嚐的每一道菜都嚴格比之前品嚐的菜更美味。\n\n舉例而言，如果有 $5$ 道菜分別有美味值 $7,8,8,9,4$，則小波可以品嚐第 $1, 2, 4$ 道菜，分別有美味值 $7, 8, 9$。但小波不能品嚐第 $2,3,4$ 道菜，因為第 $3$ 道菜並沒有比第 $2$ 道菜更加美味。\n\n給一個上菜的序列，想請問小波最多能品嚐幾道菜。\n\n輸入第一行是一個整數 $N$，代表一共有幾道菜。\n\n輸入第二行是 $N$ 個以空白分隔的整數 $a_i$，依序代表美食的美味值。\n\n輸入保證 $1\\le N\\le 5000$，$1\\le a_i\\le 10^9$。\n\n輸出一行一個整數，代表在適當安排下，小波最多可以吃到幾道菜。\n\n",
    "output": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 5010;\nint a[maxn];\nint dp[maxn];\nint main() {\n    // Read input\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; i++) {\n        cin >> a[i];\n    }\n    // Perform DP\n    int res = 0;\n    for(int i = 0; i < N; i++) {\n        int mx = 0;\n        for(int j = 0; j < i; j++) {\n            if(a[j] < a[i]) mx = max(mx, dp[j]);\n        }\n        dp[i] = mx+1;\n        res = max(res, dp[i]);\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "id": "dp03",
    "instruction": "小石腳受傷了，但他被困在湖中央，要出去只能靠一排 $N$ 個橫向等間距、高低不同的石頭。這 $N$ 個石頭分別具有高度 $h_1, h_2, \\dots, h_N$。\n\n小石在編號 $1$ 的石頭上，他必須跳到編號 $N$ 的石頭上才算逃脫。因為他的腳傷，他縱向跳躍時會感到不適，但橫向則不會。他在一次從第 $i$ 個石頭到第 $j$ 個石頭的跳躍中感受到的不適值是 $|h_i - h_j|$。然而他也有跳躍距離限制，當他在石頭 $i$ 時，他只能跳到石頭 $i+1, i+2,\\dots, i+K$ 上。他整段路的不適值是所有跳躍不適值的加總。\n\n對於給定的 $N,K$ 和石頭高度 $h_1, h_2, \\dots, h_N$，請你求出最小可能的不適值為何。\n\n輸入第一行是兩個以空白分隔的整數，分別代表 $N, K$。\n\n輸入第二行是 $N$ 個以空白分隔的整數，代表 $h_1, h_2, \\dots, h_N$。\n\n輸入保證 $1\\le N\\le 10^5$，$1\\le K\\le 100$，$1\\le h_i\\le 10^9$。\n\n輸出一行一個整數，代表最小走完這段路的不適值。\n\n",
    "output": "#include <iostream>\nusing namespace std;\nconst int maxn = 100010;\nlong long a[maxn], dp[maxn];\nint main() {\n    // Read input\n    int N,K;\n    cin >> N >> K;\n    for(int i = 1; i <= N; i++) {\n        cin >> a[i];\n    }\n    // Perform DP\n    // Base condition\n    dp[1] = 0;\n    // Main DP\n    for(int i = 2; i <= N; i++) {\n        long long mn = 1e18;\n        for(int j = max(1, i-K); j < i; j++) {\n            mn = min(mn, dp[j] + abs(a[i]-a[j]));\n        }\n        dp[i] = mn;\n    }\n    cout << dp[N] << endl;\n}\n"
  },
  {
    "id": "dp04",
    "instruction": "小晴養了一隻倉鼠，為了讓倉鼠學習，小晴設計了一個 $N \\times M$ 的表格，每個格子上都有堅果，並且每個堅果都有不同的好吃度。小晴希望倉鼠從表格最左上角的格子開始走到最右下角的格子，但是途中只能夠往下或往右走，路途中遇到的堅果都必須吃掉，而小晴希望倉鼠在看完地圖後能夠找到一條路徑讓吃到的堅果好吃度總和最大。但倉鼠只是一隻倉鼠，牠根本什麼都不會，請你各位幫幫這隻可憐的倉鼠吧！\n\n輸入第一行有兩個正整數 $N, M (1 \\leq N, M \\leq 10^5, 1 \\leq N \\times M \\leq 10^5)$，分別代表表格的長度與寬度。\n接下來的 $N$ 行，每一行都有 $M$ 個數字 $a_{ij} (1 \\leq a_{ij} \\leq 10^9)$，代表該格子堅果的好吃度。\n\n請輸出一個整數代表倉鼠可以吃到的最大好吃度總和。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int n, m; cin >> n >> m;\n  vector<vector<int>> v(n, vector<int>(m));\n  vector<vector<long long>> dp(n, vector<long long>(m));\n\n  for(int i = 0; i < n; i++)\n    for(int j = 0; j < m; j++) cin >> v[i][j];\n  \n  dp[0][0] = v[0][0];\n  for(int i = 0; i < n; i++) {\n    for(int j = 0; j < m; j++) {\n      if(i) dp[i][j] = max(dp[i][j], dp[i - 1][j] + v[i][j]);\n      if(j) dp[i][j] = max(dp[i][j], dp[i][j - 1] + v[i][j]);\n    }\n  }\n  cout << dp[n - 1][m - 1] << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "dp05",
    "instruction": "在代達羅斯建造的迷宮中，有個區域是被下了神秘魔法的方陣，高為 $N$，寬為 $M$，入口在左上角，而出口是個會隨日期變化的傳送門，以 $Q$ 天為一個變化週期。因為此地的魔法規則，每次移動只能往右或往下移動一格。方陣中有些地方會有石柱，它們會擋住去路。伊卡洛斯今天很無聊，想請你計算在各個日期中，從入口走到出口的方式有幾種。\n\n第一行有三個數字 $N,M,Q$，代表方陣的高、寬、出口變化的週期。\n接下來 $N$ 行，每行有 $M$ 個屬於 $\\{0,1\\}$ 的數字，$1$ 代表這個位置有石柱，反之則無。入口一定沒有石柱。\n再接下來 $Q$ 行，每行有 $2$ 個數字 $x_i,y_i$，代表第 $i$ 天的出口座標，$x_i$ 是縱座標，由上往下遞增；$y_i$ 是橫座標，由左往右遞增。\n\n- $1 \\le N,M \\le 1000$\n- $1 \\le Q \\le 10^5$\n- $0 \\le x_i < N,\\forall i$\n- $0 \\le y_i < M,\\forall i$\n\n$Q$ 行，每行輸出當天走到出口的方法數除以 $10^9 + 7$ 的餘數。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n#define P 1000000007\nint to_nonnegative(int i)\n{\n\tif( i == -1)\n\t\treturn 0;\n\treturn i;\n}\nint main() {\n\tint N,M,Q;\n\tcin >> N >> M >> Q;\n\tint maze[N][M];\n\tfor(int i=0; i<N; i++)\n\t{\n\t\tfor(int j=0; j<M; j++)\n\t\t{\n\t\t\tint in;\n\t\t\tcin >> in;\n\t\t\tif( in == 1)\n\t\t\t\tmaze[i][j] = -1;\n\t\t\telse\n\t\t\t\tmaze[i][j] = 0;\n\t\t}\n\t}\n\tmaze[0][0] = 1;\n\tfor(int i=0; i<N; i++)\n\t{\n\t\tfor(int j=0; j<M; j++)\n\t\t{\n\t\t\tif(maze[i][j] == -1)\n\t\t\t\tcontinue;\n\t\t\tif(i>0 && j>0)\n\t\t\t\tmaze[i][j] = to_nonnegative(maze[i-1][j]) + to_nonnegative(maze[i][j-1]);\n\t\t\telse if(i > 0)\n\t\t\t\tmaze[i][j] = to_nonnegative(maze[i-1][j]);\n\t\t\telse if(j > 0)\n\t\t\t\tmaze[i][j] = to_nonnegative(maze[i][j-1]);\n\t\t\tmaze[i][j] %= P;\n\t\t}\n\t}\n\tfor(int i=0; i<Q; i++)\n\t{\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tcout << maze[x][y] << endl;\n\t}\n}\n"
  },
  {
    "id": "dp06",
    "instruction": "輸入為 $n\\times m$ 大小的的陣列，每一格是一個介於 $-100$ 與 $100$ 之間的整數，表示經過這格可以累積的經驗值。\n你可以從最上面一排任何一個位置開始，在最下面一排任何一個位置結束。\n過程中每一步可以選擇往左、往右或往下走，但不能走回已經經過的位置。\n請你算出最多可以獲得的經驗值總和（可能是負數）。\n\n第一行有兩個正整數 $n,m(1\\leq n\\leq 50,1\\leq m\\leq 10000)$。\n接下來 $n$ 行，每行包含 $m$ 個整數。第 $i$ 行的第 $j$ 個數字表示在 $(i,j)$ 位置可以得到的經驗值 $v_{ij} (-100\\le v_{ij}\\le 100)$。\n配分：\n\n* $20\\%$：$n=1,1\\leq m\\leq 100$\n* $30\\%$：$1\\leq m\\leq 100$\n* $50\\%$：無額外限制\n\n輸出可以獲得的最多經驗值總和。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 50 + 10, N = 10000 + 10;\nint main() {\n    int m, n, arr[M][N], dp[M][N]={}, tmp[2][N];\n\tcin >> m >> n;\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcin >> arr[i][j];\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tdp[i][j] = dp[i-1][j] + arr[i][j];\n\t\t}\n\t\t/*for (int j = 0; j < n; j++) {\n\t\t\tcout << i << ' ' << j << ' ' << dp[i][j] << endl;\n\t\t}*/\n\t\ttmp[0][0] = dp[i][0];\n\t\ttmp[1][n-1] = dp[i][n-1];\n\t\tfor (int j = 1; j < n; j++) {\n\t\t\ttmp[0][j] = max(dp[i][j], tmp[0][j-1] + arr[i][j]);\n\t\t}\n\t\tfor (int j = n-2; j > -1; j--) {\n\t\t\ttmp[1][j] = max(dp[i][j], tmp[1][j+1] + arr[i][j]);\n\t\t}\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tdp[i][j] = max(dp[i][j], max(tmp[0][j], tmp[1][j]));\n\t\t}\n\t\t/*for (int j = 0; j < n; j++) {\n\t\t\tcout << i << ' ' << j << ' ' << dp[i][j] << endl;\n\t\t}*/\n\t}\n\tint ans = dp[m][0];\n\tfor (int i = 1; i < n; i++) {\n\t\tans = max(ans, dp[m][i]);\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "id": "dp07",
    "instruction": "幸運表格，一個相傳能夠帶給人們幸運的表格。上面充滿了數字，獲得表格的人可以隨機從某個位置出發，並且持續不斷地向右或向下移動直到離開表格為止，而他所獲得的幸運指數即為經過的所有數字相加。\n以下列表格為例：\n\n```\n-1 7 -8 10 -5\n-4 -9 8 -6 0\n5 -2 -6 -6 7\n-7 4 7 -3 -3\n7 1 -6 4 -9\n```\n\n若你從左上角開始，沿著右、下、下、右、右、右、右移動，則你將獲得 $-1+7-9-2-6-6+7=-10$ 的幸運指數。\n\n請注意，這只是舉例如何計算幸運指數，不代表這個表格的最大幸運指數為 $-10$。\n\n這個表格的最大幸運指數應為從第三列第一欄開始，沿著右、下、右、右、下、下移動，你可以獲得 $15$ 的幸運指數。\n\n\n輸入第一行有兩個正整數 $N,M(1 \\leq N,M \\leq 1000)$。\n之後有 $N$ 行，每行有 $M$ 個數字 $a_{ij}(-100 \\leq a_{ij} \\leq 100)$ 用來描述該表格。\n請輸出一個整數，代表該表格所能帶給人的最大幸運指數。\n",
    "output": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\nusing namespace std;\nbool have[1005][1005];\nint DP[1005][1005];\nint all[1005][1005];\nint N,M;\nint ans=-2e9;\nint F(int x,int y)\n{\n    if(x==N||y==M) return 0;\n    if(have[x][y]) return DP[x][y];\n    have[x][y]=1;\n    DP[x][y]=max(F(x+1,y),F(x,y+1))+all[x][y];\n    return DP[x][y];\n}\nint main()\n{\n    int i,j;\n    scanf(\"%d %d\",&N,&M);\n    for(i=0;i<N;i++) for(j=0;j<M;j++) scanf(\"%d\",&all[i][j]);\n    for(i=0;i<N;i++) for(j=0;j<M;j++) ans=max(ans,F(i,j));\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "id": "dp08",
    "instruction": "在一塊方方正正的土地中，市長準備進行都市更新。這塊土地是 $N\\times M$ 的矩形，左上角座標 $(0,0)$，左下角座標 $(N-1, 0)$，右上角座標 $(0, M-1)$，右下角座標 $(N-1, M-1)$。每一個座標 $(i, j)$ 的位置都有一棟價值 $a_{ij}$ 的建築物，一旦這個位置被都更，這棟建築就要被剷平。\n\n市長想選一塊方正的矩形區域作為都更預定地，其中左上角為 $(u,l)$，右下角為 $(d, r)$，矩形兩軸平行都市邊界。他一共會提出 $Q$ 種方案，想問你每種方案分別要剷除多少價值的建築物。\n\n輸入第一行是三個以空白分隔的整數 $N, M, Q$，分別代表都市的長寬和市長提出的方案數。\n\n接下來有 $N$ 行每行 $M$ 個以空白分割的整數，其中第 $i$ 行第 $j$ 個數字表示 $a_{i-1, j-1}$。\n\n接下來 $Q$ 行，每行四個以空白分割的整數 $u, l, d, r$，代表市長提出的都更方案。\n\n輸入保證 $1\\le N, M\\le 500$，$1\\le a_{ij}\\le 10^9$，$1\\le Q\\le 300000$，$0\\le u \\le d < N$，$0\\le l \\le r < M$。\n\n輸出 $Q$ 行，每行包含一個整數，代表該筆詢問需要剷除建築的價值。\n\n",
    "output": "#include <iostream>\nusing namespace std;\nconst int maxn = 510;\nlong long a[maxn][maxn], sum[maxn][maxn];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < M; j++)\n            cin >> a[i][j];\n    }\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < M; j++) {\n            sum[i][j] = a[i][j];\n            if(i) sum[i][j] += sum[i-1][j];\n            if(j) sum[i][j] += sum[i][j-1];\n            if(i&&j) sum[i][j] -= sum[i-1][j-1];\n        }\n    }\n    while(Q--) {\n        int u, l, d, r;\n        cin >> u >> l >> d >> r;\n        long long ans = sum[d][r];\n        if(u) ans -= sum[u-1][r];\n        if(l) ans -= sum[d][l-1];\n        if(u && l) ans += sum[u-1][l-1];\n        cout << ans << '\\n';\n    }\n}\n"
  },
  {
    "id": "dp09",
    "instruction": "在一個社交集會中，一共分為三個會場，其中一個是比較適合文靜的人的寧靜廳，一個比較適合外向的人的嘈雜廳，還有一個介於兩者之間的什麼都不廳。\n\n一共有 $N$ 個人排隊準備參加聚會，你對他們的外向程度瞭若指掌，並給他們每個人打了一個外向分數 $w_i$。\n\n作為分配誰進入哪個會場的人，主管對你只有一個限制是排隊隊伍中連續兩個人不能進入同一個會場，而你想要做適當安排使得全體滿足度最大。其中全體滿足度被定義為嘈雜廳所有人的外向分數總和減去寧靜廳所有人的外向分數總和。請問最高可以達成多少滿足度。\n\n輸入第一行是一個整數 $N$ 代表人數。\n\n第二行是 $N$ 個以空白分隔的整數 $w_i$，代表隊伍中所有人依序的外向分數。\n\n輸入保證 $1\\le N\\le 10^6$，$-1000\\le w_i\\le 1000$。\n\n輸出一行一個整數代表在適當安排下，最大可達成的全體滿足度。\n\n",
    "output": "#include <iostream>\nusing namespace std;\nconst int maxn = 1000010;\nint a[maxn], dp[maxn][3];\nint main() {\n    int n;\n    cin >> n;\n    for(int i = 1; i <= n; i++)\n        cin >> a[i];\n    for(int i = 1; i <= n; i++) {\n        dp[i][0] = max(dp[i-1][1], dp[i-1][2]) - a[i];\n        dp[i][1] = max(dp[i-1][0], dp[i-1][2]);\n        dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + a[i];\n    }\n    cout << max(dp[n][0], max(dp[n][1], dp[n][2])) << endl;\n}\n"
  },
  {
    "id": "dp10",
    "instruction": "在電影節中，有 $N$ 部電影依序被放映，第 $i$ 部電影會帶給你滿足度 $a_i$。每看完一部電影，你可以選擇在緊接下來的時間看這部電影的影評，同樣會給你帶來 $a_i$ 的滿足度，但是你將會錯過下部電影的播放時間。\n\n如果你選擇看影評，你只能在緊連的下一部電影時間看影評，而且你只會錯過下一部電影。如果你看的影評是來自最後放映的電影，則你不會錯過任何電影。請問所能達成最大滿足度為何。\n\n輸入第一行是一個整數 $N$ 代表人數。\n\n第二行是 $N$ 個以空白分隔的整數 $a_i$，代表電影依序的滿足度。\n\n輸入保證 $1\\le N\\le 10^5$，$1\\le a_i\\le 1000$。\n\n輸出一行一個整數代表最大可能的滿足度。\n\n",
    "output": "#include <iostream>\nusing namespace std;\nconst int maxn = 1000010;\nint a[maxn], dp[maxn][2];\nint main() {\n    int n;\n    cin >> n;\n    for(int i = 1; i <= n; i++)\n        cin >> a[i];\n    for(int i = 1; i <= n; i++) {\n        dp[i][0] = max(dp[i-1][1], dp[i-1][0] + a[i]);\n        dp[i][1] = dp[i-1][0] + a[i] * 2;\n    }\n    cout << max(dp[n][0], dp[n][1]) << endl;\n}\n"
  },
  {
    "id": "dp11",
    "instruction": "天府城有一排土地由左到右編號 $1\\sim N$，每塊土地有他蓋一棟建築帶來的價值。你想要在這裏投資一些土地並建起一些房屋，然而由於連續的房屋失火時容易蔓延，你希望投資的所有房屋不會恰形成一段完整的連續區間（也就是說，不存在 $l, r$ 使得對於所有房屋 $x$，$x$ 被你投資若且唯若 $l \\le x \\le r$），並且你不能全部不投資房屋。你的投資總收益是你在所有蓋房屋的土地上收益總和。請你回答在滿足條件下的最大收益。\n\n本題包含多筆測資，輸入第一行是一個整數 $T$，代表測資筆數。\n\n每筆測資輸入兩行，第一行是一個整數 $N$，代表土地數量。\n第二行有 $N$ 個空白分隔的整數 $a_i (1\\le i\\le N)$，代表投資第 $i$ 塊土地價值。\n\n輸入保證 $T\\le 10^5$，$3\\le N\\le 3\\times 10^5$，$-1000\\le a_i\\le 1000$，且單筆輸入所有 $N$ 總和不超過 $3\\times 10^5$。\n\n對於每筆測資輸出一行一個整數，代表最大投資收益。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3e5 + 5;\nint a[maxn], dp[maxn][3];\nint main() {\n    int T;\n    cin >> T;\n    while(T--) {\n        // Read input\n        int n;\n        cin >> n;\n        for(int i = 1; i <= n; i++)\n            cin >> a[i];\n        // Base case\n        dp[0][0] = dp[0][1] = dp[0][2] = -1e9;\n        for(int i = 1; i <= n; i++) {\n            // State 0: built and continuing\n            // State 1: finished a continous interval of building\n            // State 2: finished requirement, can do anything\n\n            // State 0: the last building must be built.\n            dp[i][0] = max(dp[i-1][0], 0) + a[i];\n            // State 1: the last building must not be built\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0]);\n            // State 2: discuss cases\n            dp[i][2] = dp[i-1][2] + max(a[i], 0);\n            dp[i][2] = max(dp[i][2], dp[i-1][1]+a[i]);\n        }\n        //for(int i = 1; i <= n; i++) cout << a[i] << \" \";\n        cout << dp[n][2] << endl;\n    }\n}\n"
  },
  {
    "id": "dp12",
    "instruction": "小 Y 和小 P 獲得了一罐水果軟糖，水果軟糖罐頭尾都有開口，裡面一共有 $N$ 個軟糖，每一顆軟糖都有屬於它的「好吃度」，小 Y 和小 P 都已經知道這 $N$ 顆軟糖的好吃度了。小 Y 和小 P 想要平分這罐水果軟糖，為了公平起見，他們決定輪流從罐子裡取出一顆軟糖，軟糖只能從頭或尾拿出，直到全部被拿完為止，由小 Y 先拿。假設最後小 Y 拿到的水果軟糖好吃度總和為 $Y$，小 P 拿到的水果軟糖好吃度總和為 $P$，雙方都想要最大化自己和對方的差距，也就是說小 Y 想要最大化 $Y - P$，小 P 則想要最小化 $Y - P$，請問在雙方的最佳策略下，$Y - P$ 的值為多少？\n\n輸入第一行有一個正整數 $N (1 \\leq N \\leq 3000)$，代表水果軟糖的數量。\n輸入第二行包含 $N$ 個正整數 $a_1, a_2, \\ldots, a_N (1 \\leq a_i \\leq 10^9)$，分別代表 $N$ 顆水果軟糖的好吃度。\n\n請輸出一個整數代表在雙方最佳策略下 $Y - P$ 的值。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int kN = 3010;\n\nint a[kN];\nlong long dp[2][kN][kN];\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int n; cin >> n;\n  for(int i = 0; i < n; i++) cin >> a[i];\n\n  for(int i = 0; i < n; i++) dp[0][i][i] = a[i], dp[1][i][i] = -a[i];\n  for(int len = 1; len < n; len++) {\n    for(int l = 0; l + len < n; l++) {\n      int r = l + len;\n      dp[0][l][r] = max(a[l] + dp[1][l + 1][r], a[r] + dp[1][l][r - 1]);\n      dp[1][l][r] = min(-a[l] + dp[0][l + 1][r], -a[r] + dp[0][l][r - 1]);\n    }\n  }\n  cout << dp[0][0][n - 1] << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "dp13",
    "instruction": "在一望無際的海灘上，有 $N$ 堆沙堡排成一排，其中由左到右第 $i (1\\le i\\le N)$ 個沙堡有重量 $a_i$。你想把所有沙堡合併成一個大沙堡，但為了維持美觀，你每次只能合併相鄰兩個沙堡。\n\n當你將重量 $x$ 和 $y$ 的沙堡合併時會花你 $x+y$ 單位的力氣，且完成後新的沙堡將會在原來兩沙堡中間的位置，重量即為 $x+y$。與新沙堡相鄰的沙堡就是與舊沙堡相鄰的那些沙堡。\n\n請你回答在這樣的操作下，合成大沙堡的最小力氣。\n\n輸入第一行是一個正整數 $N$，表示沙堡堆數。\n輸入第二行有 $N$ 個空白分隔的整數 $a_1, a_2, \\dots, a_N$，代表由左到右沙堡的重量。\n\n輸入保證 $1\\le N\\le 500$，$1\\le a_i\\le 10^9$。\n\n輸出一行一個整數代表合成一座大沙堡的最小力氣。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 510;\nlong long a[maxn], s[maxn], dp[maxn][maxn];\nint main() {\n    int n;\n    cin >> n;\n    for(int i = 1; i <= n; i++) {\n        cin >> a[i];\n        s[i] = s[i-1] + a[i];\n    }\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            dp[i][j] = 1e18;\n    for(int i = 1; i <= n; i++)\n        dp[i][i] = 0;\n    for(int i = 1; i < n; i++) {\n        for(int j = 1; j <= n-i; j++) {\n            for(int k = j; k < j+i; k++)\n                dp[j][j+i] = min(dp[j][k] + dp[k+1][j+i], dp[j][j+i]);\n            dp[j][j+i] += s[j+i] - s[j-1];\n        }\n    }\n    cout << dp[1][n] << endl;\n}\n"
  },
  {
    "id": "dp14",
    "instruction": "你聽過 H-Game 嗎？想必你一定是箇中高手。\n\n但目前時下最流行的遊戲並不是 H-Game，而是 B-Game。小 A 和小 C 打算利用這款 B-Game 進行一場史詩級的大對決，B-Game 是一款殘酷的卡牌對戰遊戲，檯面有 $N$ 張怪獸卡，排成一個環狀，每張怪獸卡都有相應的戰鬥力。接著兩個人輪流從檯面上取走一張怪獸卡，由小 A 先選擇，為了公平起見，除了第一次選怪獸卡以外，每一次選卡都只能選擇上一位玩家選擇的怪獸卡左邊或右邊。舉例來說，如果場上有五張卡 $1, 2, 3, 4, 5$ 排成環狀，小 A 拿了編號 $3$，小 C 拿了編號 $2$ 以後，小 A 就可以選取編號 $1$ 或 $4$ 的卡片。\n\n由選完怪獸卡後，兩個人會同時發動攻擊，遊戲的勝負就取決於雙方怪獸卡的攻擊力總和，總和較高的人就會取得勝利，小 A 希望他能夠贏得這個遊戲的勝利，而不至於落敗成為 B 咖，請你幫小 A 計算他一開始有__幾種選卡方式__（即第一張卡片）可以幫助他獲得最後的勝利，除此之外，他還想知道在最佳的策略下，他的怪獸們攻擊力總和最高可以達到多少。\n\n輸入第一行包含一個正整數 $N (1 \\leq N \\leq 5000)$，代表檯面上的怪獸卡數量。\n輸入第二行包含 $N$ 個正整數 $w_1, w_2, \\ldots, w_N$，分別代表每一張怪獸的攻擊力，並且它們已按照順時針的順序排在檯面上，輸入保證這些卡片的攻擊力總和不超過 `int` 型態範圍。\n\n請在一行中輸出兩個整數並用一個空白分開，第一個整數代表小 A 一開始有幾種選取卡片的方法可以幫助他在最後獲得勝利，第二個整數代表小 A 最多可以拿到的怪獸攻擊力總和。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int n; cin >> n;\n  vector<int> a(n);\n  for(int i = 0; i < n; i++) cin >> a[i];\n  vector<vector<int>> sum(n, vector<int>(n)), dp(n, vector<int>(n));\n\n  for(int i = 0; i < n; i++) {\n    sum[i][i] = a[i];\n    for(int j = 1; j < n; j++) sum[i][(i + j) % n] = sum[i][(i + j - 1) % n] + a[(i + j) % n];\n  }\n\n  for(int i = 0; i < n; i++) dp[i][i] = a[i];\n  for(int len = 1; len < n; len++) {\n    for(int l = 0; l < n; l++) {\n      int r = (l + len) % n;\n      dp[l][r] = max(a[l] + (sum[(l + 1) % n][r] - dp[(l + 1) % n][r]), a[r] + (sum[l][(r - 1 + n) % n] - dp[l][(r - 1 + n) % n]));\n    }\n  }\n\n  int ans = 0, cnt = 0;\n  for(int i = 0; i < n; i++) {\n    int cur_ans = a[i] + (sum[(i + 1) % n][(i - 1 + n) % n] - dp[(i + 1) % n][(i - 1 + n) % n]);\n    ans = max(ans, cur_ans);\n    if(cur_ans > sum[0][n - 1] - cur_ans) cnt++;\n  }\n  cout << cnt << ' ' << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "dp15",
    "instruction": "你有一片 $N\\times M$ 的巧克力要分送給人，但是每一個小方格可能是黑巧克力也可能是白巧克力。\n你每一次可以沿著邊緣剝下一條 $1\\times X$ 形狀的巧克力送人，只能沿著邊緣剝而且一次必須剝下一整條。剝下來的巧克力要送人那塊不能再細分，但是如果剩下的那塊也是 $1\\times X$ 的形狀則他還可以再細分。\n如果要送人的巧克力有黑有白，你就必須拿黑色或白色染劑把整條染成同樣顏色。黑色染劑只需要塗在白巧克力上，同理白色染劑只需要塗在黑巧克力上。但是染劑難以取得又不健康，你希望最小化被染劑染過的巧克力格數。\n請你求出在選擇適當方法剝巧克力的情況下，最少的染劑用量為何？\n\n輸入第一行是兩個空白分隔的整數 $N, M$，分別代表巧克力片的長寬。\n接下來 $N$ 行 $M$ 個空白分隔的整數 $a_{ij} (1\\le i\\le N, 1\\le j\\le M)$ 等於 $0$ 或 $1$，$0$ 代表第 $i$ 行第 $j$ 列的那格巧克力是白色的，$1$ 代表第 $i$ 行第 $j$ 列的那格巧克力是黑色的。\n\n輸入保證 $1\\le N,M\\le 25$，$0\\le a_{ij}\\le 1$。\n其中 $30\\%$ 的配分，額外滿足$20\\le N+M\\le 50$。\n\n輸出一行一個整數，代表最少需要染幾格巧克力的顏色。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nint a[30][30], dp[30][30][30][30];\nint score(vector<int> vec) {\n    int ones = 0, zeros = 0;\n    for(auto k: vec) {\n        if(k == 0) zeros++;\n        else ones++;\n    }\n    return min(ones, zeros);\n}\nint main() {\n    int n,m;\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= m; j++)\n            cin >> a[i][j];\n    }\n    for(int d = 1; d < n; d++) {\n        for(int i = 1; i <= n-d; i++) {\n            for(int c = 0; c < m; c++) {\n                for(int j = 1; j <= m-c; j++) {\n                    dp[i][i+d][j][j+c] = 1e9;\n                    vector<int> vec;\n                    for(int k = j; k <= j+c; k++) vec.push_back(a[i][k]);\n                    dp[i][i+d][j][j+c] = min(dp[i][i+d][j][j+c], dp[i+1][i+d][j][j+c] + score(vec));\n\n                    vec.clear();\n                    for(int k = j; k <= j+c; k++) vec.push_back(a[i+d][k]);\n                    dp[i][i+d][j][j+c] = min(dp[i][i+d][j][j+c], dp[i][i+d-1][j][j+c] + score(vec));\n\n                    vec.clear();\n                    for(int k = i; k <= i+d; k++) vec.push_back(a[k][j]);\n                    dp[i][i+d][j][j+c] = min(dp[i][i+d][j][j+c], dp[i][i+d][j+1][j+c] + score(vec));\n\n                    vec.clear();\n                    for(int k = i; k <= i+d; k++) vec.push_back(a[k][j+c]);\n                    dp[i][i+d][j][j+c] = min(dp[i][i+d][j][j+c], dp[i][i+d][j][j+c-1] + score(vec));\n                }\n            }\n        }\n    }\n    cout << dp[1][n][1][m] << endl;\n}\n"
  },
  {
    "id": "dp16",
    "instruction": "除了「吃飯、睡覺、打東東」的老故事以外，作為 2021 年的 IOI 銀牌，東東發憤圖強想在 World Final 加冕宇宙冠軍，而發憤圖強就要從發憤塗牆開始。\n牆壁可以視為一個 $H \\times W$ 的棋盤，每個格子需要被漆成黑色或是白色。東東身為一個分治大師，決定採用分治的方法來完成著色，具體來說，東東採取的策略如下：\n\n* 如果當前要塗色的矩形內部所有格子全部都是黑色或白色，那東東可以動用「打東東之術」在一瞬間（$0$ 單位時間內）就將其塗色完成。\n* 否則，東東可以選一條水平或垂直線將其分割成兩個矩形（理所當然分割線不能選在格子上，要選在格子和格子之間），如果把兩個矩形塗色的時間分別是 $c_1$ 和 $c_2$，那東東就可以在 $\\max(c_1,c_2)+1$ 的時間將原本的矩形著色完成。\n\n由於東東想要趕快完成塗色去 $n$ 刷桐生可可的畢業直播，因此他在每次分割的時候都會選擇能最小化總時間的分割方式。\n作為一個油宅，你也想看桐生可可的畢業直播，那麼你能計算出來東東會花多久的時間在粉刷牆壁上，方便你結束之後趕過去跟東東一起看嗎？\n\n第一行有兩個正整數 $H,W(1\\leq H,W\\leq 50)$。\n接下來 $H$ 行，每行包含一個長度為 $W$ 的字串。第 $i$ 行的第 $j$ 個字元是 ```#``` 代表那格是黑色的，是 ```.``` 代表該格是白色的。\n\n輸出東東最快可以在多短的時間內漆完整面牆。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 50 + 10, inf = 1000000000;\nint h, w, arr[N][N], dp[N][N][N][N];\nint main() {\n\tcin >> h >> w;\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == '.') {\n\t\t\t\tarr[i][j] = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarr[i][j] = 1;\n\t\t\t}\n\t\t\tarr[i][j] += arr[i - 1][j] + arr[i][j - 1] - arr[i - 1][j - 1];\n\t\t\t// cout << arr[i][j] << ' ';\n\t\t}\n\t\t// cout << endl;\n\t}\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tfor (int k = 1; k + i <= h; k++) {\n\t\t\t\tfor (int l = 1; l + j <= w; l++) {\n\t\t\t\t\t// dp[k][k+i][l][l+j]\n\t\t\t\t\tif (abs(arr[k + i][l + j] - arr[k - 1][l + j] - arr[k + i][l - 1] + arr[k - 1][l - 1]) == (i + 1) * (j + 1)) {\n\t\t\t\t\t\tdp[k][l][k+i][l+j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint &tmp = dp[k][l][k+i][l+j];\n\t\t\t\t\t\ttmp = inf;\n\t\t\t\t\t\tfor (int x = k; x < k + i; x++) {\n\t\t\t\t\t\t\ttmp = min(tmp, max(dp[k][l][x][l + j], dp[x + 1][l][k + i][l + j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int y = l; y < l + j; y++) {\n\t\t\t\t\t\t\ttmp = min(tmp, max(dp[k][l][k + i][y], dp[k][y + 1][k + i][l + j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp++;\n\t\t\t\t\t}\n\t\t\t\t\t// cout << k << ' ' << l << ' ' << k + i << ' '<< l + j << ' ' << dp [k][l][k + i][l + j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[1][1][h][w] << '\\n';\n}\n"
  },
  {
    "id": "dp17",
    "instruction": "小 B 最近在學習字串相關的演算法，他對迴文字串相當有興趣，對於一個字串 $S$，他想要找到其子序列 $T$ 並讓它是一個迴文，除此之外，他還希望這個子序列 $T$ 越長越好，但太長的字串會讓小 B 頭昏眼花，所以當答案長度超過 $1000$ 的時候你可以直接輸出一個長度只有 $1000$ 的迴文子序列來唬爛小 B，當然更長的序列也沒有問題。\n\n- 一個字串是「迴文」字串代表它倒過來和原本的字串相同。\n- 一個字串的子序列是把它其中一些字元刪去所得到的新字串（可以不刪除任何字元），例如 `3`、`123`、`293`、`11293` 都是 `11293` 的子序列。\n\n輸入只有一行，為一個只由數字字元（`0` 到 `9`）組成的字串 $S$。\n\n輸出 $S$ 中任意一個長度至少為 $\\min(1000, P)$ 的迴文子序列，其中 $P$ 是 $S$ 的最長迴文子序列的長度。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  string s; cin >> s;\n\n  int n = s.length();\n  vector<int> cnt(10);\n  for(int i = 0; i < n; i++) cnt[s[i] - '0']++;\n  for(int i = 0; i < 10; i++) if(cnt[i] >= 1000) {\n    for(int j = 0; j < 1000; j++) cout << i;\n    cout << '\\n';\n    return 0;\n  }\n\n  assert(n <= 10000);\n  vector<vector<int>> dp(n, vector<int>(n));\n  for(int i = 0; i < n; i++) dp[i][i] = 1;\n  for(int len = 1; len < n; len++) {\n    for(int l = 0; l + len < n; l++) {\n      int r = l + len;\n      if(s[l] == s[r]) dp[l][r] = dp[l + 1][r - 1] + 2;\n      else dp[l][r] = max(dp[l + 1][r], dp[l][r - 1]);\n    }\n  }\n\n  bool flag = 0;\n  int l = 0, r = n - 1;\n  string ans;\n  while(l <= r) {\n    if(l == r) {flag = 1; ans += s[l]; break;}\n    else if(s[l] == s[r] && dp[l][r] == dp[l + 1][r - 1] + 2) ans += s[l++], r--;\n    else if(dp[l][r] == dp[l + 1][r]) l++;\n    else r--;\n  }\n  cout << ans;\n  if(flag) ans.pop_back();\n  reverse(ans.begin(), ans.end());\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "dp19",
    "instruction": "有 $N$ 個物品編號 $1 \\sim N$，第 $i$ 個物品的重量和價值分別是 $w_i$ 和 $v_i$。學姐打算從這 $N$ 個物品選其中一些帶走，但她只有大小為 $W$ 的背包，也就是說她選擇的物品總重不能超過 $W$。請問背包能容納的物品的總價值最大是多少？\n\n輸入第一行有兩個正整數 $N$ 和 $W$。接下來 $N$ 行，每行都有兩個正整數，其中的第 $i$ 行的兩個正整數分別是 $w_i$, $v_i$。這些變數都對應到題目的變數。\n\n- $1 \\le N \\le 100$\n- $1 \\le W \\le 10^{5}$\n- $1 \\le w_i \\le W$\n- $1 \\le v_i \\le 10^{9}$\n\n輸出一個正整數，代表背包能容納的物品的總價值最大是多少。\n",
    "output": "/*input\n3 8\n3 30\n4 50\n5 60\n\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long maxn=100005;\n\nlong long dp[maxn];\n\nint main(){\n\tdp[0] = 0;\n\tfor(int i = 1; i < maxn; i++) dp[i] = -1e18;\n\n\tint n,W;\n\tcin>>n>>W;\n\tfor(int t = 0; t < n; t++){\n\t\tint v, w;\n\t\tcin>>w>>v;\n\t\tfor(int i = W; i >= w; i--){\n\t\t\tdp[i] = max(dp[i], dp[i - w] + v);\n\t\t}\n\t}\n\tcout<<*max_element(dp, dp + W + 1)<<'\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "id": "dp20",
    "instruction": "現在地上有 $N$ 條鐵棒，第 $i$ 條的長度為 $l_i$。你的目標是要利用這些鐵棒，焊出一條長度為 $L$ 的長鐵棒，請問有辦法嗎？兩條鐵棒如果長度分別為 $a$ 和 $b$，那它們兩個焊起來之後就會變成一條長度為 $a + b$ 的鐵棒，而且這些鐵棒可以任意焊接。\n\n此外，你必須要回答出 $T$ 種這個問題。\n輸入的第一行有一個數字 $T(1 \\leq T \\leq 50)$，代表有幾個問題。對於每一個問題，都會有兩行的輸入：第一行有兩個數字 $L(1 \\leq L \\leq 1000)$ 和 $N(1 \\leq N \\leq 30)$，代表目標長度的鐵棒與現在有幾根鐵棒。下一行有 $N$ 個數字 $l_i(1 \\leq l_i \\leq 1000)$，代表目前有的鐵棒的長度。保證所有輸出的數字都是正整數。\n\n對於每一筆測資，請輸出一行：倘若能夠達到目標的話，請輸出 `TAK`；否則，請輸出 `NO`。\n",
    "output": "#include <iostream>\nusing namespace std;\n\ninline void solve(){\n\tint N, L, x;\n\tcin >> L >> N;\n\tbool dp[L + 1];\n\tfill(dp, dp + L + 1, 0);\n\tdp[0] = true;\n\twhile(N--){\n\t\tcin >> x;\n\t\tfor(int i = L; i >= x; i--) dp[i] |= dp[i - x];\n\t}\n\tcout << (dp[L] ? \"TAK\" : \"NO\") << endl;\n}\n\nint main() {\n\tint T;\n\tcin >> T;\n\twhile(T--){\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "id": "dp21",
    "instruction": "小峰在玩電車遊戲，這個遊戲規則相當簡單。玩家一共要移動 $N$ 次，每次抽出一個數字 $a_i$，小峰可以選擇往左走或往上走 $a_i$ 公尺，小峰需要最小化遊戲結束時所在位置與起點的距離，請問這個最短距離為何？\n\n輸入第一行是一個整數 $N$，表示移動次數。\n第二行是 $N$ 個整數 $a_1, a_2, \\dots, a_N$，表示每次移動的距離。\n\n輸入保證 $1\\le N\\le 1000$，$1\\le a_i\\le 500$。\n\n輸出一行一個整數，表示最短移動距離的平方。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3e5 + 5;\nint a[maxn];\nbool dp[maxn];\nint main() {\n    dp[0] = 1;\n    int n;\n    cin >> n;\n    long long sum = 0;\n    for(int i = 1; i <= n; i++) {\n        cin >> a[i];\n        sum += a[i];\n    }\n    int target = sum/2;\n    for(int i = 1; i <= n; i++) {\n        for(int j = target; j >= a[i]; j--) {\n            dp[j] = max(dp[j], dp[j-a[i]]);\n        }\n    }\n    long long fin = 0;\n    for(int j = target; j >= 0; j--) {\n        if(dp[j]) {\n            fin = j;\n            break;\n        }\n    }\n    cout << fin * fin + (sum-fin) * (sum-fin) << endl;\n}\n"
  },
  {
    "id": "dp22",
    "instruction": "王老先生有一個置物櫃，共有 $M$ 個相同大小的格子，置物櫃目前已經租給 $n$ 個客戶，第 $i$ 位客戶所租的大小為 $f(i)$ 個格子（$1 \\le i \\le n$）。目前的承租量總和不超過 $M$，但是現在王老先生自己需要使用 $S$ 個格子的置物櫃，如果剩下的容量不夠，就必須退掉某些客戶的租約。假設每個客戶所租容量只能全退或全不退，而退租第 $i$ 個客戶失的利益與其所租容量 $f(i)$ 相同，請寫一支程式計算王老先生最小的損失利益，如果不須退租，則損失為 $0$。\n\n測試資料有兩行，第一行有三個正整數，依序是 $n$、$M$ 與 $S$，其中 $S \\le M$，第二行是 $n$ 個正整數 $f(1), f(2), f(3), \\ldots, f(n)$，同一行的數字間以空白隔開。\n\n* $1 \\leq n \\leq 100$\n* $1\\le S\\le M \\leq 2\\times 10^5$\n* $1\\le f(i)\\le M$，且 $f(i)$ 總和不超過 $M$。\n\n輸出王老先生最小的損失利益。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100 + 10, M = 200000 + 10;\nint main() {\n    int n, m, s, arr[N], sum = 0;\n\tbitset<M> dp[N];\n\tcin >> n >> m >> s;\n\tdp[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> arr[i];\n\t\tsum += arr[i];\n\t\tdp[i] = dp[i-1] | (dp[i-1] << arr[i]);\n\t}\n\tfor (int i = m - s; i > -1; i--) {\n\t\tif (dp[n][i]) {\n\t\t\tcout << sum - i << '\\n';\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n"
  },
  {
    "id": "dp23",
    "instruction": "兩個字串之間的編輯距離被定義為：經由以下三種操作，將兩字串變成相同字串所需的最少操作次數\n\n- 選擇一個字串並在不改變順序下插入一個字元。\n- 選擇一個字串並刪除一個字元\n- 選擇一個字串的某個字元，並把他修改成另一個字元。\n\n給你兩個字串 $s, t$，試求其編輯距離。\n\n輸入有兩行，第一行是字串 $s$，第二行是字串 $t$。\n\n輸入保證 $1\\le |s|, |t| \\le 2000$，且輸入的字元僅包含小寫英文字母。\n\n輸出一行一個整數，代表 $s,t$ 的編輯距離。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2010;\nint dp[maxn][maxn];\n\nint main() {\n    // Read input\n    string s,t;\n    cin >> s >> t;\n    // Convert to 1-indexed\n    int N = s.length(), M = t.length();\n    s = \"#\" + s;\n    t = \"#\" + t;\n    // Base case\n    for(int i = 0; i <= N; i++) dp[i][0] = i;\n    for(int j = 0; j <= M; j++) dp[0][j] = j;\n    // Main algorithm\n    for(int i = 1; i <= N; i++) {\n        for(int j = 1; j <= M; j++) {\n            dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]) + 1, dp[i-1][j-1] + (s[i] != t[j]));\n        }\n    }\n    cout << dp[N][M] << endl;\n}\n"
  },
  {
    "id": "dp24",
    "instruction": "本題改編自 2021 年 1 月 APCS 考古題。\n\n豆島是一個觀光導遊兼顧問，主要負責為旅行社安排行程。為了讓行程看起來緊湊有效率，豆導希望無論如何都只往東北方走，以避免看起來像在往回頭路的方向走。\n\n如果將當前位置座標定在 $(0,0)$，且正 $y$ 軸方向為北方。給定 $N$ 個位於座標 $(x,y)$ 上的景點，豆導希望規劃一條路線使得經過的景點 $x$ 座標總是不比前一個小，$y$ 座標也不比前一個小。\n\n想請問你，基於 $N$ 座城市位置和豆導的堅持下，一個行程最多能包含多少景點。\n\n輸入第一行是一整數 $N$，代表城市數量。\n\n接下來 $N$ 行是兩個空白分隔的整數 $x,y$，代表景點的座標。\n\n對於 $20\\%$ 的輸入，保證 $1\\le n,x,y\\le 100$。\n對於 $30\\%$ 的輸入，保證 $1\\le n\\le 1000$，$1\\le x,y\\le 10^7$。\n對於 $50\\%$ 的輸入，保證 $1\\le n\\le 200000$，$1\\le x,y\\le 10^7$。\n\n輸入保證沒有兩個景點位置完全相同。\n\n輸出一行一個整數，代表最多可以拜訪的景點。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200000 + 10;\npair<int,int> a[maxn];\nint main() {\n    // Read input\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; i++) {\n        cin >> a[i].first >> a[i].second;\n    }\n    // Sort by x-index then by y-index\n    sort(a, a+N);\n    // LIS\n    vector<int> LIS;\n    LIS.push_back(a[0].second);\n    for(int i = 1; i < N; i++) {\n        int idx = upper_bound(LIS.begin(), LIS.end(), a[i].second) - LIS.begin();\n        if(idx == (int)LIS.size()) LIS.push_back(a[i].second);\n        else LIS[idx] = a[i].second;\n    }\n    cout << LIS.size() << endl;\n}\n"
  },
  {
    "id": "dp25",
    "instruction": "你是一個房東，並有 $N$ 個人向你提出租約。其中第 $i$ 個人想從第 $u_i$ 天租到第 $v_i$ 天，並願意支付 $w_i$ 元。你想要選出一些人接受他們的租約。對於每筆租約，你只能全部接受或全部拒絕而不能部分接受，且同一天不能租給兩個不同人。請回答在適當選擇下，你能創造的最高收入是多少？\n\n輸入第一行是一個整數 $N$，代表租約筆數。\n接下來 $N$ 行每行三個空白分隔的正整數 $u_i, v_i, w_i (1\\le i\\le N)$，分別代表起始時間，結束時間和願意付的租金。\n\n輸入保證 $1\\le N\\le 10^3$，$1\\le u_i, v_i, w_i\\le 10^4$。請注意輸入沒有保證兩個租約不會有完全相同的時間區間。\n\n輸出包含最大的收入和列出一種方案。\n\n請輸出兩行，第一行是兩個空白分隔的正整數 $W, M$，代表最多可以獲得的收入是 $W$ 以及存在一種方法可以用 $M$ 筆租約達成。第二行是 $M$ 個空白分隔的正整數，代表要選哪些筆訂單，訂單編號 $1\\sim N$，輸出可以按照任意順序。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n#define pii pair<long long, long long>\nconst int maxn = 2e5 + 5;\n// first.first: end date, first.second: start date, second.first: weight, second.second: id\npair<pii, pii> a[maxn];\nlong long dp[maxn], src[maxn], dest[maxn];\nint main() {\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; i++) {\n        cin >> a[i].first.second >> a[i].first.first >> a[i].second.first;\n        a[i].second.second = i+1;\n        dest[i+1] = a[i].first.second;\n    }\n    sort(a, a+N);\n    vector<int> discrete;\n    for(int i = 0; i < N; i++) {\n        discrete.push_back(a[i].first.first);\n        discrete.push_back(a[i].first.second);\n    }\n    sort(discrete.begin(), discrete.end());\n    for(int i = 0; i < N; i++) {\n        a[i].first.first = lower_bound(discrete.begin(), discrete.end(), a[i].first.first) - discrete.begin() + 1;\n        a[i].first.second = lower_bound(discrete.begin(), discrete.end(), a[i].first.second) - discrete.begin() + 1;\n        dest[i+1] = lower_bound(discrete.begin(), discrete.end(), dest[i+1]) - discrete.begin() + 1;\n    }\n    int cur = 0;\n    for(int i = 1; i <= N*2; i++) {\n        while(cur < N && a[cur].first.first == i) {\n            long long revenue = dp[a[cur].first.second-1] + a[cur].second.first;\n            if(revenue > dp[i]) {\n                dp[i] = revenue;\n                src[i] = a[cur].second.second;\n            }\n            cur++;\n        }\n        if(dp[i-1] > dp[i]) {\n            src[i] = 0;\n            dp[i] = dp[i-1];\n        }\n    }\n    cout << dp[N*2] << \" \";\n    int x = N*2;\n    vector<int> res;\n    while(x) {\n        if(dp[x] == dp[x-1]) {\n            x--;\n            continue;\n        }\n        res.push_back(src[x]);\n        x = dest[src[x]]-1;\n    }\n    cout << res.size() << endl;\n    for(auto x: res) cout << x << \" \"; cout << endl;\n}\n"
  },
  {
    "id": "dp26",
    "instruction": "現在有 $N$ 個數學家在玩漆彈。身為數學家，他們具有三個特性（純粹為方便題目敘述之用，無意冒犯）：\n\n1. 遇到數字就很想要推廣化\n2. 不喜歡一直動來動去\n3. 聽力不怎麼好\n\n因為他們聽力不怎麼好，所以一聽到「七」彈就想要推廣化，變成了 $M$ 彈；而因為他們不喜歡一直動來動去，他們就將 $M$ 彈改良變成了一個新的遊戲，就叫做「$M$ 彈」。這個 $M$ 彈是遊戲的中心，是一個充滿油漆而上面有寫著數字的一顆球。一旦上面的數字歸零了，$K$ 彈就會噴出在其中的油漆，將拿著 $M$ 彈的人重新上色！與其同名的「$M$ 彈」的遊戲規則如下：\n\n- 一開始，這 $N$ 個人坐一圈，人們的編號是順時鐘從 $1$ 到 $N$ 依序編號的。\n- 一開始，編號 $1$ 的數學家拿著上面的數字寫著 $M$ 的 $M$ 彈，然後他會**先將 $M$ 彈的數字減一，再將 $M$ 彈往傳遞給坐在數學家正左邊的人**。\n- 如果數學家手上的 $M$ 彈上寫的數字剛好歸零，則他會被噴一身的油漆病直接出局，$M$ 彈則給坐在他左手邊的人，遊戲繼續。\n- 重複直到 $M$ 彈已經將 $K$ 個人弄出局了。\n\n而定義這個遊戲的贏家就是 $M$ 彈爆炸 $K$ 次之後手上拿著 $K$ 彈的那個人。\n\n給定 $N, M, K$，你有辦法知道這個遊戲的贏家是誰嗎？\n\n舉例來說，倘若 $N = 5$，$M = 2$，$K = 4$，則 $[2, 4, 1, 5]$ 將依序出局，最後的勝者為 $3$ 號數學家。\n\n輸入只有一行，包含三個數字，分別是 $N, M, K(1 \\leq N \\leq 2 \\times 10^5, 1 \\leq M \\leq 10^6, 1 \\leq K < N)$。\n\n此外，這一題有部分給分。\n\n- 對於佔分 $20$ 分的測資，額外保證 $1 \\le N \\le 100$，且 $1 \\le M \\le 10$，$K = N - 1$\n- 對於佔分 $30$ 分的測資，額外保證 $1 \\le N \\le 10^4$，且 $1 \\le M \\le 10^6$，$K = N - 1$\n- 對於佔分 $20$ 分的測資，額外保證 $1 \\le N \\le 2 \\times 10^5$，且 $1 \\le M \\le 10^6$，$K = N - 1$\n\n請輸出一個數字，代表最後贏家的編號。\n",
    "output": "#include <iostream>\nusing namespace std;\n\nconst int maxN = 2e5 + 326;\n\nint N, M, K;\n\nint F(int x, int k){\n\tif(k == 1) return (M) % x;\n\treturn (F(x - 1, k - 1) + (M) % x) % x;\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\tcout << F(N, K) + 1 << endl;\n}\n"
  },
  {
    "id": "dp27",
    "instruction": "在一個大地遊戲中，由左到右有 $N$ 個彼此相距一公尺的攤位。一開始挑戰者在最左邊的攤位左方一公尺處。\n\n在遊戲計時開始後，從左數來第 $i$ 個攤位會從第 $0$ 秒開始每隔 $T_i$ 秒投影一瞬間的綠光。如果挑戰者在此攤位面前被此攤位的綠光照到，就視為通過這個攤位的關卡。挑戰者需要通過全部 $N$ 個關卡各至少一次，結束時可以在任意位置。\n\n請回答挑戰者至少要花多少時間。\n\n輸入第一行是一個整數 $N$，代表攤位數。\n\n第二行是 $N$ 個整數，代表題目所述的 $T_i$。\n\n輸入保證 $1\\le N\\le 16$，$1\\le T_i\\le 10^8$。\n\n輸出一行一個整數代表最快完成時間。\n\n",
    "output": "#include <iostream>\nusing namespace std;\nconst int maxn = (1<<16) + 10;\nint dp[maxn][16], T[20];\nint round_up(int x, int d) {\n    if(x%d == 0) return x;\n    return (x/d+1) * d;\n}\nint main() {\n    // Read input\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; i++)\n        cin >> T[i];\n    // Initialize\n    for(int i = 0; i < (1<<N); i++) {\n        for(int j = 0; j < N; j++)\n            dp[i][j] = 2e9;\n    }\n    // Base condition\n    for(int i = 0; i < N; i++) {\n        dp[(1<<i)][i] = round_up(i+1, T[i]);\n    }\n    // DP\n    for(int i = 0; i < (1<<N); i++) {\n        for(int j = 0; j < N; j++) {\n            if((i&(1<<j)) == 0) continue;\n            for(int k = 0; k < N; k++) {\n                if(k == j || (i&(1<<k)) == 0) continue;\n                dp[i][j] = min(dp[i][j], round_up(dp[i^(1<<j)][k]+abs(j-k), T[j]));\n            }\n        }\n    }\n    // Evaluate\n    int ans = 2e9;\n    for(int i = 0; i < N; i++) {\n        ans = min(ans, dp[(1<<N)-1][i]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "id": "dp28",
    "instruction": "作為一個競速破關玩家 (speedrunner)，你對「撿金幣」遊戲地圖瞭若指掌。一開始玩家會從左上角 $(0,0)$ 開始，並走到右下角 $(N-1, M-1)$ 再回到 $(0,0)$ 算過關。每次只能移動到相鄰的格子，相鄰格子是指有共同邊。在某些格子上有障礙物，有障礙物的格子不能經過，而在沒有障礙物的格子上有些有一枚金幣，經過就可以搜集金幣。\n\n因為你的目標還是 speedrun，你要在 $2(N+M-2)$ 秒過關，你想知道在此條件下，最多能搜集多少金幣。\n\n輸入第一行有兩個空白分的正整數 $N, M$，分別表示地圖的長寬。\n接下來的 $N$ 行，每一行都有 $M$ 個空白分隔的整數 $a_{ij}$，當 $a_{ij} = 0$ 時表示該格是普通格子，$a_{ij} = 1$ 時表示該格有金幣，$a_{ij} = -1$ 時表示該格有障礙物。\n\n輸入保證 $1\\le N, M\\le 100$，$-1\\le a_{ij}\\le 1$。\n\n請輸出一個整數代表最多可搜集的金幣。請注意有可能你無論如何都無法在 $2(N+M-2)$ 秒內通關，此時請輸出 $0$。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100 + 5;\nlong long a[maxn][maxn], dp[210][maxn][maxn];\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < m; j++) {\n\t\t\tcin >> a[i][j];\n            if(a[i][j] == -1) a[i][j] = -1e9;\n        }\n\t}\n    memset(dp, -0x3f, sizeof(dp));\n    dp[0][0][0] = a[0][0];\n    for(int k = 1; k < n+m-1; k++) {\n    \tfor(int i = 0; i < m; i++) {\n            if(i > k || i <= k-n) continue;\n    \t\tfor(int j = 0; j < m; j++) {\n                if(j > k || j <= k-n) continue;\n                dp[k][i][j] = max(dp[k][i][j], dp[k-1][i][j]);\n                if(i) dp[k][i][j] = max(dp[k][i][j], dp[k-1][i-1][j]);\n                if(j) dp[k][i][j] = max(dp[k][i][j], dp[k-1][i][j-1]);\n                if(i && j) dp[k][i][j] = max(dp[k][i][j], dp[k-1][i-1][j-1]);\n                if(i != j) dp[k][i][j] += a[k-i][i] + a[k-j][j];\n                else dp[k][i][j] += a[k-i][i];\n            }\n    \t}\n    }\n    if(dp[n+m-2][m-1][m-1] < 0) dp[n+m-2][m-1][m-1] = 0;\n\tcout << dp[n+m-2][m-1][m-1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "id": "dp29",
    "instruction": "波露特石最近在學習程式語言，他對一些特別的正整數很有興趣，他發現一些十進數的每一位數已排好順序，從高位數往低位數看過去，每一位數字只會相等或變大，例如：$9, 234, 777, 11222233$ 等數字都有這性質，他稱這些數字為階梯數字。給定一正整數 $N$，阿明想知道不大於 $N$ 的階梯數字總共有幾個，請注意本題只算正整數，所以 $0$ 不算階梯數字，而且階梯數字不會以 $0$ 開始。請幫波露特石寫計算階梯數字的個數。\n\n輸入只包含一個正整數 $N$。\n\n請輸出一個整數代表不大於 $N$ 的階梯數字個數，因為答案可能很大，請將答案 $\\mod 10^9 + 7$ 之後輸出。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int kN = 1e5 + 10;\nconst int kMod = 1e9 + 7;\n\nint n, a[kN];\nlong long dp[kN][10][2];\n\nint Add(int x, int y) {\n  x += y;\n  if(x >= kMod) x -= kMod;\n  return x;\n}\n\nlong long Solve(int pos, int cur, bool flag) {\n  if(pos == n) return 1;\n  if(dp[pos][cur][flag] != -1) return dp[pos][cur][flag];\n\n  long long res = 0;\n  if(flag) {\n    for(int i = cur; i <= a[pos]; i++) res = Add(res, Solve(pos + 1, i, i == a[pos]));\n  }\n  else {\n    for(int i = cur; i < 10; i++) res = Add(res, Solve(pos + 1, i, 0));\n  }\n  return dp[pos][cur][flag] = res;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  string s;\n  while(cin >> s) {\n\n    n = s.length();\n    for(int i = 0; i < n; i++) a[i] = s[i] - '0';\n    memset(dp, -1, sizeof(dp));\n\n    cout << Solve(0, 0, 1) - 1 << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "id": "dp30",
    "instruction": "小風和摩卡是某家餐廳的老客人，這家餐廳有 $N$ 道招牌菜，但每天只會推出一道。小風和摩卡分別有一個長度為 $P$ 和 $Q$ 的願望清單，表示他們想吃 $N$ 道菜的哪些。其中同一人的願望清單也可能有重複的菜品，而且願望清單必須依序被滿足。\n\n餐廳老闆想要滿足小風和摩卡的願望清單，他可以自由決定每天推出的招牌菜。如果推出的招牌菜是小風或摩卡願望清單中的下一項，則那個人就會來吃並視為滿足這項願望，兩人可以同時來餐廳。請回答老闆至少要花幾天，以及設計其中一個方案。\n\n輸入共有三行，第一行有三個整數 $N, P, Q$，分別代表招牌菜種類數，以及小風和摩卡的願望清單長度。\n第二行是 $P$ 個空白分隔的整數 $b_1, b_2, \\dots, b_P$，表示小風的願望清單。\n第三行是 $Q$ 個空白分隔的整數 $c_1, c_2, \\dots, c_Q$，表示摩卡的願望清單。\n\n輸入保證 $1\\le N\\le 50$，$1\\le P, Q\\le 1000$，$1\\le b_i, c_i\\le N$。\n\n輸出兩行，第一行是一個正整數 $A$，表示至少要花幾天。\n第二行是 $A$ 個空白分隔的正整數 $a_i, a_2, \\dots, a_A$，其中 $a_i$ 表示第 $i$ 天要推出的招牌菜。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1010;\nint a[maxn], b[maxn], dp[maxn][maxn];\nint main() {\n    int n,p,q;\n    cin >> n >> p >> q;\n    for(int i = 1; i <= p; i++)\n        cin >> a[i];\n    for(int i = 1; i <= q; i++)\n        cin >> b[i];\n    memset(dp, 0x3f, sizeof(dp));\n    for(int i = 0; i <= p; i++) dp[i][0] = i;\n    for(int i = 0; i <= q; i++) dp[0][i] = i;\n    for(int i = 1; i <= p; i++) {\n        for(int j = 1; j <= q; j++) {\n            if(a[i] == b[j]) dp[i][j] = min(dp[i][j], dp[i-1][j-1]+1);\n            dp[i][j] = min(dp[i][j], min(dp[i-1][j] + 1, dp[i][j-1] + 1));\n        }\n    }\n    cout << dp[p][q] << endl;\n    int x = p, y = q;\n    stack<int> s;\n    while(x > 0 || y > 0) {\n        if(x && y && a[x] == b[y] && dp[x-1][y-1] + 1 == dp[x][y]) {\n            s.push(a[x]);\n            x--;\n            y--;\n            continue;\n        }\n        if(x && dp[x-1][y] + 1 == dp[x][y]) {\n            s.push(a[x]);\n            x--;\n            continue;\n        }\n        if(y && dp[x][y-1] + 1 == dp[x][y]) {\n            s.push(b[y]);\n            y--;\n            continue;\n        }\n    }\n    while(!s.empty()) {\n        cout << s.top() << \" \";\n        s.pop();\n    }\n    cout << endl;\n}\n"
  },
  {
    "id": "dp31",
    "instruction": "小 B 擁有一座牧場，牧場是線狀的，此外，上頭共有 $n$ 株草，每一株草的位置可以用一個整數座標來表示。小 B 還養了一頭小牛，一開始位於座標 $x$ 的位置。小 B 的小牛要把牧場上所有的草全部吃光，每一株草的「不新鮮度」定義為從開始到吃掉這株草所花費的時間，小牛每一單位時間可以在牧場上走一單位的長度，小 B 想要幫小牛規劃一套吃草的方法所有草的「不新鮮度」總和最小，請幫小 B 算算看最小的「不新鮮度」總和吧！\n\n輸入第一行包含兩個正整數 $n, x (1 \\leq n \\leq 3000, 1 \\leq x \\leq 10^9)$。\n輸入第二行包含 $n$ 個正整數 $a_1, a_2, \\ldots, a_n (1 \\leq a_i \\leq 10^9)$，分別代表 $n$ 株草的座標。\n\n請輸出一個整數，代表最小「不新鮮度」總和。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int n, x; cin >> n >> x;\n  vector<int> a(n);\n  for(int i = 0; i < n; i++) cin >> a[i];\n  sort(a.begin(), a.end());\n  vector<vector<vector<long long>>> dp(2, vector<vector<long long>>(n, vector<long long>(n, (long long)1e16)));\n\n  for(int i = 0; i < n; i++) dp[0][i][i] = dp[1][i][i] = 1LL * n * abs(x - a[i]);\n  for(int len = 1; len < n; len++) {\n    for(int l = 0; l + len < n; l++) {\n      int r = l + len;\n      dp[0][l][r] = min(dp[0][l + 1][r] + 1LL * (n - len) * abs(a[l] - a[l + 1]), dp[1][l + 1][r] + 1LL * (n - len) * abs(a[l] - a[r]));\n      dp[1][l][r] = min(dp[0][l][r - 1] + 1LL * (n - len) * abs(a[r] - a[l]), dp[1][l][r - 1] + 1LL * (n - len) * abs(a[r] - a[r - 1]));\n    }\n  }\n  cout << min(dp[0][0][n - 1], dp[1][0][n - 1]) << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "dp32",
    "instruction": "欸批奚欸斯奚礦帶是一條長度為 $N$ 公尺的直線礦帶，富商竹竹為了開採秘銀礦，便把礦帶分成了 $N$ 個長度為 $1$ 公尺的礦區並依序編號為 $1$ 到 $N$ ，並記錄含有秘銀礦的礦區編號，然而，礙於技術限制，竹竹只能使用三種規格的採礦機，三種採礦機分別可以開採 $1$ 、 $7$ 、 $30$ 個連續礦區，架設三種採礦機的成本分別為 $b_1, b_2, b_3$。順帶一提，因為竹竹很有錢，所以也連帶買下了礦帶周圍的土地，也就是說採礦機的開採範圍就算超出礦帶也是沒有問題的。\n於是，竹竹來向聰明的你請求協助，他希望你可以幫他計算開採所有的秘銀礦礦區所需要花費的最低成本。\n\n輸入一共有三行。\n第一行包含兩個以空白分隔的正整數 $N, M\\ (1 \\le M \\le N \\le 10^5)$ 代表礦帶的長度以及含有秘銀礦的礦區數量。\n第二行包含 $M$ 個以空白分隔的正整數 $a_i\\ (1 \\le a_i \\le N, a_i > a_j \\forall i > j)$ 代表第 $i$ 個含有秘銀礦的礦區編號。\n第三行包含三個以空白分隔的正整數 $b_1, b_2, b_3\\ (1 \\le b_1, b_2, b_3 \\le 10^7)$ 代表架設三種採礦機的成本。\n\n請輸出一個整數，代表開採所有含秘銀礦的礦區所需要的最低成本。\n\n",
    "output": "#include <bits/stdc++.h>\n#define MAXN 100000\n\nusing namespace std;\n\nint main() {\n    long long dp[MAXN + 30 + 1] = {};\n    int N = 0, M = 0;\n    cin >> N >> M;\n\n    stack<int> spot;\n    while (M--) {\n        int input;\n        cin >> input;\n        spot.push(input);\n    }\n\n    long long costs[3] = {};\n    cin >> costs[0] >> costs[1] >> costs[2];\n\n    for (int i = N; i > 0; i--) {\n        if (!spot.empty() and i == spot.top()) {\n            dp[i] = min(dp[i + 1] + costs[0], dp[i + 7] + costs[1]);\n            dp[i] = min(dp[i], dp[i + 30] + costs[2]);\n            assert(i + 30 < MAXN + 30 + 1);\n            spot.pop();\n        }\n        else {\n            dp[i] = dp[i + 1];\n            assert(i + 1 < MAXN + 30 + 1);\n        }\n    }\n\n    cout << dp[1] << \"\\n\";\n}\n"
  },
  {
    "id": "dp33",
    "instruction": "佳佳不但最喜歡、而且也很擅長刷油漆，因此每當大家有需求都會請佳佳來幫忙刷油漆，然而這次上門的顧客有個特別的需求：\n\n- 他將家中長廊分成了 $N$ 個區段，他希望佳佳一個區段用一種顏色粉刷。\n- 相鄰的兩區段顏色不可以相同，畢竟這樣就看不出區段的交界處了。\n- 他只喜歡庚斯博羅灰、納瓦霍白以及韋奇伍德瓷藍這三種顏色，因此要求佳佳僅以這三種顏色粉刷。\n- 他在每個區段都會對三種顏色進行標價，佳佳會依照他在該區段粉刷的顏色獲得相應的報酬。\n\n為了籌措出國留學所需要的經費，他希望你可以幫忙他找出能讓他獲得最多報酬的方法。\n\n輸入首行有一個正整數 $N$ ，代表顧客走廊的區段數量。\n接下來有 $N$ 行，每行有三個整數，當中的第 $i$ 行的三個整數 $a_i, b_i, c_i$ 分別代表在第 $i$ 個區段上粉刷庚斯博羅灰、納瓦霍白、韋奇伍德瓷藍可以獲得的報酬。\n\n- $1 \\le N \\le 10^6$\n- $1 \\le a_i, b_i, c_i \\le 10^4$\n\n請輸出一個整數代表佳佳可以獲得的最大報酬。\n\n",
    "output": "#include <iostream>\n#define MAX_N 1000000\n#define COLOR_CNT 3\n\nusing namespace std;\n\nint main() {\n    int N;\n    long long dp[MAX_N][COLOR_CNT] = {};\n\n    cin >> N;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < COLOR_CNT; ++j) {\n            cin >> dp[i][j];\n        }\n    }\n\n    for (int i = 1; i < N; ++i) {\n        for (int j = 0; j < COLOR_CNT; ++j) {\n            long long prev_max = 0;\n            for (int k = 0; k < COLOR_CNT; ++k) {\n                if (j == k) {\n                    continue;\n                }\n                prev_max = max(prev_max, dp[i - 1][k]);\n            }\n            dp[i][j] += prev_max;\n        }\n    }\n\n    long long ret = 0;\n    for (int i = 0; i < COLOR_CNT; ++i) {\n        ret = max(ret, dp[N - 1][i]);\n    }\n\n    cout << ret << \"\\n\";\n}\n"
  },
  {
    "id": "dp34",
    "instruction": "現在是暑假，閒閒沒事做的桃子開始亂敲鍵盤，打出了一個無意義的字串。\n\n```\nqwqq\n```\n他想要找到裡面有幾個 `qwq`，你可以幫他找出來嗎？\n\n說明：裡面有 2 個 `qwq`，<strong>qwq</strong>q、<strong>qw</strong>q<strong>q</strong>。\n只要組成字串的 index 組合不一樣，都要列入計數喔！\n\n輸入第一行有一個字串 $P\\ (\\textrm{len}(P) = 3)$。\n輸入第二行有一個字串 $S\\ (1 \\leq \\textrm{len}(S) \\leq 10^6)$。\n字串內只會有小寫英文字母。\n\n輸出一個整數代表 $P$ 在 $S$ 裡面出現了幾次（請參考題目敘述的說明）。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main ()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tlong long count[3] = {};\n\tstring p, s;\n\tcin >> p >> s;\n\n\tfor (int i = 0; i < s.length(); i++)\n\t{\n\t\tfor (int j = 2; j >= 0; j--)\n\t\t{\n\t\t\tif (s[i] == p[j])\n\t\t\t{\n\t\t\t\tif (j) count[j] += count[j-1];\n\t\t\t\telse count[j]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << count[2] << endl;\n}\n"
  },
  {
    "id": "dp35",
    "instruction": "夢想高中的福利社有四種便當分別是 $A$、$B$、$C$、$D$ 餐。\n你在第 $0$ 天點了 $A$ 餐，在限制不能連續兩天吃同一種便當的情況下。你每天點餐且在第 $n$ 天又點了 $A$ 餐的方法數有多少呢？\n由於答案可能很大，請輸出方法數模 $10^9 + 7$ 的餘數。\n\n一行包含一個正整數 $n$，$n \\leq 10^9$。\n\n輸出一行包含一個數字，代表第 $1$ 天到第 $n$ 天吃便當的方法數模 $10^9 + 7$ 的結果。\n\n",
    "output": "#include<bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define piii pair<int,pair<int,int>>\n#define pb push_back\n#pragma GCC optimize(\"Ofast\")\n#define inf LLONG_MAX\n#define mod1 998244353\n#define mod2 1000000007\n#define st first\n#define nd second\nusing namespace std;\n\nstruct matrix{\n  int arr[2][2];\n};\n\nmatrix identity = {.arr = {{1, 0}, {0, 1}}};\nmatrix A = {.arr = {{0, 3}, {1, 2}}};\n\nmatrix mul(matrix a, matrix b){\n  matrix ans;\n  ans.arr[0][0] = (a.arr[0][0] * b.arr[0][0] + a.arr[0][1] * b.arr[1][0]) % mod2;\n  ans.arr[0][1] = (a.arr[0][0] * b.arr[0][1] + a.arr[0][1] * b.arr[1][1]) % mod2;\n  ans.arr[1][0] = (a.arr[1][0] * b.arr[0][0] + a.arr[1][1] * b.arr[1][0]) % mod2;\n  ans.arr[1][1] = (a.arr[1][0] * b.arr[0][1] + a.arr[1][1] * b.arr[1][1]) % mod2;\n  return ans;\n}\n\nmatrix solve(int n){\n  matrix ans = identity;\n  if(n == 0) return ans;\n  ans = solve(n >> 1);\n  ans = mul(ans, ans);\n  if(n % 2 == 0) return ans;\n  return mul(ans, A);\n}\n\nsigned main(){\n\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  assert(1 <= n && n <= 1000000000);\n  matrix ret = solve(n);\n  cout << ret.arr[0][0] << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "id": "dp36",
    "instruction": "JOI 君很喜歡字串，有一天，他收到了別人送的禮物，兩個字串 $A, B$！\n於是 JOI 君很好奇，這兩個字串的最長共同子序列長度是多少？\n\n一個字串 $T$ 是一個字串 $S$ 的子序列，若且唯若我們刪除零或多個在 $S$ 字串中的字元後，可以得到字串 $T$。\n舉例來說 `abc` 是 `accbddc` 的子序列，因為刪除 `ccdd` 後，`accbddc` 就會變成 `abc`。\n\n假如 $T$ 同時是 $A, B$ 字串的子序列，我們就說 $T$ 是 $A, B$ 字串的共同子序列。\n\n輸入只有一行，有兩個字串 $A, B$ 以一個空白隔開。\n\n其中 $1 \\le |A|, |B| \\le 5000$。\n且 $A, B$ 字串都會由英文小寫字母組成。\n\n注意到 $|S|$ 代表的是字串 $S$ 的長度。\n\n輸出一行一個整數代表答案。\n\n",
    "output": "#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 5010;\n\nint dp[MAX_N][MAX_N];\nstring a, b;\n\nint main() {\n\tcin >> a >> b;\n\ta = \"_\" + a;\n\tb = \"_\" + b;\n\n\tfor (int i = 1;i < a.size();++i)\n\t\tfor (int j = 1;j < b.size();++j)\n\t\t\tif (a[i] == b[j])\n\t\t\t\tdp[i][j] = dp[i-1][j-1] + 1;\n\t\t\telse\n\t\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n\n\tcout << dp[(int)a.size() - 1][(int)b.size() - 1] << '\\n';\n}\n"
  },
  {
    "id": "dp37",
    "instruction": "購物中心最近大特價，你決定把每家店的商品都買一遍。購物中心是一個長型的建築，每隔一公尺就會有一個店家，由左至右編號為 $1,\\ 2,\\ \\dots,\\ n$。入口在這個購物中心的最左邊與第一個店家相距 $1$ 公尺；而且你事先得知編號為 $i$ 的店家每 $T_i$ 秒會補一次貨，你需要在店家補貨時到達店家門口才來的及搶購商品。現在你好奇，最快可以在多少時間內把每家店的商品都買一遍。\n\n假定你的體力很好，隨時以每秒 $1$ 公尺的速度移動，並且不受移動方向改變的影響，買東西所花的時間也可以忽略不計。\n第一行有一個數字 $n$，代表商店的數量 ($1\\le n\\le16$)。\n第二行有 $n$ 個數字。所有數字皆不大於 $10^8$。\n\n請輸出結束所需的最少秒數。\n",
    "output": "#include<bits/stdc++.h>\nusing namespace std;\n#define IOS {cin.tie(0);ios_base::sync_with_stdio(false);}\n#define N 16\n#define INF (1ll<<62)\n\nlong long in[N];\nlong long dp[N][1<<N];\n\nint main()\n{\n\tIOS;\n\tint n;\n\tcin >> n;\n\tfor(int i=0;i<n;i++) cin >> in[i];\n\tfor(int i=0;i<(1<<n);i++) {\n\t\tfor(int j=0;j<n;j++) if(i>>j&1){\n\t\t\tif(i==1<<j){\n\t\t\t\tdp[j][i] = (j+in[j])/in[j]*in[j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[j][i] = INF;\n\t\t\tfor(int k=0;k<n;k++) if(k!=j && i>>k&1){\n\t\t\t\tlong long a = in[j] - dp[k][i^(1<<j)]%in[j];\n\t\t\t\tdp[j][i] = min(dp[j][i],dp[k][i^(1<<j)] + a + (abs(j-k)-a+in[j]-1)/in[j]*in[j]);\n\t\t\t}\n\t\t}\n\t}\n\tlong long mn = INF;\n\tfor(int i=0;i<n;i++) mn = min(mn,dp[i][(1<<n)-1]);\n\tcout << mn << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "dp39",
    "instruction": "作為最強的勇者兼鍛造師，阿姆斯特最近決定強化他的阿姆斯特朗炮。\n現在有 $n$ 個強化槽和 $n$ 個強化石，\n對於每個強化槽，阿姆斯特都能計算出使用每種強化石的成功率，也就是形如 $p\\%$ 的百分比值（$=p/100$）\n每個強化石都只能給一個強化槽用，最終強化的成功率是所有強化槽成功率乘在一起。\n阿姆斯特希望最終強化的成功率越高越好，他請他最好的夥伴，也就是你，幫忙計算最終強化的成功率的理論最大值。\n\n第一行有一個正整數 $n$，代表強化槽的個數\n接下來有 $n$ 行，每行有 $n$ 個非負整數，第 $i$ 行的第 $j$ 個數 $p_{ij}$，代表的是第 $i$ 個強化槽選第 $j$ 種強化石的成功率。\n\n* $1\\le n\\le20$\n* $0\\le p_{ij} \\le 100$\n\n請輸出可能達到的最終強化的成功率的百分比值（四捨五入至小數第二位）\n\n",
    "output": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 20;\ndouble dp[1<<N];\nint w[N+2][N+2];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++){\n        cin >> w[i][j];\n    }\n    dp[0] = 1;\n    for(int s=1;s<(1<<n);s++) {\n        for(int j=0; s>>j; j++) if(s>>j&1){\n            dp[s] = max(dp[s], dp[s^(1<<j)] * w[__builtin_popcount(s)][j+1]/100.0);\n        }\n    }\n    cout << fixed << setprecision(2) << dp[(1<<n)-1]*100 << '\\n';\n}"
  },
  {
    "id": "dp40",
    "instruction": "上了大學之後，JOI 君修了一門叫做線性代數的課，裡面常常用到矩陣乘法。\n\n假設有矩陣 $A, B$ 其中 $A$ 是個 $n \\times m$ 大小的矩陣，且 $B$ 是個 $m \\times k$ 大小的矩陣。\n那 $AB = C$ ，$C$ 是個 $n \\times k$ 大小的矩陣，並且我們需要做 $nmk$ 那麼多次的運算才能夠算出 $C$。\n\n不只如此，矩陣乘法是有結合律的，也就是說 $A(BC) = (AB)C$。\n\nJOI 君拿到了一份作業，題目如下。\n給定 $N$ 個矩陣 $A_1, A_2,\\ldots,A_N$ 請問 $A_1A_2\\ldots A_N$ 為多少？\n看到之後 JOI 君瑟瑟發抖，因為計算量實在太龐大了。\nJOI 君發現，因為結合律的關係，只要改變計算順序就有可能省下一些計算量。\n聰明的你，可不可以告訴 JOI 君，在最佳狀況下，需要幾次運算才能得到答案呢？\n\n輸入第一行為一個正整數 $N(N \\le 1000)$ 代表總共有幾個矩陣。\n接下來一行有 $N+1$ 個正整數以一個空白隔開 $B_1, B_2,\\ldots,B_N, B_{N+1}(B_i \\le 1000)$。\n\n代表說，第 $i$ 個矩陣是 $B_i \\times B_{i+1}$ 的矩陣。\n\n請輸出一行整數代表答案。\n\n",
    "output": "#include <iostream>\nusing namespace std;\nusing ll = long long;\n\nconst int MAX_N = 1010;\nconst ll inf = 1ll << 58;\n\nint N, B[MAX_N];\nll dp[MAX_N][MAX_N];\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1;i <= N+1;++i)\n\t\tcin >> B[i];\n\n\tfor (int j = 1;j <= N;++j) \n\t\tfor (int i = j - 1;i >= 1;--i) {\n\t\t\tdp[i][j] = inf;\n\t\t\tfor (int k = i;k < j;++k) \n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1ll * B[i] * B[k+1] * B[j+1]);\n\t\t}\n\n\tcout << dp[1][N] << '\\n';\n}\n"
  },
  {
    "id": "dp41",
    "instruction": "卓利教練是$N$個孩子（編號為$1\\sim N$）的足球教練。每天訓練結束後，卓利教練都會將$N$包零食灑在足球場上，當作給努力練球之後的孩子們當作獎勵。\n\n然而，練完球的孩子們早已筋疲力竭。這使得他們在輪到自己拿零食時，只願意去拿距離（歐幾里得距離，就是你最常見的那種）自己最近的零食。但這樣小孩子有可能會打架---假設某一包零食對所有的孩子來說都是最近的，那麼這$N$個小孩就會集體衝過去並打成一片。卓利教練作為資深的足球教練，早就預判了這個潛在的問題並也有一套解決這個問題的方法：他會一個一個地叫孩子去拿自己的零食；如此一來，孩子們就不會打成一片了。而學生們對教練也很有禮貌，如果輪到某個孩子拿零食時，發現多包零食與自己的距離相同，那麼他會詢問教練在這些距離自己最近的零食中，要拿哪一包比較好。\n\n![](https://i.imgur.com/pIZmsI2.png)\n\n教球三十年以來，教練都是這麼做的。但今天發生了一點意外！今天教練灑零食的時候，他不小心把自己要吃的藍莓果凍一起灑出去了！藍莓果凍是教練最心愛的點心，這是他心心念念晚上回家時要吃的甜點。於是此時，足球場上便有$N$個小孩和$N + 1$份零食（編號$1 \\sim N + 1$）。教練很緊張，他思索著是否有一種叫小孩去拿零食的順序，能在$N$名小孩都各自拿完一包零食後，自己的藍莓果凍還留在場上因而保住自己最心愛的果凍？\n\n每份測試檔案的第一行都會包含恰一個整數$T$，代表這份檔案內含$T$筆測試資料。\n每份測試資料的第一行會有一個正整數$N$，代表小孩子們的數量。\n接下來的$N$行是小孩子們的位置，其中的第$i$行包含兩個整數$X_i, Y_i$，代表$N$個小孩在足球場上的座標位置。\n接下來的$N + 1$行是零食（1號零食是卓利教練最愛的藍莓果凍）們的位置，其中的第$j$行包含兩個整數$X_j, Y_j$，代表第$j$號零食在足球場上的座標位置。\n\n* $1 \\leq T \\leq 100$\n* $-10^9 \\leq X_i, Y_i, X_j, Y_j \\leq 10^9$\n* $1 \\le N \\le 10$\n\n對於每筆測試資料，第一行請輸出型如`Case #x: y`的字串，其中$x$是這是第幾筆測資的編號（第一筆測資的$x = 1$），而\n* 如果卓利教練的果凍沒救了（找不到任何一種叫小孩子拿零食的順序可以保住他的果凍），則$y = \\texttt{IMPOSSIBLE}$。\n* 反之，$y = \\texttt{POSSIBLE}$。\n\n如果卓利教練有辦法保住他的果凍，請告訴他該用什麼順序叫孩子去拿零食以及每個人應該拿哪一包零食。更具體地說，請額外輸出$N$行，其中第$i$行包含兩個以空白分隔的整數$A_i, B_i$，代表教練應該在第$i$次呼叫孩子的時候應該呼叫編號為$A_i$的孩子，並指示他去拿$B_i$號零食。特別需要注意的是，$B_i$號零食必須要是足球場上仍未被取走的零食中，其中一個距離$A_i$號孩子最近的零食。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/priority_queue.hpp>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>\n#define ordered_multiset tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update>\n/* ordered_set notes:\n    .order_of_key(k): Number of items strictly smaller than k\n    .find_by_order(k): k-th element in a set\n*/\n#define X first\n#define Y second\ntemplate <typename A, typename B> istream& operator >> (istream& o, pair<A, B> &a) {\n    return o >> a.X >> a.Y;\n}\ntemplate <typename A, typename B> ostream& operator << (ostream& o, pair<A, B> a) {\n    return o << '(' << a.X << \", \" << a.Y << ')';\n}\n#ifdef cychien\n#define debug(...) do {\\\n\tfprintf(stderr, \"%s - %d : (%s) = \", __PRETTY_FUNCTION__, __LINE__, #__VA_ARGS__);\\\n    _DO(__VA_ARGS__);\\\n}while(0) \ntemplate<typename I> void _DO(I&&x) {cerr << x << '\\n';}\ntemplate<typename I, typename ...T> void _DO(I&&x,T&&...tail) {cerr << x << \", \"; _DO(tail...);}\n#define IOS\n#define DE(v) {cerr << #v << \" = [\"; for(auto it = (v).begin(); it != (v).end(); it++){cerr << *it; if (next(it) != (v).end()) cerr << \", \"; } cerr << \"]\\n\";}\n#else\n#define debug(...)\n#define DE(v)  \n#define IOS ios_base::sync_with_stdio(0);cin.tie(0)\n#endif\n#define W(v) {for(auto it = (v).begin(); it != (v).end(); it++)cout << *it << \" \\n\"[next(it) == (v).end()];}\n#define FOR(i, n) for(int i = 0; i < n; i++)\n#define FOR1(i, n) for(int i = 1; i <= n; i++)\n#define pb emplace_back\n#define mp make_pair\n#define rsz resize\n#define SZ(x) (ll)x.size()\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort(ALL(x))\ntemplate<class T> bool chmin(T &a, T b) { return b < a && (a = b, true); }\ntemplate<class T> bool chmax(T &a, T b) { return a < b && (a = b, true); }\ntypedef long long int ll;\n// typedef __int128 lll; // C++20 only\ntypedef unsigned long long int ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\nconst int NF = 0x3f3f3f3f;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst ll MOD = 1e9 + 7;\nconst ld PI = 3.14159265358979323846264338327950288;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint Rand(){\n    return uniform_int_distribution<int>(INT_MIN, INT_MAX)(rng);\n}\n/*\n#include <atcoder/all>\nusing namespace atcoder;\n*/\n#define MAXn 10\nint n;\npll blue;\npll candy[MAXn + 5], stu[MAXn + 5];\nll best[MAXn + 5][(1 << MAXn) + 5];\nll sq(ll x){\n    return x * x;\n}\nll dist(pll a, pll b){\n    return sq(a.X - b.X) + sq(a.Y - b.Y);\n}\nvoid build(){\n    for (int i = 0; i < n; i++){\n        for (int msk = 0; msk < (1 << n); msk++){\n            best[i][msk] = dist(blue, stu[i]);\n            for (int j = 0; j < n; j++){\n                if (msk & (1 << j)){\n                    chmin(best[i][msk], dist(stu[i], candy[j]));\n                }\n            }\n        }\n    }\n}\nbool ok[(1 << MAXn) + 5][(1 << MAXn) + 5];\npair<int, int> sol[(1 << MAXn) + 5][(1 << MAXn) + 5];\nbool que(int x, int y){\n    if (sol[x][y].X != -2) return ok[x][y];\n    if (x == 0 && y == 0) {\n        sol[x][y] = mp(-1, -1);\n        ok[x][y] = true;\n        return true;\n    }\n    for (int i = 0; i < n; i++){\n        if ((x >> i) & 1){\n            for (int j = 0; j < n; j++){\n                if ((y >> j) & 1){\n                    if (dist(stu[i], candy[j]) == best[i][y]){\n                        if (que(x ^ (1 << i), y ^ (1 << j))){\n                            sol[x][y] = mp(i, j);\n                            ok[x][y] = true;\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\nvoid solve(){\n    cin >> n;\n    for (int i = 0; i < n; i++){\n        cin >> stu[i].X >> stu[i].Y;\n    }\n    cin >> blue.X >> blue.Y;\n    for (int i = 0; i < n; i++){\n        cin >> candy[i].X >> candy[i].Y;\n    }\n    build();\n    for (int i = 0; i < (1 << MAXn); i++)\n        for (int j = 0; j < (1 << MAXn); j++)\n            sol[i][j] = mp(-2, -2);\n    if (que((1 << n) - 1, (1 << n) - 1)){\n        cout << \"POSSIBLE\\n\";\n        vector<pii> tmp;\n        for (int i = (1 << n) - 1, j = (1 << n) - 1; i && j; ){\n            auto x = sol[i][j];\n            tmp.pb(x);\n            i ^= (1 << x.X), j ^= (1 << x.Y);\n        }\n        for (auto& [x, y] : tmp){\n            cout << x + 1 << ' ' << y + 2 << '\\n';\n        }\n    }\n    else {\n        cout << \"IMPOSSIBLE\\n\";\n    }\n}\nint main() {\n    IOS;\n    int T; cin >> T;\n    for (int kase = 1; kase <= T; kase++){\n        cout << \"Case #\" << kase << \": \";\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "id": "dp42",
    "instruction": "某天 bb 拿到了一個長度 $N$ 的序列 $v_1, v_2, \\cdots, v_N$，這個序列裡面的數字 有正有負也有可能有零，而 bb 想用紅、綠、藍三種顏色幫這個序列上色。為了美觀，每個數字都必須被標上顏色，而且序列中任兩個相鄰的數字必須要被標上不同的顏色。由於 bb 喜歡綠色且討厭紅色，他覺得這個序列上色之後的價值是標上綠色的數字的總和扣掉標上紅色的數字的總和。請問在滿足上述的條件下，這個序列上色後價值可以變成多高呢？\n輸入的第一行有一個正整數 $N$，代表序列的長度。\n第二行有 $N$ 個整數 $a_1, a_2, \\cdots a_N$，代表序列的數值。\n\n* $1 \\leq N \\leq 10^6$\n* $−10000 \\leq a_i \\leq 10000$\n輸出只有一行，代表上色之後這個序列的最高可能價值。\n",
    "output": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int MAXN = 1000000;\nint N;\nint a[MAXN+1];\nint dp[MAXN+1][3];\nint ans;\n\nsigned main() {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  cin >> N;\n  for (int i = 1; i <= N; i++) {\n    cin >> a[i];\n    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + a[i];\n    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) - a[i];\n    dp[i][2] = max(dp[i-1][0], dp[i-1][1]);\n  }\n  ans = max({dp[N][0], dp[N][1], dp[N][2]});\n  cout << ans << '\\n';\n}\n"
  },
  {
    "id": "dp43",
    "instruction": "JOI 君最喜歡圖了，他生日的時候收到了一張一般有向圖，覺得實在很一般，所以就想要在上面數有趣的東西。\n他很想知道這張圖上有多少條簡單路徑。\n一條簡單路徑就是從一個點經過一些邊走到另外一個點（可以完全不經過邊），過程經過的所有點（包含起終點）全部都不重複。\n請你幫幫 JOI 君。\n\n注意到因為方案數可能太大了，所以 JOI 君只在意方案數取 $10^9 + 7$ 的餘數。\n也就是說，如果方案數為 $T$，請輸出 $T \\pmod{10^9 + 7}$。\n\n輸入第一行有一個正整數 $N(N \\le 20)$ 代表這張圖有幾個節點。\n接下來 $N$ 行，每行都有 $N$ 個整數由一個空白隔開，第 $i$ 行第 $j$ 個數字代表 $A_{i,j}$。其中 $A_{i,j} \\in {0, 1}$。\n如果第 $i$ 個節點往第 $j$ 個節點有一題邊，則 $A_{i,j} = 1$。\n否則 $A_{i,j} = 0$。\n\n輸出一行一個整數代表答案。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MAX_N = 20, MOD = 1e9 + 7;\n\nint N;\nll dp[1<<MAX_N][MAX_N];\nint adj[MAX_N][MAX_N];\n\nint32_t main() {\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> N;\n\tfor (int i = 0;i < N;++i)\n\t\tfor (int j = 0;j < N;++j)\n\t\t\tcin >> adj[i][j];\n\n\tfor (int i = 0;i < N;++i)\n\t\tdp[1<<i][i] = 1;\n\n\tll res = 0;\n\tfor (int s = 1;s < 1<<N;++s) {\n\t\tfor (int j = 0;j < N;++j) {\n\t\t\tif ((s>>j&1) && dp[s][j]) {\n\t\t\t\tfor (int k = 0;k < N;++k)\n\t\t\t\t\tif (adj[j][k] && (~s>>k&1)) {\n\t\t\t\t\t\tdp[s | (1<<k)][k] += dp[s][j];\n\t\t\t\t\t\tdp[s | (1<<k)][k] %= MOD;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tres += dp[s][j];\n\t\t\tres %= MOD;\n\t\t}\n\t}\n\tcout << res << '\\n';\n\n}\n"
  },
  {
    "id": "ds01",
    "instruction": "這題只要你簡單練習並且熟悉 queue 的各種操作。\n請你實做一個 queue，並實現以下指令：\n\n* `1 n` 將數字 $n$ 放進 queue 中\n* `2` 拿出 queue 前端的數字(不需印出此數字)，如果 queue 是空的，則輸出 `QQ`\n* `3` 印出 queue 前端的數字(不需拿出此數字)，如果 queue 是空的，則輸出 `QQ`\n* `4` 印出當前 queue 中存放了多少數字\n\n輸入第一行有一整數 $m$，代表接下來會有幾個指令。\n接下來 $m$ 行，每行都為敘述中所提到的指令。格式如題敘所述。\n\n* $m \\leq 200000$\n* 保證指令 `1` 輸入的數字範圍為 `int`\n* 保證沒有非法指令\n\n對每個操作 `2`, `3` 與 `4` 印出對應的結果，每個指令的結果之間需換行。\n\n",
    "output": "#include <iostream>\n#define MAXN 2000050\n#define ne(x) ((x + 1) % MAXN)\nusing namespace std;\n\nint q[MAXN];\nint q_head, q_tail;\n// head >= tail\n\nbool empty() {\n\treturn q_head == q_tail;\n}\n\nvoid push(int n) {\n\tq[q_head] = n;\n\tq_head = ne(q_head);\n}\n\nvoid pop() {\n\tq_tail = ne(q_tail);\n}\n\nint size() {\n\treturn (q_head - q_tail + MAXN) % MAXN;\n}\n\nint front() {\n\treturn q[q_tail];\n}\n\nint main() {\n\tint op;\n\tint n;\n\tcin >> n;\n\tint a;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> op;\n\t\tswitch (op)\n\t\t{\n\t\tcase 1:\n\t\t\tcin >> a;\n\t\t\tpush(a);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (!empty()) {\n\t\t\t\tpop();\n\t\t\t} else {\n\t\t\t\tcout << \"QQ\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (!empty()) {\n\t\t\t\tcout << front() << '\\n';\n\t\t\t} else {\n\t\t\t\tcout << \"QQ\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcout << size() << endl;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "id": "ds02",
    "instruction": "「大鍋飯」中式餐館是北京城時下最時髦的用餐地點！每到中午用餐時間，「大鍋飯」飯館總是大排長龍，熙熙攘攘。現在，他們想要寫一支程式來處理 $T$ 天的排隊資料。已知第 $i$ 天有 $N_i$ 個旅行團來到，其中的第 $j$ 個旅行團有 $c_j$ 個人，也知道他們的編號是 $x_{j,1}, x_{j,2}, \\dots, x_{j,c_{j}}$。而又會有 $Q_i$ 個「事件」發生，可能是下列兩個的其中之一：\n\n- 編號為 $x$ 的人進入了餐館\n- 餐館放一個人進來餐館內，目前在隊伍最前面的人離隊，並且輸出這個人是誰\n\n但是，因為「大鍋飯」中式餐館實在太好吃了，午休時間又很短，導致人們在這裡特別喜歡插隊：如果一個人進來看到隊伍裡面已經有和他同一個旅行團的人在排隊的話，他會毫不猶豫地排到他們的後面。而且，每一天結束之後，不管隊伍還有沒有人，所有人都會離開商店。請注意，不同隊伍的人不會出現相同編號，但因為北京城流行分享編號，所以可能隊伍裡面同時會有兩個人的編號是相同的，這是被允許的，請將他們兩個人處理為兩個不同而編號相同的人。\n\n請寫一支支援以上兩個操作的程式吧！\n\n第一行有一個數字 $T(1 \\leq T \\leq 10^5)$，代表有幾天。接下來會有 $T$ 筆測試資料，每一筆的第一行都會有兩個數字 $N$ 和 $Q(1 \\leq N, Q \\leq 10^5)$。接下來的 $N$ 行每一行都會有若干個數字，其中第一個是 $c_j(1 \\leq c_j \\leq 10^5)$，接下來有 $c_j$ 個數字 $x_{j,1}, x_{j,2}, \\dots, x_{j,c_j}(1 \\leq x_{i,j} \\le 10^6)$。接下來是 $Q$ 行，可能是下列的其中兩個中的之一：\n\n- `1 x` 代表編號為 $x$ 的人加入了隊伍。\n- `2` 代表隊伍最前面的人離隊，請輸出那個人的編號。如果沒有人，請輸出 $-1$。\n\n此外，還保證 $\\sum N, \\sum Q, \\sum c_j \\leq 10^5$，且所有入隊伍的人都是之前出現過的團員，且一個編號最多只會屬於一個旅行團。\n\n對於每一個詢問，請於一行輸出對應的答案。\n\n",
    "output": "#include <iostream>\n#include <queue>\n#include <string.h>\nusing namespace std;\n\nint belong[1000326], inq[100326];\nqueue<int> team[100326];\n\ninline void solve(){\n\tint N, Q, c, x;\n\tqueue<int> que = queue<int>();\n\tcin >> N >> Q;\n\tfor(int i = 0; i < N; i++){\n\t\tteam[i] = queue<int>();\n\t\tinq[i] = false;\n\t\tcin >> c;\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcin >> x;\n\t\t\tbelong[x] = i;\n\t\t}\n\t}\n\twhile(Q--){\n\t\tcin >> c;\n\t\tif(c == 1){\n\t\t\tcin >> x;\n\t\t\tteam[belong[x]].push(x);\n\t\t\tif(!inq[belong[x]]){\n\t\t\t\tque.push(belong[x]);\n\t\t\t\tinq[belong[x]] = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif(que.empty()){\n\t\t\t\tcout << -1 << endl;\n\t\t\t} else {\n\t\t\t\tcout << team[que.front()].front() << endl;\n\t\t\t\tteam[que.front()].pop();\n\t\t\t\tif(team[que.front()].empty()){\n\t\t\t\t\tinq[que.front()] = false;\n\t\t\t\t\tque.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);cin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--){\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "id": "ds03",
    "instruction": "時間回到了元朝的大草原，此時一年一度的鐵木真資訊奧林匹亞（Temujin Olympiad in Informatics, TOI），正在如火如荼地進行。活動除了騎馬打扣，一箭 `AC` 等活動外，選手們還喜歡在閒暇時間打牌。他們打的牌是今日橋牌的前身，牌的數量也不固定，總共有 $N$ 張，編號分別為 $1$ 到 $N$ 各一張。一開始，牌是依照順序從上到下的，但是草原的戰士們不喜歡這樣的一成不變，他們會一直進行這個動作：\n\n- 將最上面的一張牌捨棄掉\n- 將現在牌組最上面的一張牌移動至牌組最下方\n\n假設第 $i$ 次操作的時候捨棄掉的牌的編號為 $a_i$，那草原戰士們想要你回答 $Q$ 個問題，每次會問一個 $m$，問你 $a_m$ 的值為多少？\n\n如果你都回答得出這些問題，他們將給你蒙古最高榮耀：雙鬼！還不趕快動身嗎！ \n輸入將有 $2$ 行。第一行將有兩個正整數 $N, Q (1 \\leq N \\leq 10^6, 1 \\leq Q \\leq 10^5)$，代表有幾張牌和有幾個問題要回答。第二行有 $Q$ 個數字，第 $i$ 個是 $m_i(1 \\leq m_i \\leq N)$，代表一次詢問。\n\n請輸出 $Q$ 行，每一行代表 $a_{m_{i}}$。\n",
    "output": "#include <iostream>\n#include <queue>\n#define ericxiao ios_base::sync_with_stdio(0);cin.tie(0);\nusing namespace std;\n\nconst int maxN = 1e6 + 326;\nint N, Q, q, ord[maxN], x;\nqueue<int> que;\n\nint main() {\n\tericxiao;\n\tcin >> N >> Q;\n\tfor(int i = 1; i <= N; i++) que.push(i);\n\tfor(int i = 1; i <= N; i++){\n\t\tord[i] = que.front(); que.pop();\n\t\tx = que.front(); que.pop();\n\t\tque.push(x);\n\t}\n\twhile(Q--){\n\t\tcin >> q;\n\t\tcout << ord[q] << \"\\n\";\n\t}\n}\n"
  },
  {
    "id": "ds04",
    "instruction": "菜瓜國國內正受到維尼病毒的肆虐，這個病毒非常之可怕，感染這種病毒的人會有很大的機會被外星人盯上並被迫簽約成為魔法少女，其中又以正直青春年華的美少女感染率最大。\n疫情爆發後過了半年的時間，國家實驗室總算開始量產疫苗了。但因為疫苗數量還是不足以盡快讓全國人民施打完畢，國家給九種族群設定了不同的優先度。政府官員以及疫情指揮中心團隊有最高的優先度 $9$，美少女有第二高的優先度 $8$，以此類推，而最低的優先度 $1$ 則是分配給夢想成為魔法少女的幻想肥宅。\n其實我們都知道，每個政府的施政效率都是極差無比的，菜瓜國也不例外。菜瓜國總統頒布了很荒謬的排隊方式，敘述如下：\n\n* 如果輪到你的時候，你是隊伍中優先度最高的，則你可以直接施打疫苗\n* 如果輪到你的時候，還有其他人在隊伍中比你的優先度還要高，則你會被踢到隊尾重新排隊\n\n現在亞爾薩德想要計算出從他排隊到打完疫苗需要花多少時間，你可以幫他算嗎？這裡假設每個人打疫苗都需要花一分鐘的時間，重排隊以及檢查優先度等等不花時間。\n\n輸入第一行有一個正整數 $T$，代表有幾筆測試資料。\n每筆測試資料的第一行有兩個正整數 $n, m$，代表總共有幾個人在排隊打疫苗以及你是第幾個，其中 $0 \\leq m \\leq n - 1$，注意這裡是從 $0$ 開始數。第二行有 $n$ 個正整數 $p_i$ 代表第 $i$ 個人的優先度，其中 $1 \\leq p_i \\leq 9$。\n\n* $1 \\leq T \\leq 100$\n* $1 \\leq n \\leq 10000$\n\n數字與數字之間用空白分隔。\n\n對每筆測試資料，輸出需要等待的分鐘數。\n",
    "output": "#include <iostream>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\n\nint main() {\n\tint t, n, m;\n\tint cnt[10];\n\tcin >> t;\n\twhile (t--) {\n        queue<pair<int, int> >q;\n\t\tcin >> n >> m;\n\t\tint p;\n\t\tmemset(cnt, 0, sizeof(cnt));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> p;\n\t\t\tq.push(make_pair(p, i));\n\t\t\tcnt[p]++;\n\t\t}\n\n        // for (int i = 0; i < n; i++) {\n        //     cout << cnt[i] << \" \\n\"[i == n - 1];\n        // }\n\n\t\tint ans = 0;\n\t\tbool found = false;\n\t\tfor (int i = 9; i > 0 && !found; i--) {\n\t\t\twhile (cnt[i] > 0 && !found) {\n\t\t\t\tpair<int, int> f = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tif (f.first == i) {\n\t\t\t\t\tans++;\n\t\t\t\t\tif (f.second == m) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t\tcnt[i]--;\n\t\t\t\t} else {\n\t\t\t\t\tq.push(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "id": "ds05",
    "instruction": "這題只要你簡單練習並且熟悉 stack 的各種操作。\n請你實做一個 stack ，並實現以下指令：\n\n* `1 n` 將數字 $n$ 放進 stack 中\n* `2` 拿出 stack 最上層的數字(不需印出此數字)，如果 stack 是空的，則輸出 `QQ`\n* `3` 印出 stack 最上層的數字(不需拿出此數字)，如果 stack 是空的，則輸出 `QQ`\n* `4` 印出當前 stack 中存放了多少數字\n\n輸入第一行有一整數 $m$ ，代表接下來會有幾個指令。\n接下來 $m$ 行，每行都為敘述中所提到的指令。格式如題敘所述。\n\n* $m \\leq 200000$\n* 保證指令 `1` 輸入的數字範圍為 `int`\n* 保證沒有非法指令\n\n對每個操作 `2`, `3` 與 `4` 印出對應的結果，每個指令的結果之間需換行。\n\n",
    "output": "#include <iostream>\n#define MAXN 2000050\nusing namespace std;\n\nint stk[MAXN];\nint stk_size;\n\nbool empty() {\n\treturn stk_size == 0;\n}\n\nvoid push(int n) {\n\tstk[stk_size++] = n;\n}\n\nvoid pop() {\n\tstk_size--;\n}\n\nint size() {\n\treturn stk_size;\n}\n\nint top() {\n\treturn stk[stk_size - 1];\n}\n\nint main() {\n\t//This is model solution\n\tint op;\n\tint n;\n\tcin >> n;\n\tint a;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> op;\n\t\tswitch (op)\n\t\t{\n\t\tcase 1:\n\t\t\tcin >> a;\n\t\t\tpush(a);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (!empty()) {\n\t\t\t\tpop();\n\t\t\t} else {\n\t\t\t\tcout << \"QQ\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (!empty()) {\n\t\t\t\tcout << top() << '\\n';\n\t\t\t} else {\n\t\t\t\tcout << \"QQ\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcout << size() << endl;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "id": "ds06",
    "instruction": "有好多由括號組成的字串喔！我很想知道這些字串中有哪些是合法匹配的。\n\n舉例來說，以下是合法的括號匹配方式\n\n* `(())`\n* `((()()))`\n* `()((()))`\n\n以下是不合法的匹配方式\n\n* `)(`\n* `(()))(`\n* `()(()(`\n\n請寫一個程式去判斷一串由括號組成的字串是否合法。\n\n輸入第一行為一個數字 $n$，代表接下來有幾組括號。\n接下來 $n$ 行，每行有一串僅由左小括號和右小括號組成的字串。\n\n* $0 < n \\leq 10$\n* 每串括號字串長度小於 $20000$\n\n對每行輸入，若是合法括號匹配則輸出 `Y`，不合法則輸出 `N`。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nbool checker(string s) {\n\tint cnt = 0;\n\tint len = s.length();\n    for (int i = 0; i < len; i++) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t} else {\n\t\t\tcnt--;\n\t\t}\n\n\t\tif (cnt < 0)\n\t\t\treturn false;\n\t}\n\tif (cnt > 0)\n\t\treturn false;\n\treturn true;\n}\n\nint main() {\n\tstring s;\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> s;\n\t\tcout << \"NY\"[checker(s)] << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "id": "ds07",
    "instruction": "其實我們都知道\n\n`2 + 2 = 4`\n`4 - 1 = 3`\n\n但是加上括號之後就有很多人不會算了，因此需要請你幫忙寫程式來計算。\n請寫程式計算給定數學運算式的結果，這些數學運算式會包含加減法以及括號。\n\n\n\n輸入只有一行，包含一個合法的數學運算式\n\n* 運算元包含一些 $0\\sim127$ 的整數\n* 運算子包含 `+`,`-`,`(`,`)`\n\n運算元與運算子、運算子與運算子之間以空白分隔。\n計算時請注意運算子的計算優先順序。\n除了括號以外的所有運算子都是二元運算子，即你不用考慮 `- 1 - 1` 或者 `1 + ( - 2 )` 等情況。\n也不用考慮以括號代替乘法的情況（只有加減法）。\n\n保證數字不超過 20 個，且運算式總長度（字元數）不會超過 200。\n\n輸出計算結果，保證使用 `int` 計算不會有溢位問題。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main ()\n{\n    stack<string> exp;\n    \n    string now;\n    while (cin >> now)\n    {\n        if (now == \"+\" || now == \"-\" || now == \"(\")\n        {\n            exp.push(now);\n        }\n        else\n        {\n            if (now == \")\")\n            {\n                now = exp.top();\n                exp.pop(), exp.pop();\n            }\n            \n            if (exp.empty())\n            {\n                exp.push(now);\n            }\n            else if (exp.top() == \"+\")\n            {\n                exp.pop();\n                int a = stoi(exp.top());\n                exp.pop();\n                int b = stoi(now);\n                exp.push(to_string(a + b));\n            }\n            else if (exp.top() == \"-\")\n            {\n                exp.pop();\n                int a = stoi(exp.top());\n                exp.pop();\n                int b = stoi(now);\n                exp.push(to_string(a - b));\n            }\n            else\n            {\n                exp.push(now);\n            }\n        }\n    }\n\n    cout << exp.top() << '\\n';\n}\n"
  },
  {
    "id": "ds08",
    "instruction": "有一塊高低不平的木板，他是由 $N$ 塊 $1\\times a_i$ 由左到右的木條粘接而成的，且底部平整對齊。也就是說，這塊木板佔有的空間是平面區域 $[i,i+1]\\times [0,a_i]$$(1\\le i \\le N)$ 的聯集。\n\n現在想在這塊木板上切出一塊矩形區域，問最大能切出的矩形區域面積為何。\n\n輸入第一行是一個整數 $N$，代表木條數量。\n第二行是 $N$ 個空白分隔的整數 $a_1, a_2, \\dots, a_N$，代表木條長度。\n\n輸入保證 $1\\le N\\le 3\\times 10^5$，$1\\le a_i\\le 10^9$。\n\n輸出一行一個整數，代表最大能切出的矩形面積。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n#define pii pair<long long, long long>\nconst int maxn = 3e5 + 5;\nlong long a[maxn];\nint main() {\n    int N;\n    cin >> N;\n    for(int i = 1; i <= N; i++)\n        cin >> a[i];\n    a[0] = a[N+1] = 0;\n    stack<pii> s;\n    s.push({-1,0});\n    long long ans = 0;\n    for(int i = 1; i <= N+1; i++) {\n        while(a[i] <= s.top().first) {\n            long long val = s.top().first;\n            s.pop();\n            ans = max(ans, (i-s.top().second-1) * val);\n        }\n        s.push({a[i], i});\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "id": "ds09",
    "instruction": "校草級學霸電神小風小時候就發現了一個有趣的現象：若一個群的每個元素的階都是 $2$ ，則這個群一定是一個阿貝爾群。\n\n看不懂以上的敘述沒關係，校草小風要你幫忙做一件簡單的事情來協助他驗證他的想法。\n\n給定一個字串，若有任何相鄰的字元相同，就會被消掉。舉例來說，假設一開始的字串是 `cabbab`：\n\n```\ncabbab -> caab -> cb\n```\n\n第一步中中間有兩個 `b` 相鄰，消掉後又有兩個 `a` 相鄰，最後剩下 `cb`。\n\n請你幫校草小風求出字串經過以上運算後最終的樣子。\n\n輸入只有一行，為校草小風給你的字串 $S$，長度不會超過 $200000$。\n$S$ 只由小寫英文字母組成。\n\n輸出字串運算後的結果。\n\n",
    "output": "#include <iostream>\n#define MAXN 200050\nusing namespace std;\n\nchar stk[MAXN];\nint stk_size;\n\nbool empty() {\n\treturn stk_size == 0;\n}\n\nvoid push(char n) {\n\tstk[stk_size++] = n;\n}\n\nvoid pop() {\n\tstk_size--;\n}\n\nint size() {\n\treturn stk_size;\n}\n\nchar top() {\n\treturn stk[stk_size - 1];\n}\n\nint main() {\n\t//This is model solution\n\tstring s;\n\tcin >> s;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tchar c = s[i];\n\t\tif (c == top()) {\n\t\t\tpop();\n\t\t}\n\t\telse {\n\t\t\tpush(c);\n\t\t}\n\t}\n\n\tint n = size();\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << stk[i];\n\t}\n\tcout << endl;\n\treturn 0;\n}\n"
  },
  {
    "id": "ds10",
    "instruction": "派大星收集了一堆上好美盤，他希望把這些盤子按照另一個方式排好，但因為他家實在太小了，只有一張餐桌可以放上好美盤，因此他只能用以下的方式整理這些盤子：\n\n原本的盤子從上到下按照了編號 $1, 2, 3, 4, 5, ..., m$ 堆成一疊在餐桌的**起始區**上，你可以做以下兩種操作\n\n* 從餐桌的**起始區**那一疊盤子最上面拿盤子，你可以選擇把這個盤子堆到**暫放區**或**目標區**的最上面。\n* 把**暫放區**最上面的盤子放到**目標區**的最上面。\n\n除此之外的操作（譬如說將盤子放到地上或從目標區的盤子拿去別的地方）都因為空間太小所以沒辦法做。換句話說，你只能做以上的兩種操作。\n\n接下來給你一些 $1$ 到 $m$ 的目標排列，求是否可能在有限多的操作內把目標區的盤子排列跟目標排列一樣（給的盤子的順序是**由下到上**）。此外，必須要回答 $n$ 個這樣的問題才會算 OK。你可以假設每一個問題都是獨立的，也就是說回答每一個目標排列之前，所有的盤子都會再次依照編號回到起始區）。\n\n\n輸入第一行為兩個數字 $m, n$，代表接下來有 $m$ 個上好美盤以及 $n$ 目標排列。\n接下來 $n$ 行，每行是一個 $1$ 到 $m$ 的目標排列。\n\n* $0 < n \\leq 10$\n* $0 < m \\leq 200000$\n\n對每行輸入，若可以達成目標排列則輸出 `Y`，不可則輸出 `N`。\n\n",
    "output": "#include <iostream>\n#include <stack>\n#define MAXN 200050\nusing namespace std;\n\nint stk[MAXN];\nint stk_size;\n\nvoid push(int n) {\n\tstk[stk_size++] = n;\n}\n\nvoid pop() {\n\tstk_size--;\n}\n\nint top() {\n\treturn stk[stk_size - 1];\n}\n\nbool empty() {\n\treturn stk_size == 0;\n}\n\nvoid clear() {\n\tstk_size = 0;\n}\n\nint arr[MAXN];\nint n, m;\n\nbool checker() {\n\tint k = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tpush(i);\n\t\twhile (!empty() && top() == arr[k]) {\n\t\t\tk++;\n\t\t\tpop();\n\t\t}\n\t}\n\treturn empty();\n}\n\nint main() {\n\tcin >> m >> n;\n\twhile (n--) {\n\t\tclear();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> arr[i];\n\t\t}\t\t\n\t\tcout << \"NY\"[checker()] << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "id": "ds11",
    "instruction": "展現你的 quick maffs.\n\n請寫出程式計算四則運算的結果。\n\n輸入只有一行，包含一個合法的數學運算式\n\n* 運算元包含一些 $0\\sim127$ 的整數\n* 運算元和運算子的總數不超過 50\n* 運算子包含 `+`, `-`, `*`, `/`, `(`, `)`\n\n運算元與運算子、運算子與運算子之間以空白分隔。\n計算時請注意運算子的計算優先順序。\n另外為了避免小數點誤差造成的麻煩，運算過程中全部用整數計算即可，無法整除的向零取整。\n除了括號以外的所有運算子都是二元運算子，即你不用考慮 `- 1 - 1` 或者 `1 + ( - 2 )` 等情況。\n\n輸出計算結果，保證使用 `int` 計算不會有溢位問題。\n\n",
    "output": "#include <iostream>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <cctype>\n\nusing namespace std;\n// using postfix algorithm.\nint getWeight(char c)\n{\n\tchar priority[6] = {'+', '-', '*', '/', '(', ')'};\n\tint weight[6] = {1, 1, 2, 2, 0, 0};\n\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tif (c == priority[i])\n\t\t{\n\t\t\treturn weight[i];\n\t\t}\n\t}\n\treturn -1; // not found.\n}\n\nint calc(int a, char op, int b)\n{\n\tint ret;\n\tif (op == '+')\n\t{\n\t\tret = a + b;\n\t}\n\telse if (op == '-')\n\t{\n\t\tret = a - b;\n\t}\n\telse if (op == '*')\n\t{\n\t\tret = a * b;\n\t}\n\telse if (op == '/')\n\t{\n\t\tret = a / b;\n\t}\n\telse {\n\t\texit(-1); // error\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tstack<char> op;\n\tstack<int> result_stack;\n\tqueue<string> postfix_queue;\n\n\tstring input_str;\n\tstring token;\n\n\tgetline(cin, input_str);\n\tistringstream iss(input_str);\n\twhile (iss >> token)\n\t{\n\t\t// parse token\n\t\tif (getWeight(token[0]) == -1) // not operator\n\t\t{\n\t\t\tpostfix_queue.push(token);\n\t\t}\n\t\telse // is operator.\n\t\t{\n\t\t\tchar c = token[0];\n\t\t\tif (c == '(')\n\t\t\t{\n\t\t\t\top.push(c); // push '(' into the stack.\n\t\t\t}\n\t\t\telse if (c == ')')\n\t\t\t{\n\t\t\t\twhile (op.top() != '(')\n\t\t\t\t{\n\t\t\t\t\tstring tmp_str(1, op.top());\n\t\t\t\t\tpostfix_queue.push(tmp_str);\n\t\t\t\t\top.pop();\n\t\t\t\t}\n\t\t\t\top.pop(); // remove the '('\n\t\t\t}\n\t\t\telse if (op.empty() || getWeight(c) > getWeight(op.top()))\n\t\t\t{\n\t\t\t\top.push(c);\n\t\t\t}\n\t\t\telse if (getWeight(c) <= getWeight(op.top()))\n\t\t\t{\n\t\t\t\twhile (!op.empty() && (getWeight(op.top()) >= getWeight(c)))\n\t\t\t\t{\n\t\t\t\t\tstring tmp_str(1, op.top());\n\t\t\t\t\tpostfix_queue.push(tmp_str);\n\t\t\t\t\top.pop();\n\t\t\t\t}\n\t\t\t\top.push(c);\n\t\t\t}\n\t\t}\n\t}\n\twhile (!op.empty())\n\t{\n\t\tstring tmp_str(1, op.top());\n\t\tpostfix_queue.push(tmp_str);\n\t\top.pop();\n\t} // when the program runs here, the queue should be ready to analyze.\n\n\twhile (!postfix_queue.empty())\n\t{\n\t\tif (isdigit(postfix_queue.front()[0])) // not operator -> a number.\n\t\t{\n\t\t\tistringstream iss(postfix_queue.front());\n\t\t\tlong long int value;\n\t\t\tiss >> value;\n\t\t\tresult_stack.push(value); // push the value into the stack.\n\t\t}\n\t\telse // met operator.\n\t\t{\n\t\t\tchar o = postfix_queue.front()[0];\n\t\t\tint a, b;\n\t\t\tb = result_stack.top();\n\t\t\tresult_stack.pop();\n\t\t\ta = result_stack.top();\n\t\t\tresult_stack.pop();\n\t\t\tresult_stack.push(calc(a, o, b)); // push the result back to the stack.\n\t\t}\n\t\tpostfix_queue.pop();\n\t}\n\tcout << result_stack.top() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "id": "ds12",
    "instruction": "deque 是一種能支援從前後插入、刪除、查詢 deque 裡面有幾個元素、查詢最前面與最後面數字的資料結構。\n這題要你學會實作 deque，指令如下。\n- `1 C`：將正整數 $C$ 從後端插入 deque。\n- `2 C`：將正整數 $C$ 從前端插入 deque。\n- `3`：查詢目前 deque 最後面的元素是多少並輸出，如果 deque 為空則輸出 `error`。\n- `4`：查詢目前 deque 最前面的元素是多少並輸出，如果 deque 為空則輸出 `error`。\n- `5`：將 deque 最後面的元素從 deque 中移除，如果 deque 為空則輸出 `error`。\n- `6`：將 deque 最前面的元素從 deque 中移除，如果 deque 為空則輸出 `error`。\n- `7`：查詢 deque 中目前有多少元素。\n\n輸入第一行有一個正整數 $N(1 \\leq N \\leq 100000)$。\n之後有 $N$ 行，每行有一個指令，指令如題敘所述，其中插入指令的 $C$ 值不超過 $10^9$。\n\n請對需要輸出的指令輸出答案並換行。\n\n",
    "output": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <set>\nusing namespace std;\nint all[3000005];\nint Begin,End;\nint main()\n{\n    //freopen(\"1-06.in\",\"rt\",stdin);\n    //freopen(\"1-06.out\",\"w+t\",stdout);\n    int N,a,b,i;\n    Begin=1500000;\n    End=Begin+1;\n    scanf(\"%d\",&N);\n    for(i=0;i<N;i++)\n    {\n        scanf(\"%d\",&a);\n        if(a==1)\n        {\n            scanf(\"%d\",&b);\n            all[End++]=b;\n        }\n        else if(a==2)\n        {\n            scanf(\"%d\",&b);\n            all[Begin--]=b;\n        }\n        else if(a==3)\n        {\n\n            if(Begin+1==End) printf(\"error\\n\");\n            else printf(\"%d\\n\",all[End-1]);\n        }\n        else if(a==4)\n        {\n            if(Begin+1==End) printf(\"error\\n\");\n            else printf(\"%d\\n\",all[Begin+1]);\n        }\n        else if(a==5)\n        {\n            if(Begin+1==End) printf(\"error\\n\");\n            else End--;\n        }\n        else if(a==6)\n        {\n            if(Begin+1==End) printf(\"error\\n\");\n            else Begin++;\n        }\n        else printf(\"%d\\n\",End-Begin-1);\n    }\n    return 0;\n}\n"
  },
  {
    "id": "ds13",
    "instruction": "APCSC 請了一位鵝老師來給大家上課。鵝老師很喜歡點名，而且很過分的是，牠點名會看著成績單，直接講出那位同學的總分。鵝老師很懶惰，牠手上的成績單由分數低到高排序，然後牠只會唸最低的那兩個分數而已 (如果最低分有兩個，它就是最低分跟第二低分)。這會產生幾個事件。\n- 鵝老師講出了最低的分數\n- 鵝老師講出了第二低的分數\n- 分數最低的同學停修了\n- 有新同學帶著他的成績加入\n\n請幫忙模擬出鵝老師的教室情況。\n\n輸入第一行有兩個正整數 $N, M (1 \\leq N \\leq 10^6, 1 \\leq M \\leq 10^4, M < N)$，$N$ 代表教室原本的學生數，$M$ 代表發生的事件數。\n第二行有 $N$ 個數字 $a_{i} (0 \\leq a_{i} \\leq 10^9)$，代表第 $i$ 位同學的總分。\n第三行以後共有 $M$ 行指令，指令的格式如下\n- `0`，輸出教室內的同學的最低分 \n- `1`，輸出教室內的同學的第二低分\n- `2`，移除教室內的同學的最低分 (如果重複，移除其中一個即可)\n- `3 a`，新增一個分數為 `a` 的同學進教室 $(0 \\leq a \\leq 10^9)$\n\n註：請用輸入優化\n請依照指令輸出同學的分數，分數之間用換行分隔。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAXN 1000000\n\nint a[MAXN];\n\nint main ()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\n\tpriority_queue<int, vector<int>, greater<int>> hp (a, a + n);\n\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint x, c;\n\t\tcin >> x;\n\n\t\tswitch (x)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tcout << hp.top() << '\\n';\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tc = hp.top();\n\t\t\t\thp.pop();\n\t\t\t\tcout << hp.top() << '\\n';\n\t\t\t\thp.push(c);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\thp.pop();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcin >> c;\n\t\t\t\thp.push(c);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "id": "ds14",
    "instruction": "這題只要你簡單練習並且熟悉 linked-list 的各種操作。\n請你實做一個 linked-list ，並實現以下指令：\n\n* `1 n` 將整數 $n$ 放進 linked-list 的頭\n* `2 n` 將整數 $n$ 放進 linked-list 的尾\n* `3 n a` 將整數 $n$ 放到整數 $a$ 的前面，若 $a$ 不存在則印出 `peko` 並略過這個操作\n* `4 n a` 將整數 $n$ 放到整數 $a$ 的後面，若 $a$ 不存在則印出 `peko` 並略過這個操作\n* `5 a` 印出整數 $a$ 前面的整數，若此整數不存在則印出 `NULL`，若 $a$ 不存在則印出 `peko`\n* `6 a` 印出整數 $a$ 後面的整數，若此整數不存在則印出 `NULL`，若 $a$ 不存在則印出 `peko`\n* `7 a` 刪除整數 $a$，若 $a$ 不存在則印出 `peko` 並略過這個操作\n\n其中保證所有操作 `1`, `2`, `3`, `4` 中的整數 $n$ 不會重複\n\n輸入第一行有一整數 $m$ ，代表接下來會有幾個指令。\n接下來 $m$ 行，每行都為敘述中所提到的指令。格式如題敘所述。\n\n* $m \\leq 20000$\n* $0 < $ 所有整數 $\\leq 100000$\n\n對每個操作 `3`,`4`,`5`,`6`,`7` 印出對應的結果，每個指令的結果之間需換行。\n\n",
    "output": "#include <iostream>\n#include <cstring>\n#define MAXN 100050\n\nusing namespace std;\n\nint ne[MAXN];\nint pr[MAXN];\nbool exists[MAXN];\nint head, tail;\n\nvoid peko()\n{\n\tcout << \"peko\\n\";\n}\n\nvoid push_front(int n)\n{\n\texists[n] = true;\n\tif (head == -1)\n\t{\n\t\thead = tail = n;\n\t}\n\telse\n\t{\n\t\tne[n] = head;\n\t\tpr[head] = n;\n\t\tpr[n] = -1;\n\t\thead = n;\n\t}\n}\n\nvoid insert_after(int n, int a)\n{\n\tif (a == -1)\n\t{\n\t\tpush_front(n);\n\t}\n\telse\n\t{\n\t\tif (a == tail) {\n\t\t\ttail = n;\n\t\t}\n\t\texists[n] = true;\n\t\tif (ne[a] != -1)\n\t\t{\n\t\t\tpr[ne[a]] = n;\n\t\t}\n\t\tne[n] = ne[a];\n\t\tne[a] = n;\n\t\tpr[n] = a;\n\t}\n}\n\nvoid del(int a)\n{\n\tif (!exists[a])\n\t{\n\t\tpeko();\n\t}\n\telse\n\t{\n\t\texists[a] = false;\n\t\tif(a == head) head = ne[a];\n\t\tif(a == tail) tail = pr[a];\n\t\tif (ne[a] != -1)\n\t\t{\n\t\t\tpr[ne[a]] = pr[a];\n\t\t}\n\t\tif (pr[a] != -1)\n\t\t{\n\t\t\tne[pr[a]] = ne[a];\n\t\t}\n\t\tne[a] = pr[a] = -1;\n\t}\n}\n\nint main()\n{\n\thead = tail = -1;\n\tmemset(pr, -1, sizeof(pr));\n\tmemset(ne, -1, sizeof(ne));\n\tint m;\n\tcin >> m;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint op, n, a;\n\t\tcin >> op;\n\t\tif (op == 1)\n\t\t{\n\t\t\tcin >> n;\n\t\t\tpush_front(n);\n\t\t}\n\t\telse if (op == 2)\n\t\t{\n\t\t\tcin >> n;\n\t\t\tinsert_after(n, tail);\n\t\t}\n\t\telse if (op == 3)\n\t\t{\n\t\t\tcin >> n >> a;\n\t\t\tif (!exists[a])\n\t\t\t{\n\t\t\t\tpeko();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinsert_after(n, pr[a]);\n\t\t\t}\n\t\t}\n\t\telse if (op == 4)\n\t\t{\n\t\t\tcin >> n >> a;\n\t\t\tif (!exists[a])\n\t\t\t{\n\t\t\t\tpeko();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinsert_after(n, a);\n\t\t\t}\n\t\t}\n\t\telse if (op == 5)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tif (!exists[a])\n\t\t\t{\n\t\t\t\tpeko();\n\t\t\t}\n\t\t\telse if (pr[a] == -1)\n\t\t\t{\n\t\t\t\tcout << \"NULL\\n\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << pr[a] << '\\n';\n\t\t\t}\n\t\t}\n\t\telse if (op == 6)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tif (!exists[a])\n\t\t\t{\n\t\t\t\tpeko();\n\t\t\t}\n\t\t\telse if (ne[a] == -1)\n\t\t\t{\n\t\t\t\tcout << \"NULL\\n\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << ne[a] << '\\n';\n\t\t\t}\n\t\t}\n\t\telse if (op == 7)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tdel(a);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "id": "ds15",
    "instruction": "A 檢定總是很受歡迎，因此不少機構推出各種方案幫助考生磨練實力，其中考生波路參加了每日一題活動。他每天會傳當天解答上去。\n在 $N$ 天結束後波路收到了初步的結果包含每天正解與否，但他並不滿意，他認為主辦方審解有誤。因此，他提出了 $K$ 次申訴，第 $i$ 次申訴針對第 $a_i$ 題，並且波路總是能申訴成功將錯的改為對的。\n波路很在意他的連續正解天數，假設在第 $p$ 次申訴後，波路的最長連續正解天數和最短連續正解天數分別是 $s_p, t_p$ ($0\\le p\\le K$)，請你輸出 $s_p$ 的總和和 $t_p$ 的總和 $(0\\le p\\le K)$。\n注意如果波路在第 $p$ 天每題都是錯的，那 $s_p = t_p = 0$。\n\n輸入第一行是兩個空白分隔的正整數 $N, K$。\n第二行是 $N$ 個空白分隔的數 $c_1, c_2, \\dots, c_N$，$c_i = 1$ 時代表波路第 $i$ 天正解，$c_i = 0$ 時代表波路第 $i$ 天答錯。\n第三行是 $K$ 個空白分隔的整數 $a_1, a_2, \\dots, a_K$，代表每次申訴的是第幾天的題目。當 $K = 0$ 時本行為空行。\n\n輸入保證 $1\\le N\\le 10^5$，$0\\le K\\le 2\\times 10^4$，$0\\le c_i\\le 1$，$1\\le a_i\\le N$。\n在申訴當下第 $a_i$ 題一定是答錯狀態，並且題目敘述中的 $s_p (0\\le p\\le K)$ 總是不超過 $10^4$。\n\n輸出兩行，第一行是一個整數代表題目敘述中的 $s_0 + s_1 + \\dots + s_K$，第二行是一個整數代表題目敘述中的 $t_0 + t_1 + \\dots + t_K$。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nint c[maxn], l[maxn], r[maxn];\nmultiset<int> s;\nint main() {\n    int n,k;\n    cin >> n >> k;\n    for(int i = 1; i <= n; i++) {\n        cin >> c[i];\n    }\n    int lst = 0;\n    for(int i = 1; i <= n+1; i++) {\n        if(!c[i]) {\n            if(i-lst-1 > 0) {\n                s.insert(i-lst-1);\n            }\n            l[i] = lst;\n            lst = i;\n        }\n    }\n    lst = n+1;\n    for(int i = n; i >= 0; i--) {\n        if(!c[i]) {\n            r[i] = lst;\n            lst = i;\n        }\n    }\n    int ans_big, ans_small;\n    if(s.empty()) {\n        ans_big = ans_small = 0;\n    }\n    else {\n        ans_big = *prev(s.end());\n        ans_small = *s.begin();\n    }\n    for(int i = 0; i < k; i++) {\n        int x;\n        cin >> x;\n        assert(c[x] == 0);\n        if(r[x]-x-1) s.erase(s.lower_bound(r[x]-x-1));\n        if(x-l[x]-1) s.erase(s.lower_bound(x-l[x]-1));\n        s.insert(r[x]-l[x]-1);\n        ans_big += *prev(s.end());\n        ans_small += *s.begin();\n        l[r[x]] = l[x];\n        r[l[x]] = r[x];\n        c[x] = 0;\n    }\n    cout << ans_big << endl << ans_small << endl;\n}\n"
  },
  {
    "id": "ds16",
    "instruction": "在一個商場有 $N$ 條排隊動線。一開始所有動線都是空的，之後依序發生了 $M$ 個事件，事件可能是以下三者之一，記錄如下：\n- 紀錄 `ADD i x` 表示一個客人 $x$ 加入了第 $i$ 條排隊隊伍最後方。\n- 紀錄 `LEAVE i` 表示第 $i$ 條排隊隊伍最前方客人完成結帳離開隊伍。\n- 紀錄 `JOIN i j` 表示第 $i$ 條動線臨時關閉，所有第 $i$ 條動線的客人依序加入第 $j$ 條動線尾端。\n\n輸入第一行是兩個數字 $N,M$，分別表示排隊動線數量和事件數。\n接著有 $M$ 條指令，每條指令一定是 `ADD i x`，`LEAVE i`，`JOIN i j` 三者之一。\n\n輸入保證 $1\\le N\\le 100$，$1\\le M\\le 2\\times 10^5$，$1\\le i, j\\le N$，$1\\le x\\le 10^6$，並保證沒有重複編號的客人，以及不會有關閉隊伍 $i$ 後客人隨即加入隊伍 $i$ 的情況。\n\n輸入保證 `ADD` 和 `JOIN` 合法。\n對於 `LEAVE i` 操作，如果第 $i$ 條隊伍是空的，請輸出 `queue i is empty!` 並忽略操作。其中 $i$ 是指隊伍編號，例如第 $3$ 條隊伍是空的則輸出 `queue 3 is empty!`\n在所有操作結束後，依序輸出 $n$ 行，第 $i$ 行輸出 `queue i: `，隨後輸出若干個空白分隔的整數表示隊伍從頭到尾排隊的人編號，如果隊伍是空的請在其後輸出 `empty`。例如若第 $1$ 條動線是空的，輸出 `queue 1: empty`，第 $2$ 條動線依序是 $1, 2$ 號排隊則輸出 `queue 2: 1 2`。請見範例。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node{\n    int val;\n    node* nxt;\n    node(){}\n    node(int _val): val(_val), nxt(nullptr){}\n} *st[110], *ed[110];\nint main() {\n    int n,m;\n    cin >> n >> m;\n    for(int i = 0; i < m; i++) {\n        string cmd;\n        cin >> cmd;\n        if(cmd == \"ADD\") {\n            int x,y;\n            cin >> x >> y;\n            if(st[x] == nullptr) {\n                st[x] = ed[x] = new node(y);\n            }\n            else {\n                ed[x]->nxt = new node(y);\n                ed[x] = ed[x]->nxt;\n            }\n        }\n        if(cmd == \"LEAVE\") {\n            int x;\n            cin >> x;\n            if(st[x] == nullptr) {\n                cout << \"queue \" << x << \" is empty!\" << endl;\n                continue;\n            }\n            if(st[x] == ed[x]) {\n                delete(st[x]);\n                st[x] = ed[x] = nullptr;\n            }\n            else {\n                node* tmp = st[x]->nxt;\n                delete(st[x]);\n                st[x] = tmp;\n            }\n        }\n        if(cmd == \"JOIN\") {\n            int x,y;\n            cin >> x >> y;\n            if(st[y] == nullptr) {\n                st[y] = st[x];\n                ed[y] = ed[x];\n                st[x] = ed[x] = nullptr;\n                continue;\n            }\n            ed[y]->nxt = st[x];\n            if(ed[x])\n                ed[y] = ed[x];\n            st[x] = ed[x] = nullptr;\n        }\n    }\n    for(int i = 1; i <= n; i++) {\n        cout << \"queue \" << i << \":\";\n        if(st[i] == nullptr) cout << \" empty\";\n        node* it = st[i];\n        while(it != nullptr) {\n            cout << \" \" << it->val;\n            it = it->nxt;\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "id": "ds17",
    "instruction": "歡迎來到一年一度的裝弱國際競賽！這裡集結了來自各地的好手，明明一個比一個厲害，卻又一個比一個會裝弱。第一輪是淘汰賽，會將與會的 $N$ 位選手分成兩隊。已知每一個選手有一個「裝弱值」，由左數來第 $i$ 位選手的「裝弱值為」 $a_i(1 \\leq a_i \\leq N)$，且已知選手們的裝弱值兩兩不相同。將這些選手分隊的流程如下：\n\n- 首先，裝弱值最高的選手、其左邊 $K$ 個選手、其右邊 $K$ 個選手都會加入第一隊（如果左、右邊不到 $K$ 個人則全數選取），這些人脫隊以後剩下的人依照原本的順序重新站好。\n- 接下來，剩下的裝弱值最高的選手，其左邊 $K$ 個選手、其右邊 $K$ 個選手都會加入第二隊（如果左、右邊不到 $K$ 個人則全數選取），這些人脫隊以後剩下的人依照原本的順序重新站好。\n- 以上的流程會一直持續直到這 $N$ 個人全部都被分到其中一個隊伍。\n\n現在，給你 $N$、$K$、和所有的 $a_i$ 的值，你可以寫一支程式輸出誰在第幾隊嗎？\n\n輸入將有兩行。第一行包含兩個數字 $N$ 與 $K(1 \\leq K \\leq N \\leq 2 \\times 10^5)$，代表與會人數與題目中提到的常數 $K$。第二行有 $N$ 個數字，第 $i$ 個數字代表 $a_i(1 \\leq a_i \\leq N)$，且保證 $a_i$ 兩兩不重複。\n\n請輸出 $N$ 個字元，其中第 $i$ 個代表從左數來第 $i$ 個選手被分到哪一隊。如果這個選手被分到第一隊，請輸出 `1`；如果她被分到第二隊請輸出 `2`。\n",
    "output": "#include <iostream>\nusing namespace std;\n\nconst int maxN = int(2e5 + 10);\n\nint N, K, team[maxN], pos[maxN];\n\nstruct Node{\n    int val;\n    Node *l, *r;\n    Node(){}\n    Node(int val): val(val), l(NULL), r(NULL){}\n} *nodes[(int)2e5 + 10];\n\n\n\nvoid toggleTeam(int &t){\n    if(t == 1) t = 2;\n    else t = 1;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    cin >> N >> K;\n    nodes[0] = new Node(-1); //start\n    for(int i = 1; i <= N; i++){\n        int v;\n        cin >> v;\n        nodes[i] = new Node(i);\n        team[i] = 0;\n        pos[v] = i;\n    }\n    nodes[N + 1] = new Node(-1);\n    nodes[0]->r = nodes[1];\n    nodes[N + 1]->l = nodes[N];\n    for(int i = 1; i <= N; i++){\n        nodes[i]->r = nodes[i + 1];\n        nodes[i]->l = nodes[i - 1];\n    }\n\n    int currentTeam = 1;\n\n    for(int v = N; v; v--){\n        if(team[pos[v]]) continue;\n        team[pos[v]] = currentTeam;\n        Node *goR = nodes[pos[v]]->r, *goL = nodes[pos[v]]->l;\n        for(int i = 0; goR->val != -1 && i < K; i++, goR = goR->r){\n            team[goR->val] = currentTeam;\n        }\n        for(int i = 0; goL->val != -1 && i < K; i++, goL = goL->l){\n            team[goL->val] = currentTeam;\n        }\n        goL->r = goR;\n        goR->l = goL;\n        toggleTeam(currentTeam);\n    }\n    for(int i = 1; i <= N; i++) cout << team[i];\n}\n\n"
  },
  {
    "id": "ds19",
    "instruction": "這題只要你簡單練習並且熟悉 heap 的各種操作。\n請你實做一個 heap ，並實現以下指令：\n\n* `1 n` 將數字 $n$ 放進 heap 中\n* `2` 拿出 heap 中的最大值，如果 heap 是空的則輸出 `QQ` 並略過這個操作，否則執行操作且不輸出任何東西。\n* `3` 印出 heap 中的最大值，如果 heap 是空的，則輸出 `QQ`\n* `4` 印出當前 heap 中存放了多少數字\n\n輸入第一行有一整數 $m$，代表接下來會有幾個指令。\n接下來 $m$ 行，每行都為敘述中所提到的指令。格式如題敘所述。\n\n* $m \\leq 200000$\n* 保證指令 `1` 輸入的數字範圍為 `int`\n* 保證沒有非法指令\n\n對每個操作 `2`,`3` 與 `4` 印出對應的結果，每個指令的結果之間需換行。\n\n",
    "output": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main() {\n\tint op;\n\tint n, a;\n\tcin >> n;\n\tpriority_queue<int> pq;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> op;\n\t\tswitch (op)\n\t\t{\n\t\tcase 1:\n\t\t\tcin >> a;\n\t\t\tpq.push(a);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (!pq.empty()) {\n\t\t\t\tpq.pop();\n\t\t\t} else {\n\t\t\t\tcout << \"QQ\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (!pq.empty()) {\n\t\t\t\tcout << pq.top() << '\\n';\n\t\t\t} else {\n\t\t\t\tcout << \"QQ\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcout << pq.size() << endl;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "id": "ds20",
    "instruction": "這裡是合太醫院急診室，是全合灣最好的醫療中心。當然，那麼好的醫學中心也有一個很先進的看診排程系統：隨著病患的進出，每一個病患都會給一個*嚴重值* $x$，而會有下列的四種操作：\n\n- `1 x`：代表有一個嚴重值為 $x$ 的病患進入醫院了，必須予以紀錄。\n- `2`：醫生會看診目前在醫院中嚴重值最**小**的病患中的其中一位，並且看診完之後這個病患就離開醫院。請輸出這個病患的嚴重值。\n- `3`：有時候，醫生也會想要休息一下：醫生會看診目前在醫院中嚴重值最**大**的病患中的其中一位，並且看診完之後這個病患就離開醫院。請輸出這個病患的嚴重值。\n- 倘若醫院已經沒有病患了，但是有 `2` 或 `3` 這兩個操作的話，那請輸出 `EMPTY`。\n\n已知總共會有 $N$ 筆操作，你可以幫忙模擬合太醫院的看診排程系統嗎？\n\n輸入有 $N + 1$ 行。第一行將有一個數字 $N$（$1 \\leq N \\leq 2 \\cdot 10^ 5$），代表共有幾次操作。接下來每一行可能型如 `1 x`（$|x| \\leq 10^ 9$）、`2`、或 `3`，而它們的功用已於題敘中說明。請注意，輸入的 $x$ 可能會重複。\n\n保證每一筆資料當中一定至少有一個 `2` 或 `3` 的操作。\n\n\n對於每一個 `2` 或 `3` 的操作，請輸出相對應的答案。\n\n",
    "output": "#include <iostream>\n#include <map>\n#define ericxiao ios_base::sync_with_stdio(0);cin.tie(0);\n#define endl '\\n'\n#define F first\n#define S second\nusing namespace std;\n\nmap<int, int> mp;\n\ninline void getMx(){\n\tif(!mp.size()){\n\t\tcout << \"EMPTY\" << endl;\n\t\treturn;\n\t}\n    auto it = --mp.end();\n\tcout << it->F << endl;\n    it->S--;\n    if(!it->S) mp.erase(it);\n}\n\ninline void getMn(){\n\tif(!mp.size()){\n\t\tcout << \"EMPTY\" << endl;\n\t\treturn;\n\t}\n    auto it = mp.begin();\n\tcout << it->F << endl;\n    it->S--;\n    if(!it->S) mp.erase(it);\n}\n\ninline void add(int x){\n    if(!mp.count(x)) mp[x] = 0;\n    mp[x]++;\n}\n\nint main() {\n\tericxiao\n    int N, com, x;\n    cin >> N;\n    while(N--){\n        cin >> com;\n        if(com == 1){\n            cin >> x;\n            add(x);\n        } else if(com == 2){\n            getMn();\n        } else {\n            getMx();\n        }\n    }\n}\n"
  },
  {
    "id": "ds21",
    "instruction": "APCS game 一款流行於學生間的射擊遊戲，遊戲主要有下列兩種指令。\n- `1 x y z`：在座標 $(x,y,z)$ 出現了一個目標。\n- `2`：要你瞄準一個離原點最近的目標並將其射擊掉，如果有多個目標離遠點距離相同，則射擊 $x$ 座標較小者，若 $x$ 座標也相同，則射擊 $y$ 座標較小者，若 $y$ 座標也相同，則射擊 $z$ 座標較小者，若該座標有多個目標，則射擊任意一個即可，該目標被射擊之後就會從場上消失。\n\n輸入第一行有一個正整數 $N(1 \\leq N \\leq 100000)$。\n之後有 $N$ 行，每行有一個指令，指令如題序所述，其中座標的絕對值不超過 $10^9$，且保證座標數值均為整數。\n\n請在射擊指令的時候輸出你所射擊的座標，如果場上已經沒有目標，請輸出 `none`。\n\n",
    "output": "#include <stdio.h>\n#include <stdlib.h>\n\n#include <iostream>\n#include <queue>\nusing namespace std;\nstruct A {\n  long long x, y, z;\n  long long all;\n};\nbool operator>(A a, A b) {\n  if (a.all != b.all) return a.all > b.all;\n  if (a.x != b.x) return a.x > b.x;\n  if (a.y != b.y) return a.y > b.y;\n  if (a.z != b.z) return a.z > b.z;\n  return false;\n}\npriority_queue<A, vector<A>, greater<A> > all;\nint main() {\n  long long N, t, i;\n  A tt;\n  scanf(\"%lld\", &N);\n  for (i = 0; i < N; i++) {\n    scanf(\"%lld\", &t);\n    if (t == 1) {\n      scanf(\"%lld %lld %lld\", &tt.x, &tt.y, &tt.z);\n      tt.all = tt.x * tt.x + tt.y * tt.y + tt.z * tt.z;\n      all.push(tt);\n    } else {\n      if (all.empty())\n        printf(\"none\\n\");\n      else {\n        printf(\"%lld %lld %lld\\n\", all.top().x, all.top().y, all.top().z);\n        all.pop();\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "id": "ds22",
    "instruction": "小風正在玩 RPG 遊戲，這個遊戲需要玩家們藉由學習**攻擊**與**防守**的能力值來獲取技能，遊戲中共有 $N$ 個技能，每個技能都必須要至少有 $a_i$ 的攻擊力以及 $b_i$ 的防守力才能夠習得，小風每一秒鐘只能讓某個能力值提升一點，且一開始攻擊力以及防守力都是 $0$，請問他至少要花費多少時間才能夠習得其中的 $K$ 個技能呢？\n\n輸入第一行有兩個正整數 $N, K (1 \\leq K \\leq N \\leq 10^6)$，代表技能的數量以及想學習的技能數。\n接下來共有 $N$ 行，第 $i$ 行有兩個正整數 $a_i, b_i (1 \\leq a_i, b_i \\leq 10^6)$，代表學習這個技能所需要的最小攻擊力與防守力。\n\n請輸出一個正整數，表示至少需要花費多久時間才能夠達成目標。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n\n  int n, k; cin >> n >> k;\n  vector<pair<int, int>> a(n);\n  for(int i = 0; i < n; i++) cin >> a[i].first >> a[i].second;\n\n  sort(a.begin(), a.end());\n  int ans = INT_MAX;\n  priority_queue<int> pq;\n  for(int i = 0; i < n; i++) {\n    pq.push(a[i].second);\n    while(int(pq.size()) > k) pq.pop();\n    if(int(pq.size()) == k) ans = min(ans, a[i].first + pq.top());\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "ds23",
    "instruction": "set 是一種能支援插入（已經存在的數字則忽略），刪除某個數字，查詢 set 裡面有幾個元素，查詢最大最小值的資料結構。\n這題要你學會使用 set，指令如下。\n`1 C`：將數字 $C$ 插入 set，如果數字 $C$ 已經在裡面則忽略。\n`2 C`：將數字 $C$ 從 set 刪除，如果數字 $C$ 不在裡面則輸出 `error`。\n`3`：查詢目前 set 裡面有多少元素。\n`4`：查詢 set 中的最小值，如果 set 為空則輸出 `error`。\n`5`：查詢 set 中的最大值，如果 set 為空則輸出 `error`。\n\n輸入第一行有一個正整數 $N(1 \\leq N \\leq 100000)$。\n之後有 $N$ 行，每行有一個指令，指令如題序所述，其中插入與刪除指令的 $C$ 絕對值不超過 $10^9$。\n請對需要輸出的指令輸出答案並換行。\n",
    "output": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <set>\nusing namespace std;\nset < int > all;\nint main()\n{\n    int N,a,b,i;\n    scanf(\"%d\",&N);\n    for(i=0;i<N;i++)\n    {\n        scanf(\"%d\",&a);\n        if(a==1)\n        {\n            scanf(\"%d\",&b);\n            all.insert(b);\n        }\n        else if(a==2)\n        {\n            scanf(\"%d\",&b);\n            if(all.find(b)==all.end()) printf(\"error\\n\");\n            else all.erase(b);\n        }\n        else if(a==3) printf(\"%d\\n\",(int) all.size());\n        else if(a==4)\n        {\n            if(all.empty()) printf(\"error\\n\");\n            else printf(\"%d\\n\",*all.begin());\n        }\n        else if(a==5)\n        {\n            if(all.empty()) printf(\"error\\n\");\n            else printf(\"%d\\n\",*prev(all.end()));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "id": "ds24",
    "instruction": "身為一位競賽選手，你時常在網路上找題目來寫，具體而言，你會有以下三種操作。\n\n* `1 C`：將困難程度為 $C$ 的題目放進題單，如果題單裡面已經有相同困難程度的題目則忽略（數字越大代表題目越難）。\n* `2`：因為你想要耍廢，所以你會將題單裡最簡單的題目寫掉，同時將那題從題單中移除，並告訴大家你寫了哪個困難程度的題目（如果題單裡面已經沒有題目了請輸出 `done` )。\n* `3`：因為你想要訓練自己，所以你會將題單裡最難的題目寫掉，同時將那題從題單中移除，並告訴大家你寫了哪個困難程度的題目（如果題單裡面已經沒有題目了請輸出 `done` )。\n\n輸入第一行有一個正整數 $N(1 \\leq N \\leq 100000)$。\n之後有 $N$ 行，每行有一個指令，指令如題序所述，其中題目困難程度的絕對值不超過 $10^9$。\n請在做題指令的時候輸出你做了哪個困難程度的題目；如果已經沒有題目可做，請輸出 `done`。\n\n",
    "output": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <set>\nusing namespace std;\nset < int > all;\nint main()\n{\n    int N,a,b,i,t;\n    scanf(\"%d\",&N);\n    for(i=0;i<N;i++)\n    {\n        scanf(\"%d\",&a);\n        if(a==1)\n        {\n            scanf(\"%d\",&b);\n            all.insert(b);\n        }\n        else if(a==2)\n        {\n            if(all.empty()) printf(\"done\\n\");\n            else\n            {\n                t=*all.begin();\n                printf(\"%d\\n\",t);\n                all.erase(t);\n            }\n        }\n        else if(a==3)\n        {\n            if(all.empty()) printf(\"done\\n\");\n            else\n            {\n                t=*prev(all.end());\n                printf(\"%d\\n\",t);\n                all.erase(t);\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "id": "ds25",
    "instruction": "恭喜你，現在成為了「英格蘭創意香腸」（Creative Sausages In England, CSIE）的董事長了！作為 CSIE 的董事長，你必須管理香腸工廠的製程與監督成本。你發現，如果有一條長度為 $l$ 的香腸被切成兩段，則所花費的成本就是這條香腸的長度。現在，就是想要計算一個長度為 $L$ 的香腸依照某種順序切若干段後的總成本。\n\n如果將這一條香腸想像成左端在數線的 $0$ 處、右段在數線的 $L$ 處的話，則可以想像有 $N$ 次切割的動作，第 $i$ 次會切在某一個位置 $x_i$。請注意，不會有兩次的切割在一樣的地方，亦即 $x_i$ 是兩兩相異的。\n\n譬如說，我有一個長度為 $4$ 的香腸，我先後在上面 $1, 2$ 的位置切割，則第一刀後，一個長度為 $4$ 的香腸會變成一個長度為 $1$ 和一個長度為 $3$ 的香腸，而第二次切割後，會變成一個長度為 $1$、一個長度為 $1$，和一個長度為 $2$ 的香腸，總花費 $4 + 3 = 7$。如果反過來切的話，則花費為 $4 + 2 = 6$。\n\n輸入將有 $N + 1$ 行。第一行將有兩個數字 $N$（$1 \\leq N \\leq 2 \\times 10^5$）與 $L$（$1 \\leq L \\leq 10^7$），分別代表切了幾刀與香腸總長度。接下來的第 $i$（$1 \\leq i \\leq N$）行會有兩個數字 $x$ $k$，代表第 $k$（$1 \\leq k \\leq N$）刀切在 $x$ （$0 \\leq x \\leq L$）的位子。保證所有的 $k$ 在 $[1, N]$ 內且兩兩相異，且所有 $x$ 兩兩相異。\n\n此外，對於佔分 $20\\%$ 的測試資料，額外保證 $N \\leq 1000$，且對於另外佔分 $30\\%$ 的測試資料，$N \\leq 50000$。\n\n請輸出一個數字，代表最後的總時間花費。\n",
    "output": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <utility>\n#define pii pair<int,int>\n#define F first\n#define S second\n#define ericxiao ios_base::sync_with_stdio(0);cin.tie(0);\n#define int long long int\nusing namespace std;\n\nconst int maxN = 2e5 + 326;\nint N, L, cut[maxN], x, t;\nset<pii> st;\n\n\n//bugs: overflow\n\nsigned main(){\n    ericxiao;\n    cin >> N >> L; \n    for(int i = 0; i < N; i++){\n        cin >> x >> t;\n        cut[t] = x;\n    }\n    st.insert({0, L});\n    int ans = 0;\n    int l, r;\n    for(int i = 1; i <= N; i++){\n        auto it = --st.upper_bound({cut[i], L + 1});\n        l = it->F;\n        r = it->S;\n        ans += (r - l);\n        st.erase(it);\n        st.insert({l, cut[i]});\n        st.insert({cut[i], r});\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "id": "ds26",
    "instruction": "你現在有一臺吐鈔機，它會不斷地吐出鈔票！但是，在這之前你要確定這個吐鈔機是有好好運作的。這臺吐鈔機所吐出來的每一張鈔票上面都會有一個理論上是唯一的辨識碼，是一個由英文小寫字母組成的字串 $S$（$1 \\leq |S| \\leq 20$）。然而，這個吐鈔機有時候會故障而吐出之前有出現過的辨識碼！\n\n你的工作是負責紀錄這一臺吐鈔機吐了 $N$ （$1 \\leq N \\leq 10^5$）張鈔票後的結果：給每一張新出現的鈔票賦予一個從 $1$ 開始的編號，而如果這一張鈔票已經出現過了，則丟棄之，避免自己偷偷印鈔票這件事露出馬腳。\n\n輸入將有 $N + 1$ 行。第一行是一個正整數 $N$（$1 \\leq N \\leq 10^5$），代表印了幾張鈔票；接下來的每一行都會有一個字串 $S$ ，代表印出來的鈔票的編碼。保證 $S$ 的長度不超過 $20$，且 $S$ 由小寫英文字母所組成。 \n對於每一個新印出來的鈔票，如果它之前沒有出現過的話，請輸出 `TAK x`，此處 $x$ 是從 $1$ 開始的編號。否則，請輸出 `NIE x`，此處 $x$ 是它之前被賦予的編號。如果還是不清楚的話，請參考範例。\n",
    "output": "#include <iostream>\n#include <string.h>\n#include <map>\n#define ericxiao ios_base::sync_with_stdio(0);cin.tie(0);\n#define endl '\\n';\nusing namespace std;\n\nmap<string, int> mp;\nint N, cnt;\n\nint main() {\n\tericxiao\n\tcin >> N;\n\tstring s;\n\twhile(N--){\n\t\tcin >> s;\n\t\tif(mp.count(s)){\n\t\t\tcout << \"NIE \" << mp[s] << endl;\n\t\t} else {\n\t\t\tcout << \"TAK \" << ++cnt << endl;\n            mp[s] = cnt;\n\t\t}\n\t}\n}\n"
  },
  {
    "id": "ds27",
    "instruction": "學姐是一個置物櫃的管理員，這個置物櫃有 $N$ 行 $M$ 列的格子，一開始都是空的。接下來的 $T$ 天，每一天會發生以下三種事件的其中一種：\n\n1. 一個學生在第 $i$ 行第 $j$ 列的格子放了編號為 $k$ 的東西。\n2. 一個學生問學姐第 $i$ 行第 $j$ 列的格子裡面最晚被放進去的東西編號是多少\n3. 一個學生把第 $i$ 行第 $j$ 列的格子中最晚放進去的東西拿出來，但如果該格子是空的，什麼事情都不會發生。\n\n但是學姐常常偷睡覺，所以她請你幫她回答學生的問題。\n\n輸入第一行有三個正整數，分別代表題目中的 $N, M, T$ 。接下來 $T$ 行，每一行的格式都會是以下其中一種：\n\n- `1 i j k` -- 學生在第 $i$ 行第 $j$ 列放入編號為 $k$ 的物品。\n- `2 i j` -- 學生詢問第 $i$ 行第 $j$ 列裡面最晚被放入的物品編號。\n- `3 i j` -- 學生將第 $i$ 行第 $j$ 列最晚被放入的物品拿出來，如果該格子是空的，則什麼都不發生。\n\n請特別注意，物品的編號 $k$ 是可以重複的。\n\n\n- $1 \\le N, M, T \\le 10^5$\n- $1 \\le i \\le N$\n- $1 \\le j \\le M$\n- $1 \\le k \\le 10^9$\n\n對於每個第二種操作（學生的詢問）輸出一行：若該格有物品，輸出一個正整數代表該置物格中最晚被放進去的物品的編號，否則輸出 ```empty``` 。\n\n",
    "output": "/*input\n10 10 9\n1 1 1 3\n2 1 1\n3 1 1\n2 1 1\n1 1 3 2\n1 1 3 3\n2 1 3\n3 1 3\n2 1 3\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=300005;\n\nmap<pair<int,int>, vector<int>> mp;\n\nint main(){\n\tint n,m,t;\n\tcin>>n>>m>>t;\n\twhile(t--){\n\t\tint type, i, j;\n\t\tcin>>type>>i>>j;\n\t\tif(type == 1){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tif(!mp.count(make_pair(i, j))){\n\t\t\t\tmp[make_pair(i, j)] = vector<int>();\n\t\t\t}\n\t\t\tmp[make_pair(i, j)].push_back(k);\n\t\t}\n\t\telse if(type == 2){\n\t\t\tif(!mp.count(make_pair(i, j))){\n\t\t\t\tcout<<\"empty\\n\";\n\t\t\t}\n\t\t\telse if(mp[make_pair(i, j)].size() > 0){\n\t\t\t\tcout<<mp[make_pair(i, j)].back()<<'\\n';\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"empty\\n\";\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(mp.count(make_pair(i, j)) && mp[make_pair(i, j)].size() > 0)\n\t\t\t\tmp[make_pair(i, j)].pop_back();\n\t\t}\n\t}\t\n}\n"
  },
  {
    "id": "ds28",
    "instruction": "在 JOI 國有個火車叫 JOI 小火車。\n這個火車總共有 $M$ 截車廂，上面總共載了 $N$ 個人。\n車廂由左排到右，其中第 $i$ 截車廂，原本上面有 $A_i$ 個人。\n每個車廂裡面的人也是從左排到右，裡面的人彼此不會交換位置。\n為了方便起見，我們從最左邊到最右邊給人編號 $1,2,3\\ldots,N$。\n\n接下來發生了 $Q$ 個事件\n\n1. 第 $x$ 截車廂上面最左邊的人，跑去第 $x-1$ 截車廂的最右邊了。\n2. 第 $x$ 截車廂上面最左邊的人，忽然跳下車離開了！\n3. 第 $x$ 截車廂上面最右邊的人，跑去第 $x+1$ 截車廂的最左邊了。\n4. 第 $x$ 截車廂上面最右邊的人，忽然跳下車離開了！\n\n想請問你最後這個火車裡面人的分佈狀況？\n\n輸入第一行有三個正整數 $N, M, Q(N, M, Q \\le 10^6)$ 以一個空白隔開。\n接下來一行有 $M$ 個整數以一個空白隔開，$A_1, A_2,\\ldots,A_M$。\n接下來有 $Q$ 行，每行都是下列四種中的其中一種。\n\n車廂從第1截開始編號\n\n1. `d x` 代表第 $x$ 截車廂上面最左邊的人，跑去第 $x-1$ 截車廂的最右邊了。\n2. `q x` 代表第 $x$ 截車廂上面最左邊的人，忽然跳下車離開了！\n3. `b x` 代表第 $x$ 截車廂上面最右邊的人，跑去第 $x+1$ 截車廂的最左邊了。\n4. `p x` 代表第 $x$ 截車廂上面最右邊的人，忽然跳下車離開了！\n\n請輸出 $M$ 行，其中第 $i$ 行代表第 $i$ 截車廂的狀況。\n每一行先輸出一個整數 $s$ 代表這個車廂有多少人，接下來 $s$ 個整數代表人的編號，由左邊到右邊。\n\n舉例來說假設有個車廂上面有 $3$ 個人，分別是 $3, 2, 5$。\n那就請輸出 `3 3 2 5`（注意到整數間都以一個空白隔開）。\n\n",
    "output": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\n\tint N, M, Q;\n\tcin >> N >> M >> Q;\n\n\tvector<int> cnt(M);\n\tfor (int &i : cnt) cin >> i;\n\n\tvector<deque<int>> ids(M);\n\n\tfor (int id = 1, i = 0;i < M;++i) {\n\t\tfor (int j = 0;j < cnt[i];++j)\n\t\t\tids[i].push_back(id++);\n\t}\n\n\twhile (Q--) {\n\t\tchar op;\n\t\tint x;\n\t\tcin >> op >> x; --x;\n\t\tif (op == 'b') {\n\t\t\tids[x+1].push_front(ids[x].back());\n\t\t\tids[x].pop_back();\n\t\t} \n\t\tif (op == 'd') {\n\t\t\tids[x-1].push_back(ids[x].front());\n\t\t\tids[x].pop_front();\n\t\t}\n\t\tif (op == 'p') {\n\t\t\tids[x].pop_back();\n\t\t}\n\t\tif (op == 'q') {\n\t\t\tids[x].pop_front();\n\t\t}\n\t}\n\tfor (int i = 0;i < M;++i) {\n\t\tcout << ids[i].size();\n\t\tfor (int u : ids[i])\n\t\t\tcout << ' ' << u;\n\t\tcout << '\\n';\n\t}\n}\n"
  },
  {
    "id": "ds31",
    "instruction": "在一個座標平面上，原點有一座敵人的城堡，而我軍要在其他座標上部屬許多部隊。\n精確來說，每個部隊是由一排排好的士兵組成，且我們稱一個部隊內排最前面的為前排士兵，排最後面的為後排士兵。\n由於最近這個地區動盪不安，敵軍城堡頻有動作，因此需要不斷調度兵力以抵禦敵人。\n\n總結來說依序共有 $N$ 個兵力調度事件，分成四類：\n1.  座標 $(x, y)$ 的部隊空降一名編號為 $i$ 的士兵成為前排士兵。\n2.  座標 $(x, y)$ 的部隊空降一名編號為 $i$ 的士兵成為後排士兵。\n3.  座標 $(x, y)$ 的部隊請求一名前排士兵，到該部隊前排支援。\n4.  座標 $(x, y)$ 的部隊請求一名後排士兵，到該部隊後排支援。\n\n事件3、4中，前排士兵要由其他部隊的前排士兵來支援，後排士兵要由其他部隊的後排士兵來支援。且支援會由安全度最接近的部隊來派兵（安全度定義為與敵人城堡距離的平方。若安全度之差相同，則選擇 x 較小的部隊。若 x 仍相同，則選擇 y 較小的部隊。）。\n\n最初，我軍在地圖上沒有任何士兵。求 $N$ 個事件後，每個編號的士兵待在哪個座標。\n\n輸入第一行有一個正整數 $N$，代表有多少事件。\n接下來 $N$ 行每行都會是下列其中一種\n\n1. `1 x y i` 座標 $(x, y)$ 的部隊空降一名編號為 $i$ 的士兵成為前排士兵\n2. `2 x y i` 座標 $(x, y)$ 的部隊空降一名編號為 $i$ 的士兵成為後排士兵\n3. `3 x y` 座標 $(x, y)$ 的部隊請求一名前排士兵\n4. `4 x y` 座標 $(x, y)$ 的部隊請求一名後排士兵\n\n- $1 \\leq N \\leq 3 \\cdot 10^5$\n- $-10^9 \\leq x, y \\leq 10^9$\n- 若 $x_a^2 + y_a^2 = x_b^2 + y_b^2$ 則 $(x_a, y_a) = (x_b, y_b)$\n- $i$ 兩兩不重複\n- $1 \\le i \\le N$\n- 在事件 3, 4中，保證請求得到支援。\n\n令 $M$ 為士兵的數量。\n請輸出 $M$ 行，第 $j$ 行請輸出編號第 $j$ 小的士兵所在的座標，以一個空白隔開。\n\n",
    "output": "#include <queue>\n#include <iostream>\n#include <map>\nusing namespace std;\nusing ll = long long;\n\nll dis(pair<ll,ll> a) { \n\treturn a.first * a.first\n\t\t+ a.second * a.second;\n}\n\nstruct cmp {\n\tbool operator()(pair<ll,ll> a, pair<ll,ll> b) const {\n\t\treturn make_pair(dis(a), a) < make_pair(dis(b), b);\n\t}\n};\n\npair<ll,ll> min_dis(pair<ll,ll> mid, pair<ll,ll> a, pair<ll,ll> b) {\n\tif (abs(dis(a) - dis(mid)) < abs(dis(b) - dis(mid))\n\t\t\t|| abs(dis(a) - dis(mid)) == abs(dis(b) - dis(mid)) \n\t\t\t&& a < b)\n\t\treturn a;\n\treturn b;\n}\n\nmap<pair<ll,ll>, deque<int>, cmp> sold;\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\n\tint N;\n\tcin >> N;\n\n\twhile (N--) {\n\t\tint t, x, y, i;\n\t\tcin >> t >> x >> y;\n\t\tif (t <= 2) cin >> i;\n\n\t\tif (t == 1) sold[{x, y}].push_front(i);\n\t\tif (t == 2) sold[{x, y}].push_back(i);\n\t\tif (t > 2) {\n\t\t\tauto it = sold.insert({{x, y}, {}}).first;\n\t\t\tpair<ll,ll> take = it->first;\n\t\t\tauto update = [&](auto tar) {\n\t\t\t\tif (take == it->first) {\n\t\t\t\t\ttake = tar->first;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttake = min_dis({x, y}, take, tar->first);\n\t\t\t};\n\t\t\tif (it != prev(end(sold))) update(next(it));\n\t\t\tif (it != begin(sold)) update(prev(it));\n\n\t\t\tif (t == 3) {\n\t\t\t\tint v = sold[take].front();\n\t\t\t\tsold[take].pop_front();\n\t\t\t\tit->second.push_front(v);\n\t\t\t}\n\t\t\tif (t == 4) {\n\t\t\t\tint v = sold[take].back();\n\t\t\t\tsold[take].pop_back();\n\t\t\t\tit->second.push_back(v);\n\t\t\t}\n\t\t\tif (sold[take].empty())\n\t\t\t\tsold.erase(take);\n\t\t}\n\t}\n\tmap<int, pair<ll,ll>> location;\n\tfor (auto [p, d] : sold) {\n\t\tfor (int id : d)\n\t\t\tlocation[id] = p;\n\t}\n\tfor (auto [i, p] : location)\n\t\tcout << p.first << ' ' << p.second << '\\n';\n}\n"
  },
  {
    "id": "ds32",
    "instruction": "在大 JOI 高中裡面有 $N$ 個人，裡面的社交關係錯綜複雜。\n已知最一開始的時候，這 $N$ 個人兩兩不認識。\n在接下來的 $M$ 天之中，每天都有一些事情發生。\n\n1. 第 $x$ 個人和第 $y$ 個人認識了。\n\t因為 JOI 高中裡面的人都很熱情，所以如果 $a, b$ 兩個人認識，那他們就會介紹所有自己的朋友給對方的所有朋友認識，進而形成更大的交友圈。\n2. 你忽然很想知道第 $x$ 個人和第 $y$ 個人認不認識。\n3. 你忽然很想知道第 $x$ 個人認識幾個人（包含他自己）。\n\n請你在第 2, 3 種事件時，輸出你想要知道的資訊！\n\n輸入第一行有兩個正整數 $N, M(N \\le 10^6, M \\le 10^6)$ 以空白隔開。\n第二行開始有 $M$ 行，每行都會是底下三種的其中一種\n\n1. `1 x y` 代表 $x, y(1 \\le x, y \\le N)$ 今天突然認識了。（保證他們以前絕對不認識）。\n2. `2 x y` 代表你忽然很想知道第 $x(1 \\le x \\le N)$ 個人和第 $y(1 \\le y \\le N)$ 個人認不認識。\n3. `3 x` 你忽然很想知道第 $x(1 \\le x \\le N)$ 個人認識幾個人（包含他自己）。\n\n註：每個人都認識自己。\n\n遇到第 2 種事件時，如果兩人認識請輸出一行 `Yes` 不然請輸出一行 `No`。\n遇到第 3 種事件時，請輸出一行整數代表答案。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 1e6 + 10;\n\nint N, M;\n\nint g[MAX_N], sz[MAX_N];\n\nint find(int i) {\n\treturn i == g[i] ? i : g[i] = find(g[i]); \n}\nvoid merge(int a, int b) {\n\ta = find(a), b = find(b);\n\tif (a == b) return;\n\tif (sz[a] < sz[b]) swap(a, b);\n\tsz[a] += sz[b];\n\tg[b] = a;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\n\tcin >> N >> M;\n\n\tfor (int i = 1;i <= N;++i)\n\t\tg[i] = i, sz[i] = 1;\n\n\tfor (int t, x, y;M--;) {\n\t\tcin >> t;\n\t\tif (t == 1) {\n\t\t\tcin >> x >> y;\n\t\t\tmerge(x, y);\n\t\t} else if (t == 2) {\n\t\t\tcin >> x >> y;\n\t\t\tcout << (find(x) == find(y) ? \"Yes\" : \"No\") << '\\n';\n\t\t} else {\n\t\t\tcin >> x;\n\t\t\tcout << sz[find(x)] << '\\n';\n\t\t}\n\t}\n\n}\n"
  },
  {
    "id": "ds34",
    "instruction": "在大 JOI 高中裡面有 $N$ 個人，裡面的社交關係錯綜複雜。\n已知最一開始的時候，這 $N$ 個人兩兩不認識。\n在接下來的 $M$ 天之中，每天都有一些事情發生。\n\n1. 第 $x$ 個人和第 $y$ 個人認識了。\n\t因為 JOI 高中裡面的人都很熱情，所以如果 $a, b$ 兩個人認識，那他們就會介紹所有自己的朋友給對方的所有朋友認識，進而形成更大的交友圈。\n2. 你忽然很想知道第 $x$ 個人和第 $y$ 個人認不認識。\n3. 你忽然很想知道第 $x$ 個人認識幾個人（包含他自己）。\n4. 你忽然很想知道現在有多少個朋友組合，也就是說存在多少 $i < j$，且第 $i, j$ 兩個人互相認識。\n\n請你在第 2, 3, 4 種事件時，輸出你想要知道的資訊！\n\n輸入第一行有兩個正整數 $N, M(N \\le 10^6, M \\le 10^6)以空白隔開。\n第二行開始有 $M$ 行，每行都會是底下三種的其中一種\n\n1. `1 x y` 代表 $x, y(1 \\le x, y \\le N)$ 今天突然認識了。（保證他們以前絕對不認識）。\n2. `2 x y` 代表你忽然很想知道第 $x(1 \\le x \\le N)$ 個人和第 $y(1 \\le y \\le N)$ 個人認不認識。\n3. `3 x` 你忽然很想知道第 $x(1 \\le x \\le N)$ 個人認識幾個人（包含他自己）。\n4. `4` 你忽然很想知道現在有多少個朋友組合，也就是說存在多少 $i < j$，且第 $i, j$ 兩個人互相認識。\n\n註：每個人都認識自己。\n\n遇到第 2 種事件時，如果兩人認識請輸出一行 `Yes` 不然請輸出一行 `No`。\n遇到第 3, 4 種事件時，請輸出一行整數代表答案。\n\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 1e6 + 10;\n\nint N, M;\n\nlong long res;\n\nint g[MAX_N], sz[MAX_N];\n\nint find(int i) {\n\treturn i == g[i] ? i : g[i] = find(g[i]); \n}\nvoid merge(int a, int b) {\n\ta = find(a), b = find(b);\n\tif (a == b) return;\n\tif (sz[a] < sz[b]) swap(a, b);\n\tres += 1ll * sz[a] * sz[b];\n\tsz[a] += sz[b];\n\tg[b] = a;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\n\tcin >> N >> M;\n\n\tfor (int i = 1;i <= N;++i)\n\t\tg[i] = i, sz[i] = 1;\n\n\tfor (int t, x, y;M--;) {\n\t\tcin >> t;\n\t\tif (t == 1) {\n\t\t\tcin >> x >> y;\n\t\t\tmerge(x, y);\n\t\t} else if (t == 2) {\n\t\t\tcin >> x >> y;\n\t\t\tcout << (find(x) == find(y) ? \"Yes\" : \"No\") << '\\n';\n\t\t} else if (t == 3) {\n\t\t\tcin >> x;\n\t\t\tcout << sz[find(x)] << '\\n';\n\t\t} else {\n\t\t\tcout << res << '\\n';\n\t\t}\n\t}\n\n}\n"
  },
  {
    "id": "enumerate01",
    "instruction": "你和朋友一行 $N$ 人被困在密室中，提示上寫道「人山人海，$M$ 斤八兩」並放著一個體重計，你馬上意識到要取前兩個字解讀，也就是放上三個總和 $M$ 斤的人。\n\n然而你卻好奇有多少通關方式，因此你問了現場 $N$ 個人的體重，並想找出有多少種選出三人的方式總和剛好是 $M$ 斤。請注意，兩人體重有可能會相同，此時他們仍算不同人。\n\n輸入第一行是兩個空白分隔的數字 $N, M$ 分別代表密室人數和目標總重。\n第二行有 $N$ 個空白分隔的數字 $a_1, a_2, \\dots, a_N$ ， 代表所有人分別幾斤。\n\n$30\\%$ 測資保證 $1\\le N\\le 200$ ， $1\\le M, a_i\\le 10^9$ 。\n\n$70\\%$ 測資保證 $1\\le N\\le 5000$ ， $1\\le M, a_i\\le 10^9$ 。\n\n輸出一行一個整數，代表有幾種選出三人的方法可以過關。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5010;\nlong long a[maxn];\nint main() {\n    int N, M;\n    cin >> N >> M;\n    for(int i = 0; i < N; i++) {\n        cin >> a[i];\n    }\n    sort(a, a+N);\n    long long ans = 0;\n    for(int i = 0; i < N; i++) {\n        for(int j = i+1; j < N; j++) {\n            ans += upper_bound(a+j+1, a+N, M-a[i]-a[j]) - lower_bound(a+j+1, a+N, M-a[i]-a[j]);\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "id": "enumerate02",
    "instruction": "因數是一個常見的數學名詞，用於描述自然數 $a$ 和自然數 $b$ 之間存在的整除關係。若正整數 $a, b$ 滿足存在另外一個正整數 $q$ 使得 $a = bq$ ，則我們說 $b$ 是 $a$ 的因數。由定義我們可以知道 對於所有正整數 $n \\ge 2$ ， $1, n$ 都是 $n$ 的因數，也就是說 $1$ 是唯一一個只有一個因數的正整數。\n給定一個正整數 $N$ ，請輸出他的所有正因數。\n輸入只有一行，包含一個正整數代表題目中的 $N$。\n\n- $1 \\le N \\le 10^{12}$\n\n請將 $N$ 的所有因數從小到大，用空白分隔輸出一行。 \n",
    "output": "/*input\n1\n1\n*/\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst long long maxn=100005;\n\nvector<long long int> v;\n\nint main(){\n\tlong long n;\n\tcin>>n;\n\tfor(int i = 1; (long long)i * i <= n; i++){\n\t\tif(n % i == 0){\n\t\t\tv.push_back(i);\n\t\t\tif(i * i != n) v.push_back(n / i);\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tfor(int i = 0; i < v.size(); i++){\n\t\tcout<<v[i]<<\" \\n\"[i == v.size() - 1];\n\t}\n\treturn 0;\n}\n"
  },
  {
    "id": "enumerate03",
    "instruction": "學姐骰了 $n$ 顆有編號的六面骰，總和是 $m$ 點。請問可能的骰子點數組合有幾種?由於答案可能太大，請輸出答案除以 $998244353$ 的餘數。\n輸入第一行有一個正整數 $T$ ，代表測資的數量。接下來 $T$ 行每行有一筆測資，包含兩個正整數 $n, m$ ，代表骰子個數和總點數。\n\n- $1 \\le T \\le 500$\n- $1 \\le n \\le 500$\n- $n \\le m \\le 6n$\n\n其中對於 $20\\%$ 的測資，輸入保證 $n\\le 5$。\n\n對於每一筆測資輸出一行，包含一個整數，代表可能的排列數量除以 $998244353$ 的餘數。\n",
    "output": "/*input\n9\n1 2 3 4 5 6 7 8 9\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 505;\nconst long long MOD=998244353;\nlong long dp[N][6 * N + 10];\n\nint main(){\n\tdp[0][0] = 1;\n\tfor(int i = 1; i < N; i++) for(int j = i; j <= 6 * i; j++){\n\t\tdp[i][j] = 0;\n\t\tfor(int t = 1; t <= 6; t++){\n\t\t\tif(j - t >= i - 1 && j - t <= 6 * (i - 1)){\n\t\t\t\tdp[i][j] += dp[i-1][j-t];\n\t\t\t\tif(dp[i][j] >= MOD) dp[i][j] -= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tint T;\n\tcin>>T;\n\twhile(T--){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tcout<<dp[n][m]<<'\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "id": "enumerate04",
    "instruction": "給定正整數 $K$ ，請找出所有正整數對 $(a,b)$ 滿足 $a \\le b$ 且 $\\frac{1}{a} + \\frac{1}{b} = \\frac{1}{K}$ 。\n輸入有一行，包含一個正整數 $K$。\n\n- $1 \\le K \\le 10^6$\n\n對於每一個可能的 $(a, b)$ 輸出一行，這一行有兩個用空格分隔正整數分別代表 $a$ 和 $b$ 。輸出的解請照 $a$ 的大小由小到大排序。\n",
    "output": "/*input\n1000000\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn=300005;\n\nvector<long long> tmp;\nvector<long long> fac;\n\nint main(){\n\tlong long k;\n\tcin>>k;\n\tfor(long long i = 1; i * i <= k; i++){\n\t\tif(k % i == 0){\n\t\t\ttmp.push_back(i);\n\t\t\tif(i * i != k) tmp.push_back(k / i);\n\t\t}\n\t}\n\tsort(tmp.begin(), tmp.end());\n\tfor(int i = 0; i < tmp.size(); i++){\n\t\tfor(int j = i; j < tmp.size(); j++){\n\t\t\tif(tmp[i] * tmp[j] > k) break;\n\t\t\tfac.push_back(tmp[i] * tmp[j]);\n\t\t}\n\t}\n\tsort(fac.begin(), fac.end());\n\tfac.resize(unique(fac.begin(), fac.end()) - fac.begin());\n\n\tfor(long long i : fac){\n\t\tcout<< k + i << ' ' << k + k * k / i << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "id": "enumerate05",
    "instruction": "你知道數獨嗎？數獨是一個填數字的遊戲。遊戲會給你一個 $9\\times 9$ 的方陣，其中這個方陣會被切分成 $9$ 個 $3\\times 3$ 的子方陣。數獨中的 $9\\times 9=81$ 個格子中有的有填數字，有的是空白。範例如下圖：\n\n![](https://i.imgur.com/tDSgm0q.png)\n\n數獨的規則是這樣的，你不能動已經填有數字的格字；對於所有空白的格子，你必須要填上 $1\\sim 9$ 其中一個數字，使得**每一列、每一列、每一個子方陣**中都不能有重複的數字。\n\n現在給你一個數獨，你的任務是寫一個程式來完成這個數獨。\n\n輸入只有一行，包含 $81$ 個字元；這些字元可能是 $1\\sim 9$，代表這格已經填上數字，或者是 `.` ，代表這格還沒填上數字。這 $81$ 的字元的第 $0\\sim 8$ 的字元對應到數獨的第一列、$9\\sim 18$ 的字元對應到數獨的第二列、以此類推。我們保證未填上數字的格字不超過 $15$ 個。\n請輸出一行代表數獨完成後的結果，格式和輸入格式一樣。若存在多組解的話，請輸出字典序最小的解（字典序的定義請參考[這裡](https://zh.wikipedia.org/zh-tw/%E5%AD%97%E5%85%B8%E5%BA%8F)）。若無解的話，請輸出 `No solution.`。\n\n",
    "output": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring a, b;\n\nbool legal() {\n    int cnt[10] = {0};\n    \n    // 檢查每一行\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (a[9 * i + j] != '.') cnt[a[9 * i + j] - '0']++;\n        }\n        \n        for (int j = 1; j <= 9; j++) {\n            if (cnt[j] > 1) return 0;\n            cnt[j] = 0;\n        }\n    }\n    \n    // 檢查每一列\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (a[i + 9 * j] != '.') cnt[a[i + 9 * j] - '0'] ++;\n        }\n        \n        for (int j = 1; j <= 9; j++) {\n            if (cnt[j] > 1) return 0;\n            cnt[j] = 0;\n        }\n    }\n    \n    // 檢查每一個 3x3 小方陣\n    for (int i = 0; i < 9; i += 3) {\n        for (int j = 0; j < 9; j += 3) {\n            for (int k = 0; k < 3; k++)\n                for (int l = 0; l < 3; l++)\n                    if (a[9 * (i + k) + (j + l)] != '.') cnt[a[9 * (i + k) + (j + l)] - '0'] ++;\n            \n            for (int k = 1; k <= 9; k++) {\n                if (cnt[k] > 1) return 0;\n                cnt[k] = 0;\n            }\n        }\n    }\n    \n    return 1;\n}\n\nbool guess(int n) {\n\t// 如果 n >= 81，代表所有的空白都被填滿了\n\tif (n >= 81) return 1;\n\n\t// 找到 n 後面第一個 '.' 的位置\n    int next = 81;\n    for (int i = n + 1; i < 81; i++) {\n        if (a[i] == '.') {\n            next = i;\n            break;\n        }\n    }\n\n    // 在第 n 格試試看 1 ~ 9\n    for (int i = 1; i <= 9; i++) {\n        a[n] = i + '0';\n        // 如果目前已經填的都合法，而且剩下的格子也填成功，就回傳 true\n        if (legal() && guess(next)) {\n            b[n] = i + '0';\n            return true;\n        }\n        a[n] = '.';\n    }\n        \n    return false;\n}\n\nint main() {\n\tcin >> a; b = a;\n\n\tint next = 81;\n\tfor (int i = 0; i < 81; i++) {\n\t\tif (a[i] == '.') {\n\t\t\tnext = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (legal() && guess(next)) cout << b << '\\n';\n\telse cout << \"No solution.\\n\";\n}"
  },
  {
    "id": "enumerate06",
    "instruction": "在一個 $N \\times N$ 的西洋棋棋盤上有 $N$ 個皇后，每個皇后都佔據一個格子而攻擊範圍同標準西洋棋規則，國王希望他們互相不能攻擊，請列出所有可能的皇后擺放位置。\n\n皇后攻擊範圍如下：\n\n<img src=\"https://i.imgur.com/TdODAqP.png\" width=\"446\" height=\"396\" />\n\n輸入只有一行，包含一個正整數 $1 \\le N \\le 12$ 代表棋盤的大小。\n輸出總共有 $(N+1)\\cdot S$ 行，其中 $S$ 是皇后擺放方式的數量。\n\n一個皇后擺放方式可以表示成一個長度 $N$ 的序列 $(A_1, A_2, \\cdots, A_N)$ ，代表第 $i$ 個橫列的皇后放在第 $A_i$ 直行。這 $S$ 個解請照序列的字典序由小到大輸出，換句話說，第一橫列的皇后放在第一直行的解會優先輸出，而第一橫列的皇后放在最後一直行的解則會最後輸出。\n\n對於每一個皇后擺放方式，輸出 $(N+1)$ 行長度為 $N$ 的字串，如果棋盤的第 $i$ 橫列第 $j$ 直行是一個皇后，則在第 $i$ 行的第 $j$ 個字元輸出 `Q`，否則輸出 `*`，最後一行則是一個空行。\n\n請注意如果沒有合法的皇后擺放方式，輸出將會是空的，另外，如果有解的話，最後一行一定是空行（所以輸出格式比較方便 :p）。\n\n",
    "output": "/*input\n12\n*/\n#include <iostream>\nusing namespace std;\n\nconst int N = 12;\nint n;\nint a[N];\n\nvoid dfs(int u){\n\tif(u == n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(a[i] == j){\n\t\t\t\t\tcout<<'Q';\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout<<'*';\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<'\\n';\n\t\t}\n\t\tcout<<'\\n';\n\t\treturn;\n\t}\n\tfor(int x = 0; x < n; x++){\n\t\ta[u] = x;\n\t\tbool flag = 1;\n\t\tfor(int i = 0; i < u; i++){\n\t\t\tif(a[i] + i == a[u] + u) flag = 0;\n\t\t\tif(a[i] == a[u]) flag = 0;\n\t\t\tif(a[i] - i == a[u] - u) flag = 0;\n\t\t}\n\t\tif(flag){\n\t\t\tdfs(u + 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin>>n;\n\tdfs(0);\n}\n"
  },
  {
    "id": "enumerate07",
    "instruction": "學姐是一個化學小天才，為了考驗她，宇宙冠軍決定給他一個英文單字，讓學姐用元素週期表的元素英文簡寫來拼出這個單字，像是 `genius` 可以由 `Ge`, `N`, `I`, `U`, `S` 組合而成，但是 `qaq` 就沒有辦法因為元素週期表裡面沒有 `Q` 也沒有 `Qa`。但是宇宙冠軍不知道一個單字能不能用元素英文簡寫組合而成，所以請你寫程式回答這個問題。\n\n**此題中的英文字母不考慮大小寫的差異**。\n\n附註：為了避免隔天有人發現新元素，這裡提供一個[元素英文的清單](https://pastebin.com/Ps848TWr)，請以這個為準。\n\n輸入有一行，包含一個大寫英文字母字串 $S$，代表題目中的英文單字。\n\n- $1 \\le |S| \\le 10$\n\n輸出只有一行。這一行只有一個字串：如果這個英文單字可以由化學元素英文簡寫組成，輸出 `YES`，否則輸出 `NO`。\n\n",
    "output": "/*input\nAAA\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> els = {\"H\",\"He\",\"Li\",\"Be\",\"B\",\"C\",\"N\",\"O\",\"F\",\"Ne\",\"Na\",\"Mg\",\"Al\",\"Si\",\"P\",\"S\",\"Cl\",\"Ar\",\"K\",\"Ca\",\"Sc\",\"Ti\",\"V\",\"Cr\",\"Mn\",\"Fe\",\"Co\",\"Ni\",\"Cu\",\"Zn\",\"Ga\",\"Ge\",\"As\",\"Se\",\"Br\",\"Kr\",\"Rb\",\"Sr\",\"Y\",\"Zr\",\"Nb\",\"Mo\",\"Tc\",\"Ru\",\"Rh\",\"Pd\",\"Ag\",\"Cd\",\"In\",\"Sn\",\"Sb\",\"Te\",\"I\",\"Xe\",\"Cs\",\"Ba\",\"La\",\"Ce\",\"Pr\",\"Nd\",\"Pm\",\"Sm\",\"Eu\",\"Gd\",\"Tb\",\"Dy\",\"Ho\",\"Er\",\"Tm\",\"Yb\",\"Lu\",\"Hf\",\"Ta\",\"W\",\"Re\",\"Os\",\"Ir\",\"Pt\",\"Au\",\"Hg\",\"Tl\",\"Pb\",\"Bi\",\"Po\",\"At\",\"Rn\",\"Fr\",\"Ra\",\"Ac\",\"Th\",\"Pa\",\"U\",\"Np\",\"Pu\",\"Am\",\"Cm\",\"Bk\",\"Cf\",\"Es\",\"Fm\",\"Md\",\"No\",\"Lr\",\"Rf\",\"Db\",\"Sg\",\"Bh\",\"Hs\",\"Mt\",\"Ds\",\"Rg\",\"Cn\",\"Nh\",\"Fl\",\"Mc\",\"Lv\",\"Ts\",\"Og\"};\n \nint main(){\n\tfor(int i = 0; i < els.size(); i++){\n\t\tif(els[i].size() == 2){\n\t\t\tels[i][1] = char(toupper(els[i][1]));\n\t\t}\n\t}\n\n\tstring s;\n\tcin>>s;\n\tbool dp[15] = {1};\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(!dp[i]) continue;\n\t\tfor(string t : els){\n\t\t\tif(t.size() + i > s.size()) continue;\n\t\t\tif(s.substr(i, t.size()) == t)\n\t\t\t\tdp[i + t.size()] = 1;\n\t\t}\n\t}\n\tcout<<((dp[s.size()]) ? \"YES\\n\" : \"NO\\n\");\n\treturn 0;\n}\n"
  },
  {
    "id": "enumerate08",
    "instruction": "學姊給了你 $N$ 張紙條，每個紙條裡面有一個正整數，你不知道這些紙條的意思，所以想找出這 $N$ 個正整數的所有可能排列，看看有沒有隱藏的訊息，請把所有排列 **依照字典序大小** 由小到大列出來，並且不能印出重複的排列。（也就是對於 $i < j$ 都存在正整數 $k$，使第 $i$ 個排列與第 $j$ 個排列的前 $k - 1$ 項都相同，且第 $i$ 個排列的第 $k$ 項比第 $j$ 個排列的第 $k$ 項小）\n\n輸入有兩行，第一行有一個整數 $N$ 代表紙條的數量，第二行則有 $N$ 個正整數 $A_1, A_2, \\cdots, A_N$ 代表每個紙條裡的正整數。\n\n- $1 \\le N \\le 9$\n- $1 \\le A_i \\le 10^{9},\\forall 1\\le i \\le N$\n\n 令 $S$ 為可能的排列數量。 輸出有 $S$ 行，每一行有 $N$ 個以空格分隔的整數，代表一個可能的排列。\n\n **請依照字典序大小輸出**。\n",
    "output": "/*input\n9\n1 2 3 4 5 6 7 8 9\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 9;\nint a[N];\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++) cin>>a[i];\n\n\tsort(a, a + n);\n\n\tdo{\n\t\tfor(int i = 0; i < n; i++) cout<<a[i]<<\" \\n\"[i==n-1];\n\t}while(next_permutation(a, a + n));\n\n\treturn 0;\n}\n"
  },
  {
    "id": "enumerate09",
    "instruction": "有一耐重為 $M$ 的背包和 $N$ 個物品，第 $i$ （$1 \\le i \\le N$）個物品有其重量 $W$ 和價值 $P$，你可以任意選擇一些物品裝填，每個物品最多只能被裝一次。\n\n請問在重量總和不超過耐重的情況下，所能達到最大價值總和為何？\n\n輸入第一行是兩個空白分割的整數 $M, N$，分別代表背包限重和物品數量。\n\n接下來有 $N$ 行兩個以空白分割的整數 $W, P$，分別代表物品重量和物品價值。\n\n輸入保證 $1\\le N\\le 20$，$1\\le M, W, P\\le 10^8$。\n\n輸出一行一個整數代表背包最大可裝下的物品價值。\n\n",
    "output": "#include <iostream>\nusing namespace std;\nint w[22], p[22];\nint main() {\n    int M, N;\n    cin >> M >> N;\n    for(int i = 0; i < N; i++) {\n        cin >> w[i] >> p[i];\n    }\n    int ans = 0;\n    for(int i = 0; i < (1<<N); i++) {\n        int total_weight = 0, total_price = 0;\n        for(int j = 0; j < N; j++) {\n            if(i&(1<<j)) {\n                total_weight += w[j];\n                total_price += p[j];\n            }\n        }\n        if(total_weight <= M) ans = max(ans, total_price);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "id": "enumerate10",
    "instruction": "學姐最喜歡的數字有 $n$ 個，分別是 $A_1, A_2, ...,A_n$，她在買樂透的時候需要從她喜歡的數字中挑出 $k$ 個數字來買樂透，請告訴她所有的可能的號碼組合吧！\n\n輸入第一行有一個正整數 $T$，代表測資數量，每一筆測資有兩行，第一行有兩個正整數代表題目中的 $n$ 和 $k$，第二行則有 $n$ 個正整數代表學姐喜歡的數字。\n\n- $1 \\le T \\le 100$\n- $1 \\le n \\le 13$\n- $1 \\le k \\le n$\n- $1 \\le A_i \\le 10^9$\n\n$A_i$ 可能有重複數字，若遇到重複數字需要輸出多次組合。例如若給定的數字為 $1,1,2,3$ 且 $k=3$，則需要輸出兩次 $1,2,3$。\n\n對於每一筆測資，輸出所有可能的組合。每一個組合佔一行，包含 $k$ 個用空白分隔的正整數，組合必須由小到大排序。\n兩筆測資之間不需用空行分隔。\n\n",
    "output": "/*input\n1\n1\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n,k;\nint a[15];\nvector<int> ans;\n\nvoid dfs(int u){\n\tif(ans.size() == k){\n\t\tfor(int i = 0; i < k; i++) cout<<ans[i]<<\" \\n\"[i == k - 1];\n\t\treturn;\n\t}\n\tif(u == n) return;\n\tans.push_back(a[u]);\n\tdfs(u + 1);\n\tans.pop_back();\n\tdfs(u + 1);\n}\n\nvoid solve(){\n\tcin>>n>>k;\n\tfor(int i = 0; i < n; i++) cin>>a[i];\n\tsort(a, a + n);\n\tdfs(0);\n}\n\nint main(){\n\tint T;\n\tcin>>T;\n\twhile(T--) solve();\n\treturn 0;\n}\n"
  },
  {
    "id": "enumerate11",
    "instruction": "有一個推銷員要推銷他的百科全書，因此要走訪 $N$ 座城市後回家。這 $N$ 座城市之間有 $M$ 條雙向鐵路相連，其中連接 $u_i, v_i$ 的鐵路路程為 $w_i$。推銷員需要選擇任意一座城市作為出發地，並且不重複的經過所有城市恰一次，最後回到出發點。請回答推銷員所需經過的最短旅程長度。\n\n輸入第一行是兩個以空白分隔的整數 $N, M$，分別代表城市和鐵路數量。\n\n接下來有 $M$ 行，每行有三個以空白分隔的整數 $u,v,w$，分別代表鐵路連接的兩個城市和距離。\n\n輸入保證 $3\\le N\\le 10$，$3\\le M \\le \\frac{N(N-1)}2$，$1\\le u,v\\le N$，$1\\le w\\le 10^6$。\n且沒有兩條鐵路有相同的起終點，也沒有一條連接兩個相同城市的鐵路。\n\n輸出一行一個整數，表示最短旅行距離。如果不存在一條路徑可以完成，請輸出 $-1$。\n\n",
    "output": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<pair<int,int> > e[12];\nint vis[12], ans, path_length, depth;\nint N, M, st;\nvoid dfs(int x) {\n    if(depth == N-1) {\n        int back = -1;\n        for(auto k:e[x]) {\n            if(k.first == st) back = k.second;\n        }\n        if(back == -1) return;\n        ans = min(ans, path_length + back);\n        return;\n    }\n    depth++;\n    vis[x] = 1;\n    for(auto k:e[x]) {\n        if(!vis[k.first]) {\n            path_length += k.second;\n            dfs(k.first);\n            path_length -= k.second;\n        }\n    }\n    depth--;\n    vis[x] = 0;\n}\nint main() {\n    // Read Input\n    cin >> N >> M;\n    for(int i = 0; i < M; i++) {\n        int u,v,w;\n        cin >> u >> v >> w;\n        e[u].push_back({v,w});\n        e[v].push_back({u,w});\n    }\n    // Enumerate paths\n    ans = 1e9;\n    depth = 0;\n    for(int i = 1; i <= N; i++) {\n        for(int j = 1; j <= N; j++)\n            vis[j] = 0;\n        depth = path_length = 0;\n        st = i;\n        dfs(i);\n    }\n    if(ans == 1000000000) ans = -1;\n    cout << ans << endl;\n}\n"
  },
  {
    "id": "enumerate12",
    "instruction": "身為考古學家的你，拿到了一份上古年代的黑白文件，為了方便閱讀，你必須先對這份文件進行修復，修復的考慮如下：\n1. 修復後的文件需盡量與原本相同\n2. 為了閱讀的美觀，相鄰位置的顏色需盡量相同\n\n綜合上述，你可以定義出修復後的文件成本如下：\n1. 若某個位置修復後的顏色與原本不同，這個位置的成本為 $2$\n2. 若某組相鄰位置的顏色不同（相鄰的定義為有共邊即上下左右），則這組相鄰位置的成本為 $1$\n\n舉例而言：\n\n若一份\n\n```\n0 0 1\n0 0 1\n0 1 1\n```\n\n的文件被修復為\n\n```\n0 0 1\n0 0 1\n0 0 1\n```\n\n則此次修復成本為 $2\\cdot1+1\\cdot3=5$。\n請注意，這個修復為用來解釋成本計算，不一定代表這份文件的最佳解。\n\n輸入第一行有兩個正整數 $N,M(1 \\leq N\\cdot M \\leq 20)$。\n之後有 $N$ 行，每行有 $M$ 個 $0$ 或 $1$ 的數字用來描述原本的文件。\n請輸出一個整數，代表修復這份文件的最小成本。\n",
    "output": "#include <iostream>\nusing namespace std;\nint origin_board[25][25];\nint new_board[25][25];\nint N,M,ans=2e9;\nvoid solve(int x,int y)\n{\n    int t=0,i,j;\n    if(x==N)\n    {\n        for(i=0;i<N;i++)\n        {\n            for(j=0;j<M;j++)\n            {\n                if(new_board[i][j]!=origin_board[i][j]) t+=2;\n                if(i&&new_board[i][j]!=new_board[i-1][j]) t++;\n                if(j&&new_board[i][j]!=new_board[i][j-1]) t++;\n            }\n        }\n        ans=min(ans,t);\n    }\n    else\n    {\n        new_board[x][y]=0;\n        if(y==M-1) solve(x+1,0);\n        else solve(x,y+1);\n\n        new_board[x][y]=1;\n        if(y==M-1) solve(x+1,0);\n        else solve(x,y+1);\n    }\n}\nint main()\n{\n    int i,j;\n    cin >> N >> M;\n    for(i=0;i<N;i++) for(j=0;j<M;j++) cin >> origin_board[i][j];\n    solve(0,0);\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "id": "enumerate13",
    "instruction": "在一塊 $N\\times N$ 的土地上，有些格子上有雜草。一個偷懶的園丁想要方便的除草，他發現一台直直開過的除草機可以將一整行或一整列的雜草消除，然而除草機不能斜著開。想請問你在給定雜草的位置下，最少要發動幾次除草機才能把雜草清光？\n\n輸入第一行是一個正整數 $N$，表示土地大小。\n接著有 $N$ 行，第 $i$ 行有 $N$ 個空白分隔的數字 $a_{ij} (1\\le i, j\\le N)$，當 $a_{ij} = 1$ 時表示第 $i$ 列第 $j$ 行的位置有雜草，當 $a_{ij} = 0$ 時表示上述位置沒有雜草。\n\n輸入保證 $1\\le N\\le 20$，$0\\le a_{ij}\\le 1$。\n其中對於 $40\\%$ 的測資，額外保證 $1\\le N\\le 10$。\n\n本題必須輸出最少次數並給出一個例子。\n\n第一行輸出一個正整數 $m$ 表示最少發動除草機次數。\n第二行輸出 $N$ 個 $0$ 或 $1$ 的數字，數字間以空白分隔，第 $i$ 個數字是 $1$ 表示第 $i$ 列要發動除草機，$0$ 表示不發動除草機。\n第三行輸出 $N$ 個 $0$ 或 $1$ 的數字，數字間以空白分隔，第 $i$ 個數字是 $1$ 表示第 $i$ 行要發動除草機，$0$ 表示不發動除草機。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nint a[22][22];\nint main() {\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            cin >> a[i][j];\n    int ans = 100;\n    vector<int> rowans, colans;\n    for(int i = 0; i < (1<<N); i++) {\n        vector<int> row, col;\n        row.resize(N);\n        col.resize(N);\n        for(int j = 0; j < N; j++) {\n            if(i&(1<<j)) row[j] = 1;\n            else {\n                for(int k = 0; k < N; k++) {\n                    if(a[j][k]) col[k] = 1;\n                }\n            }\n        }\n        int sum = 0;\n        for(int j = 0; j < N; j++) {\n            sum += row[j] + col[j];\n        }\n        if(sum < ans) {\n            ans = sum;\n            rowans = row;\n            colans = col;\n        }\n    }\n    cout << ans << endl;\n    for(auto x: rowans) cout << x << \" \"; cout << endl;\n    for(auto x: colans) cout << x << \" \"; cout << endl;\n}\n"
  },
  {
    "id": "enumerate14",
    "instruction": "一場拔河比賽每隊有 $N$ 人，現在全班有 $2N$ 個人要進行練習賽。教練紀錄了編號 $i$ 的人和編號 $j$ 的人有對戰欲望 $a_{ij}(1\\le i, j\\le 2N)$，而分組後的團隊對戰欲則是所有分屬兩隊的人彼此對戰欲的加總。舉例而言，如果拔河比賽只有四人，分成 $1,2$ 和 $3,4$ 兩隊，且 $a_{13} = 4, a_{23} = 5, a_{14} = 6, a_{24} = 7$，那團隊對戰欲就是 $22$。\n\n教練想要安排一種方法把大家分成兩隊每隊 $N$ 人，使得團隊對戰欲最強，請問你這個團隊對戰欲是多少。\n\n輸入第一行是正整數 $N$，代表每隊人數。\n接著 $2N$ 行是 $2N$ 個空白分隔的整數，代表題目敘述中的 $a_{ij}(1\\le i, j\\le 2N)$。\n\n輸入保證 $1\\le N\\le 14$，$1\\le a_{ij}\\le 10^9$，且 $a_{ij} = a_{ji}$ 和 $a_{ii} = 0$。\n\n輸出一行一個整數代表在適當分配下，最強團隊對戰欲。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[28][28];\nint u[28], v[28], n;\nlong long ans = 0, sum = 0;\nvoid dfs(int x, int y) {\n    if(x == n && y == n) {\n        ans = max(ans, sum);\n        return;\n    }\n    if(x < n) {\n        long long s = 0;\n        for(int i = 0; i < y; i++) {\n            s += a[x+y][v[i]];\n        }\n        sum += s;\n        u[x] = x+y;\n        dfs(x+1, y);\n        sum -= s;\n    }\n    if(y < n) {\n        long long s = 0;\n        for(int i = 0; i < x; i++) {\n            s += a[x+y][u[i]];\n        }\n        sum += s;\n        v[y] = x+y;\n        dfs(x, y+1);\n        sum -= s;\n    }\n}\nint main() {\n    cin >> n;\n    for(int i = 0; i < n*2; i++) {\n        for(int j = 0; j < n*2; j++)\n            cin >> a[i][j];\n    }\n    //set 0 to be the first group can reduce the time by 50%\n    u[0] = 0;\n    dfs(1, 0);\n    //dfs(0,0);\n    cout << ans << endl;\n}\n"
  },
  {
    "id": "enumerate15",
    "instruction": "本題為一道互動題。在這個問題中，你需要和評測系統進行互動，一開始電腦會產生一個介於 $1$ 至 $1000000$ 的正整數 $N$，你的目標是猜出這個正整數，你每次可以詢問評測系統一個正整數 $Q$，評測系統將會告訴你 $Q$「大於」$N$，或者 $Q$「不大於」$N$。最後你需要正確回答出 $N$ 的值。\n\n以下是一些可以幫助到你的函式，首先請在你的程式碼第一行引入標頭檔 `enumerate15.h`，就可以使用以下的函式：\n\n- `void Init()`：請在程式的一開始呼叫，評測系統會決定正整數 $N$。\n- `int Query(int Q)`：每次呼叫可以猜測一個數字 $Q$。如果回傳 $0$ 就代表 $Q$ 比正確答案大，如果回傳 $1$ 則代表 $Q$ 不比正確答案大。注意本函式只能呼叫 $25$ 次，如果超過，系統會自動結束你的程式並將你的提交視為錯誤。\n- `void Answer(int K)`：請呼叫此函數將你認為的正確答案 $K$ 回傳給評測系統，在呼叫此函式後，系統會自動結束你的程式。\n\n\n本題沒有輸入，隨意輸入將會得到不可預期的結果。\n\n本題沒有輸出，隨意輸出將會得到不可預期的結果。\n\n",
    "output": "#include \"enumerate15.h\"\n// #include <bits/stdc++.h>\n// using namespace std;\n\nint main() {\n  // ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int l = 1, r = 1000001;\n  Init();\n  while(r - l > 1) {\n    int m = (l + r) >> 1;\n    int res = Query(m);\n    if(res == 1) l = m;\n    else r = m;\n  }\n  Answer(l);\n  return 0;\n}\n"
  },
  {
    "id": "enumerate16",
    "instruction": "老師給全班 $N$ 人出了一題隨堂練習，答案是一個正整數。這個問題的解答一共有 $Q$ 個可能的答案，$N$ 位學生排成一列依序告知老師他們的答案，最先向老師說出正確答案的學生就會獲得一份神秘小禮物，而老師想知道最先答對的學生是誰以及有多少人答對，請你寫一個程式解決這個問題。\n\n輸入第一行是兩個空白分隔的整數 $N,Q$，代表學生人數和可能的答案數量。\n第二行是 $N$ 個整數 $a_1, a_2,\\dots, a_N$，$a_i$ 代表第 $i$ 個學生的回答。\n第三行是 $Q$ 個整數 $b_1, b_2,\\dots, b_Q$，代表 $Q$ 個可能的答案。\n\n輸入保證 $1\\le N, Q\\le 3\\times 10^5$，$1\\le a_i, b_i\\le 10^9$，且每個可能的答案都有某個學生回答到。\n\n請一共輸出 $Q$ 行，對於第 $i$ 行，請輸出兩個整數並以空白分隔。第一個整數表示答案是 $b_i$ 的話第幾位學生會首先回答正確答案，第二個整數表示有多少人答對。如果沒有學生答對則第一個整數輸出 $-1$。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\npair<int,int> a[1000000];\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    for(int i = 1; i <= N; i++) {\n        cin >> a[i].first;\n        a[i].second = i;\n    }\n    sort(a+1, a+N+1);\n    while(Q--) {\n        int x;\n        cin >> x;\n\t    int first_id = lower_bound(a+1, a+N+1, make_pair(x, 0)) -> second;\n\t    int num_correct = lower_bound(a+1, a+N+1, make_pair(x+1, 0)) - lower_bound(a+1, a+N+1, make_pair(x,0));\n    \tif(num_correct == 0) first_id = -1;\n        cout << first_id << \" \" << num_correct << endl;\n    }\n}\n"
  },
  {
    "id": "enumerate17",
    "instruction": "為因應資訊化與數據化的發展趨勢，某市長想要在城市的一些服務據點上提供無線網路服務，因此他委託電信公司架設無線基地台。某電信公司負責其中 $N$ 個服務點，這 $N$ 個服務點位在一條筆直的大道上，它們的位置（座標）係以與該大道一端的距離 $P[i]$ 來表示，其中 $i = 0 \\sim N - 1$。由於設備訂製與維護的因素，每個基地台的服務範圍必須相同，當基地台架設後，與此基地台距離不超過 $R$（稱為基地台的半徑）的服務點都可以使用無線服務網路。也就是說每一個基地台可以服務的範圍是 $D = 2R$（稱為基地台的直徑）。現在電信公司想計算，如果要架設 $K$ 個基地台，那麼基地台的最小直徑是多少才能使每個服務點都可以得到服務。\n基地台的架設不一定要在服務點上，最佳的架設方式也不一定唯一，但本題只需要求最小直徑即可。以下是 $N = 5$ 的一個例子，五個服務點的座標分別是 $1, 2, 5, 7, 8$。\n![](https://i.imgur.com/eJWy059.png)\n假設 $K = 1$，最小的直徑是 $7$，基地台架設在座標 $4.5$ 的位置，所有點與基地台的距離都在半徑 $3.5$ 以內。假設 $K = 2$，最小的直徑是 $3$，一個基地台服務座標 $1$ 與 $2$ 的點，另一個基地台服務另外三個點。在 $K = 3$ 時，直徑只要 $1$ 就足夠了。\n\n輸入有兩行。第一行是兩個正整數 $N$ 與 $K$，以一個空白間隔。第二行 $N$ 個非負整數 $P_0, P_1, P_2, \\ldots, P_{N-1}$ 表示 $N$ 個服務點的位置，這些位置彼此之間以一個空白間隔。\n請注意，這 $N$ 個位置並不保證相異也未經過排序。本題中 $1 \\leq K < N \\leq 10^5$ 且所有座標都是 $0$ 到 $10^9$ 的整數，因此，所求最小直徑必然是非負整數。\n\n輸出最小直徑，不要有任何多餘的字或空白並以換行結尾。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint Cal(int x, vector<int> const &a, const int &n){\n  int cnt = 1;\n  for(int i = 0, first = 0; i < n; i++) {\n    if(a[i] - a[first] > x) cnt++, first = i;\n  }\n  return cnt;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); \n  cin.tie(nullptr);\n  \n  int n, k; \n  cin >> n >> k;\n  vector<int> a(n);\n  for(int i = 0; i < n; i++) cin >> a[i];\n  sort(a.begin(), a.end());\n\n  int l = -1, r = int(1e9);\n  while(r - l > 1) {\n    int m = (l + r) >> 1;\n    if(Cal(m, a, n) <= k) r = m;\n    else l = m;\n  }\n  cout << r << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "enumerate18",
    "instruction": "南宋年間，蒙古大軍自北方入侵中原，烽火四起，百姓生靈塗炭、苦不堪言。南宋趙氏朝廷退至臨安，坐守南方膏腴之地。其中，襄陽城堪稱通往南方的咽喉。現在，蒙古兵臨城下，干戈四起，守城將領已經做好準備了，而你則是負責運送砲彈的小兵。\n\n\n已知襄陽城的城牆上有 $N$ 個哨站，編號為 $0$ 至 $N - 1$，呈環狀排列，且對於所有的 $0 \\le i < N$，編號 $i$ 的哨站有一條單行道通往編號 $(i + 1) \\mod N$ 的哨站。每一個哨站有各自對於砲彈的需求量，一個正整數 $p_i$ 代表第 $i$ 個哨站需要 $p_i$ 石的砲彈。而一旦你經過了一個哨站，你就會恰將 $p_i$ 石的砲彈給那個哨站。一開始你在編號為 $0$ 的哨站，而你將收到 $M$ 個型如「請送出至少 $q_i$ 個砲彈」的任務。也就是說，你會從現在這個哨站開始送砲彈，然後走到下一個哨站繼續送，直到送出的砲彈數量達到 $q_i$ 個為止。如果你從編號為 $s$ 的哨站開始，送到編號 $t$ 的哨站剛好送出足夠的砲彈的話，則你會停在編號為 $(t + 1) \\mod N$ 的哨站，才算任務完成（$0 \\le s, t < N$）。\n\n給定以上的資訊，請問你最後會停在哪個哨站？\n\n輸入將有 $3$ 行。第一行包含兩個正整數 $N, M(1 \\leq N \\le 200000, 1 \\le M \\le 20000)$。第二行將包含 $N$ 個正整數，第 $i$ 個數字代表 $p_{i - 1}(\\sum_{i = 0}^{N - 1} p_i \\leq 10^{9})$。最後一行將有 $M$ 個正整數，其中第 $j$ 個代表 $q_j(q_j \\leq \\sum_{i = 0}^{N - 1} p_i)$。\n\n此外，對於佔分 $20\\%$ 的測試資料，還額外滿足 $1 \\le N, M \\le 100$。\n\n請輸出一個數字 $k$，代表最後你會停在哪一個哨站。\n",
    "output": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#define ericxiao ios_base::sync_with_stdio(0);cin.tie(0);\nusing namespace std;\n\nconst int maxN = 4e5 + 326;\nint N, M, p[maxN], q, x = 0;\n\n//Bugs that might be there:\n//  - using lower_bound and upper bound - Make sure to have some that equal the sum\n//  - brute force walks - have one where you have to loop everytime?\n//  - forgetting to +1? Random can fix\n\nsigned main(){\n    ericxiao;\n    cin >> N >> M;\n    for(int i = 0; i < N; i++){\n        cin >> p[i];\n        p[i + N] = p[i];\n    }\n    for(int i = 1; i < 2 * N; i++) p[i] += p[i - 1];\n    while(M--){\n       cin >> q; \n       x = ((lower_bound(p, p + 2 * N, q + (x ? p[x - 1] : 0)) - p) + 1) % N; //lol code golf\n    }\n    cout << x << endl;\n}\n\n\n"
  },
  {
    "id": "enumerate19",
    "instruction": "有個與數獨很類似的遊戲稱為「乘法獨」，其遊戲規則為：給定三個由英文字母大寫與數字組合成的字串 $s_1,s_2,s_3$ 作為題目，玩家要在大寫英文字母的位置填入數字 $k_i$（$1\\le k_i \\le 9$），同一種英文字母要填入相同的數字，但不同的英文字母可以填入相同的數字。將每個英文字母都取代成數字後，字串會轉換成數字 $x_1,x_2,x_3$（為了讓乘法獨簡單一些，$x_1,x_2$ 的位數和不會超過 $8$），若可以找到一種取代方式使得 $x_1 \\times x_2=x_3$，則玩家就成功解出乘法獨。\n\n現在，請你撰寫一個程式以解出乘法獨。\n\n輸入共有三行，每行會有一個只包含大寫英文字與數字 $0\\sim9$ 的字串，依序代表 $s_1,s_2,s_3$ 。\n\n請以 `x1 x x2 = x3` 的格式輸出乘法獨的答案，格式詳見範例測資。若有多組解，請輸出任意一組解即可。\n\n",
    "output": "#include<bits/stdc++.h>\nusing namespace std;\n#define x first\n#define y second\n#define isChar(c) ('A'<=c&&c<='Z')\n\nstring s1, s2, s3;\n\nint trans(string &s, vector<int> &cti) {\n    int ans = 0;\n    for (int i = 0; i < (int)s.length(); i++) {\n        if (isChar(s[i]))\n            ans = ans * 10 + cti[s[i]-'A'];\n        else\n            ans = ans * 10 + s[i]-'0';\n    }\n    return ans;\n}\n\nbool sol(vector<char> &cs, int j, vector<int> &cti) {\n    if (j == cs.end()-cs.begin()) {\n        int x1 = trans(s1, cti), x2 = trans(s2, cti), x3 = trans(s3, cti);\n        // cout << s1 << ' ' << s2 << ' ' << s3 << ' ';\n        // for (auto ccc: cti) cout << ccc << ' ';\n        // printf(\"%d %d %d\\n\", x1, x2, x3);\n        if (x1 * x2 == x3) {\n            for (auto c:s1) {\n                if (isChar(c))\n                    cout << cti[c-'A'];\n                else\n                    cout << c;\n            }\n            cout << \" x \";\n            for (auto c:s2) {\n                if (isChar(c))\n                    cout << cti[c-'A'];\n                else\n                    cout << c;\n            }\n            cout << \" = \";\n            for (auto c:s3) {\n                if (isChar(c))\n                    cout << cti[c-'A'];\n                else\n                    cout << c;\n            }\n            return true;\n        }\n        return false;\n    }\n    for (int i = 1; i <=9; i++) {\n        cti[cs[j]-'A'] = i;\n        if(sol(cs, j+1, cti))\n            return true;\n    }\n    return false;\n}\n\nint main() {\n    cin >> s1 >> s2 >> s3;\n    vector<char> cs;\n    vector<int> appear(26, 0), cti(26, 0);\n    for (auto c:s1+s2+s3) {\n        if ('A' <= c && c <= 'Z' && !appear[c-'A']) {\n            appear[c-'A'] = 1;\n            cs.push_back(c);\n        }\n    }\n    sol(cs, 0, cti);\n    return 0;\n}"
  },
  {
    "id": "enumerate20",
    "instruction": "學姐最近去遊樂園坐摩天輪，她拿著一張她坐摩天輪的照片跟你說：「我記得當時跟摩天輪最高點的海拔高度差距是 $H$ 公尺，然後跟最高點的水平差距是 $L$ 公尺。」已知拍照時，學姐在摩天輪的上半部（沒有人會在下半部就拍照的> <）。聰明的你能告訴她摩天輪的半徑嗎？\n\n輸入只有一行，包含兩個正整數 $H,L$，分別代表和最高點的高度差和水平距離。\n\n- $1 \\le H < L \\le 10^{6}$\n\n輸出一個浮點數，代表摩天輪的半徑。請四捨五入到小數第五位（推薦使用 ```std::setprecision``` ）。\n",
    "output": "/*input\n12 15\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tdouble h, l;\n\tcin>>h>>l;\n\tcout<<fixed<<setprecision(5)<<(l * l - h * h) / (2 * h) + h <<'\\n';\n}\n"
  },
  {
    "id": "enumerate21",
    "instruction": "> 齊使者如梁，孫臏以刑徒陰見，說齊使。齊使以為奇，竊載與之齊。齊將田忌善而客待之。忌數與齊諸公子馳逐重射。孫子見其馬足不甚相遠，馬有上、中、下輩。於是孫子謂田忌曰：「君第重射，臣能令君勝。」田忌信然之，與王及諸公子逐射千金。及臨質，臏曰：「今以君之下駟與彼上駟，取君上駟與彼中駟，取君中駟與彼下駟。」既馳三輩畢，而田忌一不勝而再勝，卒得王千金。於是忌進孫子於威王。威王問兵法，遂以為師。——『史記。孫子吳起列傳第五』\n\n千年以前，孫臏靠著過人的智謀，巧妙地調整比賽順序，讓三戰皆墨的田忌翻身成兩勝一敗的贏家，也為自己贏得尊敬和重用。千年以後的今日，賽馬依然是熱門的活動，不過今天你要面對的是更困難的問題。\n\n你和對手各有 $N$ 匹馬，要進行 $N$ 場比賽。一匹馬只限出場一次，同場比賽中速度較快的馬獲勝。若兩匹馬速度一樣，則算平手。你可以決定你的馬匹的出場順序；而你的對手，就如同齊王，會在第一場比賽出速度最快的馬，第二場出次快的馬，$\\dots$，第 $N$ 場出速度最慢的馬。\n\n除此之外，你還可以決定比賽的時間，全部 $N$ 場比賽都會在你選的這一天進行。在比賽之前，勤勞的你每天都會訓練你的每一匹馬；而你的對手自我感覺非常良好，因此不會訓練他的馬。每一匹馬的素質不同，我們用 $a_i$ 來表示第 $i$ 匹馬的速度，用 $b_i$ 來表示第 $i$ 匹馬的成長率。經過 $m$ 天的訓練，你的第 $i$ 匹馬在第 $m+1$ 天的速度就會是 $a_i+m\\times b_i$。對手的第 $j$ 匹馬在每一天的速度都是 $c_j$。\n\n現在你有你和對手共 $2N$ 匹馬的資料，請決定最小的訓練天數 $M$，使得在第 $M+1$ 天比賽的時候，你有一個出場順序可以贏得 $N$ 場比賽中的至少 $K$ 場（不包含平手）。\n\n第一行有一個整數 $T$，代表接下來有幾組測試資料。\n\n每一組測試資料的第一行有兩個數字 $N$ 和 $K$。\n\n接下來 $N$ 行是你的馬匹資料，每一行有兩個整數，$a_i$ 和 $b_i$，代表馬匹的速度和成長率。\n\n再下來 $N$ 行是對手的馬匹的資料，每一行有一個整數 $c_j$，代表馬匹的速度。\n\n* $1 \\le T \\le 100$\n* $1\\le K\\le N\\le 10^4$\n* $0\\le a_i, c_j \\le 10^{8}$\n* $0\\le b_i \\le 100$\n對每筆測試資料輸出一個非負整數 $M$，代表訓練 $M$ 天後在第 $M+1$ 天舉行賽馬你可以贏得至少 $K$ 場。\n\n如果有不只一個 $M$ 滿足條件，請輸出最小的 $M$。如果沒有任何 $M$ 滿足條件，請輸出 $-1$。\n\n不同測試資料請以換行隔開。\n\n",
    "output": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nusing ll = long long;\n\nconst int N = 10000 + 5;\nll n, k, speed[N], growth[N], enemy[N], fight[N];\n\nbool ok(ll x) {\n    if (x < 0) return 0;\n\n    ll ans = 0;\n    for (int i = 0 ; i < n ; i++) fight[i] = speed[i] + x * growth[i];\n    sort(fight, fight + n);\n\n    for (int i = 0 ; i < n ; i++) {\n        if (fight[i] > enemy[ans]) ans++;\n        if (ans >= k) break;\n    }\n    \n    return ans >= k;\n}\n\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0);\n    int t; cin >> t;\n    while (t--) {\n        cin >> n >> k;\n        for (int i = 0 ; i < n ; i++) cin >> speed[i] >> growth[i];\n        for (int i = 0 ; i < n ; i++) cin >> enemy[i];\n        sort(enemy, enemy + n);\n\n        ll l = -50, r = (ll)1e17, mid = (l + r) / 2;\n        while (l + 1 < r) {\n            if (ok(mid)) {\n                r = mid;\n                mid = (l + r) / 2;\n            }\n            else{\n                l = mid;\n                mid = (l + r) / 2;\n            }\n        }\n        \n        if (r >= (ll)1e17) cout << \"-1\\n\";\n        else cout << r << '\\n';\n    }\n}"
  },
  {
    "id": "enumerate22",
    "instruction": "小風有一個數列 $a_1, a_2, \\ldots, a_N$，每一項皆落在 $[0, M - 1]$，小風想把這個序列變成遞增數列，也就是每一項皆不比前一項小，他的操作方式如下：\n\n- 選取正整數 $k$ 以及 $k$ 個下標 $1 \\leq i_1 < i_2 < \\ldots < i_k \\leq N$。\n- 將每個元素 $a_{i_j}, (1 \\leq j \\leq k)$ 變成 $( (a_{i_j} + 1)\\ \\mod M)$。\n\n小風想知道他最少需要幾次操作才能達成他的目標，請你幫幫小風。\n\n輸入第一行有兩個正整數 $N, M (1 \\leq N, M \\leq 300000)$。\n輸入第二行包含 $N$ 個整數 $a_1, a_2, \\ldots, a_N (0 \\leq a_i < M)$。\n\n請輸出一個整數，代表小風至少需要幾次操作。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int n, m; cin >> n >> m;\n  vector<int> a(n);\n  for(int i = 0; i < n; i++) cin >> a[i];\n\n  int l = -1, r = m - 1;\n  auto Check = [&](int x) {\n    int cur = -1;\n    for(int i = 0; i < n; i++) {\n      if(a[i] + x < m) {\n        if(a[i] + x < cur) return false;\n        else cur = max(a[i], cur);\n      }\n      else {\n        if((a[i] + x) % m < cur && cur < a[i]) cur = a[i];\n      }\n    }\n    return true;\n  };\n  while(r - l > 1) {\n    int mid = (l + r) >> 1;\n    if(Check(mid)) r = mid;\n    else l = mid;\n  }\n  cout << r << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "id": "enumerate23",
    "instruction": "瑪利歐除了路易吉之外，還有個弟弟：瑪利 P。瑪利 P 跟瑪利歐一樣很喜歡賽車，但是因為年紀還小所以開車一直都快不起來！有一次，小瑪利 P 又在練車場練習了，他總共繞了 $N$ 圈。而因為這是神奇的世界，所以對於第 $i$ 圈來說，它的長度都是 $d_i$，不一定都一樣。瑪利 P 每一圈都保持等速移動，且他在儀表板上面看到他的速度為 $s_i$。然而，心疼弟弟的瑪利歐知道瑪利 P 一直達不到他想要的速度，所以就暗中幫助他，在全程都幫他加速了一個神奇速度 $v$（也就是說瑪利 P 實際上的速度為 $v + s_i$）。練習完後，瑪利 P 發現自己跑完這 $N$ 圈所花的總時間為 $T$。請注意，雖然說 $d_i, s_i$ 都是整數，$v$ 可能不是。\n\n在旁邊的路易吉發現了：雖然瑪利歐有時候會搞錯而讓 $v < 0$，瑪利P在每一圈的實際速度（$s_i + v$）都是正數，不會讓瑪利 P 走倒退路。\n\n請寫一支程式來計算瑪利歐所選擇的神奇速度 $v$ 到底是多少吧！\n\n第一行會有兩個數字 $N(1 \\leq N \\leq 1000)$ 和 $T(1 \\leq T \\leq 10^6)$，分別代表瑪利 P 跑了幾圈和總花費的時間。\n接下來有 $N$ 行，每行包含兩個數字 $d_i(1 \\leq d_i \\leq 1000)$ 和 $s_i(|s_i| \\leq 1000)$，分別代表第 $i$ 圈的長度與瑪利 P 看到的速度。\n\n註：此題目中所有的長度單位都為[千香蕉](http://bananaforscale.info/#!/)，時間單位都是小時。\n\n請輸出一行一個實數 $v$，代表瑪利歐偷偷幫瑪利 P 加的速度量。你所輸出的答案和正解的相對誤差必須要小於或等於 $10^{-6}$ 才算正確。\n\n你輸出的解答 $a$ 和正解 $b$ 的相對誤差定義為 $\\min(|a - b|, \\frac{|a - b|}{|b|})$。\n\n",
    "output": "#include <iostream>\n#include <iomanip>\n#define double long double\n#define ericxiao ios_base::sync_with_stdio(0);cin.tie(0);\nusing namespace std;\n\nconst int maxN = 1e3 + 326, INF = 2e9;\nint N;\ndouble T, s[maxN], d[maxN];\n\ninline double Abs(double x){\n    return max(-x, x);\n}\n\ninline bool tooSmall(double m){\n    double sum = 0;\n    for(int i = 0; i < N; i++){\n        if((s[i] + m) <= 1e-6) return true;\n        sum += 1.0 * d[i] / (s[i] + m);\n        if(sum > T) return true;\n    }\n    return false;\n}\n\nint main(){\n\tericxiao\n    cin >> N >> T;\n    double minSpeed = INF;\n    for(int i = 0; i < N; i++){\n        cin >> d[i] >> s[i];\n        minSpeed = min(minSpeed, (double)s[i]);\n    }\n    double l = -minSpeed, r = INF, m;\n    for(int i = 0; i < 100; i++){\n        m = (l + r) / 2;\n        if(tooSmall(m)){\n            l = m;\n        } else r = m;\n    }\n    cout << setprecision(20) << m << endl;\n}\n"
  },
  {
    "id": "enumerate24",
    "instruction": "在西洋棋盤中，皇后可以直走也可以斜走，城堡只能直走，某皇后或城堡可以攻擊另一皇后或城堡若且唯若他可以一步到達另一子。\n\n現在有 $N$ 個皇后和 $M$ 個城堡要放入 $(N+M)\\times (N+M)$ 的棋盤，請求出有幾種方法可以使任何一子無法攻擊其他一子。\n\n輸入只有一行，包含兩個以單一空格隔開的整數 $N, M$，分別代表皇后和城堡數量。\n\n輸入保證 $0\\le N, M\\le 8$，$1\\le N+M\\le 8$。\n\n輸出一行一個整數，代表棋盤上有幾種放法。\n\n",
    "output": "#include <iostream>\nusing namespace std;\nint row[11], plu[22], mns[22];\nlong long ans = 0;\nint m,n;\n// x: rooks, y: queens\nvoid dfs(int x, int y, int dpt) {\n    if(x == 0 && y == 0) {\n        ans++;\n        return;\n    }\n    for(int i = 0; i < n+m; i++) {\n        if(row[i] > 1 || plu[dpt+i] > 1 || mns[10+dpt-i] > 1) continue;\n        if(x) {\n            row[i] = 2;\n            int tmp = plu[dpt+i], tmp2 = mns[10+dpt-i];\n            plu[dpt+i] = 1;\n            mns[10+dpt-i] = 1;\n            dfs(x-1, y, dpt+1);\n            row[i] = 0;\n            plu[dpt+i] = tmp;\n            mns[10+dpt-i] = tmp2;\n        }\n        if(y && !plu[dpt+i] && !mns[10+dpt-i]) {\n            row[i] = 2;\n            plu[dpt+i] = 2;\n            mns[10+dpt-i] = 2;\n            dfs(x, y-1, dpt+1);\n            row[i] = 0;\n            plu[dpt+i] = 0;\n            mns[10+dpt-i] = 0;\n        }\n    }\n}\nint main() {\n    cin >> m >> n;\n    dfs(n, m, 0);\n    cout << ans << endl;\n}\n"
  },
  {
    "id": "enumerate25",
    "instruction": "小意家裡養了很多鯊鯊，鯊鯊每天的伙食是非常驚人的，根據小意的計算，從今天算起的第 $i$ 天鯊鯊們會需要吃掉至少 $a_i$ 公斤的食物。\n\n市面上販售的鯊魚食品有 $n$ 種，且由於新政策的推行，每一種的鯊魚食品的價錢都是相同的，然而，每一種鯊魚食品的份量卻大不相同，其中第 $j$ 種的鯊魚食品包含了 $x_j$ 公斤的食物，而且由於鯊魚食品的種類太多了，寵物店店家每一天每一種食品的庫存都只有一份，而且跨日的鯊魚食品，鯊鯊們是不會吃的，所以當天沒吃完的食物不可以留到隔天。\n\n由於經費有限，小意希望可以花最少的錢來餵飽家裡的鯊鯊們，你可以告訴小意每天最少要買幾份鯊魚食品才可以餵飽鯊鯊嗎？\n\n輸入的第一行有一個整數 $t\\ (1\\le t\\le 1000)$ 代表測資的數量。\n\n每一筆測資的第一行有兩個整數 $n, q (1\\le n,q\\le 1.5 \\times 10^5)$ 分別代表食品種類的數量以及需要計算的天數，兩者之間以空格分隔。\n\n第二行包含 $n$ 個整數 $x_j (1\\le x_j\\le 10^4)$，代表第 $j$ 種食品的重量，每個整數之間以空白分隔。\n\n接下來的 $q$ 行中，第 $i$ 行包含一個正整數 $a_i (1\\le a_i\\le 2\\times 10^9)$，代表鯊鯊第 $i$ 天所需的食物總重。\n\n保證所有測資中的 $n$ 以及 $q$ 的和不會超過 $1.5 \\times 10^5$。\n\n對於每一筆測資的每一天，請輸出一行，包含一個整數，代表小意需要購買的最少食品數量，如果當天就算買下所有的鯊魚食品都沒辦法餵飽鯊鯊的話，請輸出 $-1$。\n\n",
    "output": "#include <bits/stdc++.h>\n#define MAX_N 150000\n\nusing namespace std;\n\nint cmp (int a, int b) {\n    return a > b;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, q;\n        cin >> n >> q;\n        int weight[MAX_N] = {};\n\n        for (int i = 0; i < n; ++i) {\n            cin >> weight[i];\n        }\n\n        sort(weight, weight + n, cmp);\n        for (int i = 1; i < n; ++i) {\n            weight[i] += weight[i - 1];\n        }\n\n        for (int i = 0; i < q; ++i) {\n            int tar = 0;\n            cin >> tar;\n            int ans =  (lower_bound(weight, weight + n, tar) - weight);\n            cout << (ans == n ? -1 : ans + 1) << '\\n';\n        }\n    }\n}\n"
  },
  {
    "id": "enumerate26",
    "instruction": "小 Q 身為一位專業的壽司師傅，能夠同時使用兩隻手各自包不同的壽司，如此特殊的才藝也替壽司店吸引了不少人潮。\n\n某天，壽司店舉辦了一場免費吃壽司的活動，並且要請小 Q 展示一下單手包壽司的技能。已知活動當天來到壽司店的第 $1$ 位客人將可以免費獲得 $1$ 個壽司、第 $2$ 位客人將可以免費獲得 $2$ 個壽司 $\\cdots$ 依此類推。但是壽司店準備的材料有限，所以小 Q 將用以下的方法捏壽司：已知當天小 Q 的左手邊準備了可以捏出 $L$ 個壽司的材料、右手邊準備了可以捏出 $R$ 個壽司的材料。當第 $i$ 個客人來時，會使用所剩材料較多的那隻手捏 $i$ 個壽司給第 $i$ 個客人。由於小 Q 是個左撇子，因此若左手右手邊的食材一樣多時，會使用左手邊的材料捏壽司給客人。若左手邊及右手邊的材料都無法再捏出 $i$ 個壽司時，第 $i$ 個客人將拿不到任何壽司，並且當日的活動會立即結束。\n\n註：左手邊及右手邊的材料不可混用，即使單邊的材料不夠也不能使用兩邊的材料組成 $i$ 個壽司。\n\n給定小 Q 左右手邊的壽司材料數 $L,R$，求當天有幾個客人可以拿到壽司？並求活動結束後左邊及右邊分別剩下幾份材料？\n\n輸入第一行包含一個整數 $T$（$1\\le T \\le 100$），接下來會有 $T$ 組測試資料。第二行以後的 $T$ 組測試資料中，每行各有兩個以空白分隔的整數 $L,R$（$0 \\le L,R \\le 10^{18}$），代表當天左右手邊準備的壽司材料數。\n\n\n輸出總共有 $T$ 行，每行有 $3$ 個以空白分隔的整數 $n, l, r$ 表示當天有拿到壽司的客人數 $n$、當天左手邊剩下的壽司材料數 $l$、以及當天右手邊剩下的壽司材料數 $r$。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long x;\n\ninline long long f1(long long i) {\n    return (i+1)*i/2;\n}\n\ninline long long f2(long long i) {\n    return x * i + i*i;\n}\n\ninline long long f3(long long i) {\n    return (x + 1) * i + i*i;\n}\n\nlong long bin_search(long long thrd, long long (*func)(long long i), long long l, long long r) {\n    // Return the maximum of i satisfying func(i) <= thrd\n    long long mid = (l+r)>>1;\n    while (r - l > 4) {\n        if (func(mid) > thrd) {\n            r = mid - 1;\n        }\n        else {\n            l = mid;\n        }\n        mid = (l+r)>>1;\n    }\n    while (func(r) > thrd) {\n        r--;\n    }\n    return r;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    long long L, R, T;\n    cin >> T;\n    for (int t = 1; t <= T; t++) {\n        cin >> L >> R;\n\n        // Phase I\n        x = bin_search(abs(L-R), f1, 0, 2000000000);\n        if (L >= R) {\n            L -= f1(x);\n        }\n        else {\n            R -= f1(x);\n        }\n\n        // Phase II\n        bool exch = R > L;\n        if (R>L)\n            swap(R, L);\n        long long x1 = bin_search(L, f2, 0, 2000000000);\n        long long x2 = bin_search(R, f3, 0, 2000000000);\n\n        if (exch)\n            cout << x + x1 + x2 << ' ' << R - f3(x2) << ' ' << L - f2(x1);\n        else\n            cout << x + x1 + x2 << ' ' << L - f2(x1) << ' ' << R - f3(x2);\n        if (t != T)\n            cout << endl;\n    }\n}"
  },
  {
    "id": "function01",
    "instruction": "有一天，小明跟小華在玩一個遊戲，他們要在球箱裡面各自抽一顆球，球上面標有數字，小明抽到是數字 $A$，小華抽到的是數字 $B$，聰明的你知道數字比較大的是什麼嗎？\n\n提示：可以 include `<algorithm>` 標頭檔，並且呼叫其中的 `std::max` 函式。\n\n輸入只有一行，包含兩個以單一空格隔開的整數 $A,B(-2^{31}\\le A,B<2^{31})$，分別代表小明和小華抽到的數字。\n\n輸出一行一個整數 $C=\\max(A,B)$，代表他們之間比較大的整數，若兩者一樣則輸出任一個整數。\n\n",
    "output": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    cout << max(a,b) << endl;\n}\n"
  },
  {
    "id": "function02",
    "instruction": "你知道三角函數嗎？你知道 C++ 裡面有幫你實作三角函數嗎？現在給你一個三角形的兩個邊 $a, b$ 和他們之間的夾角（弧度）$\\theta$，請計算這個三角形的面積。\n\n* Hint: 三角函數在 `<cmath>` 裡面\n* Hint2: 三角形面積 = $\\frac{1}{2}ab\\sin\\theta$\n輸入只有一行，包含三個用空白分隔的浮點數，分別代表三角形的兩邊長 $a, b$ 與兩邊長之間的夾角（單位是弧度）$\\theta$。\n\n* $1 \\le a, b \\le 100$\n* $0 \\lt \\theta \\lt \\pi$\n請輸出此三角形的面積到小數後第二位（hint：可以使用 `fixed` 和 `setprecision`）。\n\n",
    "output": "#include <iostream>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\nint main() {\n\tdouble edge1, edge2, deg; cin >> edge1 >> edge2 >> deg;\n\tcout << fixed << setprecision(2) << edge1 * edge2 * sin(deg) / 2 << endl;\n}\n"
  },
  {
    "id": "function03",
    "instruction": "有一天國王去世了，需要分配土地給三個王子，已經知道分割後，土地的大小分別為 $a,b,c$。有一位王子取走了最大塊的土地，另一位取走了最小塊的土地，最後那一位取走了最後剩下的土地，你能知道最後一位王子取走的土地有多大嗎也就是（$a,b,c$ 之間的中位數）？\n\n請在程式碼的第一行引入標頭檔 `function03.h`，並實作以下函數：\n\n- `int median(int a, int b, int c)`：\n  - $a, b, c$：代表分割後的土地 $a,b,c$。\n  - 此函數需回傳一個型別為 `int` 的整數代表 $a,b,c$ 中的中位數。\n\n注意！請勿在你的程式碼宣告主函式 `main()` 以及進行任何輸入輸出的動作，否則將會發生不可預期的結果。\n\n本題沒有輸入，隨意輸入將會得到不可預期的結果。\n\n本題沒有輸出，隨意輸出將會得到不可預期的結果。\n\n",
    "output": "#include \"function03.h\"\n\nint median(int a, int b, int c) {\n  if (a <= b && b <= c) return b;\n  else if (a >= b && b >= c) return b;\n  else if (b <= a && a <= c) return a;\n  else if (b >= a && a >= c) return a;\n  else return c; \n}\n"
  },
  {
    "id": "function04",
    "instruction": "小明剛學完排序後，覺得單純按照大小排序很枯燥乏味，所以就想到了另一種排序方法：\n\n> 給定了一個陣列，要將陣列內每個數取絕對值後由小而大排序，若遇到一正一反相同絕對值的兩數時，則負的值會在前面，正的值會在後面。\n\n請在程式碼的第一行引入標頭檔 `function04.h`，並實作以下函數：\n\n- `void sort_by_abs(int array[], int size)`：\n  - $array$：代表待排序的陣列。\n  - $size$：代表此陣列的大小，保證 $1\\le size\\le 100000$。\n  - 此函數會把傳入的 $array$ 做小明的排序。\n\n提示：可以使用 `std::sort` 中的 compare function。\n注意請勿在你的程式碼宣告主函式 `main()` 以及進行任何輸入輸出的動作，否則將會發生不可預期的結果。\n\n本題沒有輸入，隨意輸入將會得到不可預期的結果。\n\n本題沒有輸出，隨意輸出將會得到不可預期的結果。\n\n",
    "output": "#include \"function04.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long absl(long long a){\n  if (a < 0) return -a;\n  return a;\n}\n\nint cmpf(int a, int b) {\n  if (absl(a) == absl(b)) {\n    return a < b;\n  }\n  return absl(a) < absl(b);\n  return a < b;\n}\n\nvoid sort_by_abs (int array[], int size) {\n  sort(array, array + size, cmpf);\n  return;\n}\n"
  },
  {
    "id": "function05",
    "instruction": "選擇排序法（selection sort）是一種複雜度為 $O(n^2)$ 的排序演算法。實作方式為：從尚未排序的區間中選出最小的元素並將其加入已排序的區間。\n\n請你在程式碼開頭引用 `function05.h`，並實作此函數，將長度為 $size$ 的 $array$ 內的整數由小到大排好：\n\n- `void selection_sort(int array[], int size)`：\n  - $array$：代表待排序的陣列。\n  - $size$：代表此陣列的大小，保證 $1\\le size\\le 3000$。\n\n標頭檔內已經有 `main` 函式，因此請勿在程式碼裡面加入 `main` 函式。\n\n請勿額外讀入或寫入任何資料。\n\n請勿額外讀入或寫入任何資料。\n\n",
    "output": "#include \"function05.h\"\n\nvoid selection_sort(int array[], int size) {\n    for (int i = 0; i < size; i++) {\n        int minimum = i;\n        for (int j = i+1; j < size; j++) {\n            if (array[minimum] > array[j]) {\n                minimum = j;\n            }\n        }\n        int temp = array[minimum];\n        array[minimum] = array[i];\n        array[i] = temp;\n    }\n}"
  },
  {
    "id": "function06",
    "instruction": "指考剛剛結束，為了抽查整體高中生的數學平均實力，教育部隨機抽查了 $N(1\\le N\\le 100000)$ 位學生的數學成績，想要藉由他們的平均來評估整體學生數學能力素質，請你協助教育部進行這項調查。\n\n在本道題目中，請你在程式碼第一行引入標頭檔 `function06.h`，並請實作以下函數：\n\n- `double average(int scores[], int N)`：\n  - $scores$：一個長度為 $N$ 的陣列，$scores[i]$ 代表第 $i$ 位學生的成績，保證每位學生的成績為 $[0, 100]$ 間的整數。\n  - 此函數需回傳一個浮點數，代表這 $N$ 位學生的平均成績。\n\n注意請勿在你的程式碼宣告主函式 `main()` 以及進行任何輸入輸出的動作，否則將會發生不可預期的結果。\n\n本題沒有輸入，隨意輸入將會得到不可預期的結果。\n\n本題沒有輸出，隨意輸出將會得到不可預期的結果。\n\n",
    "output": "#include \"function06.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble average(int scores[], int size) {\n  int sum = 0;\n  for(int i = 0; i < size; i++) sum += scores[i];\n  return (double)sum / size;\n}\n"
  },
  {
    "id": "function07",
    "instruction": "除了數字可以排序以外，字串也可以排序喔！\n\n我們想要做出以下的排列方式：\n> 先以字串的長度由小而大排序，若字串的長度相等時，則按照字典序排序\n\n請在程式碼的第一行引入標頭檔 `function07.h`，並實作以下函數：\n\n- `void sort_by_length(char *strings[], int size);`：\n  - $strings$：代表待排序的字串陣列。\n  - $size$：代表此陣列有多少個字串，保證 $1\\le size\\le 100000$。\n  - 此函數會把傳入的 $strings$ 做上述的排序。\n\n可以使用 `std::sort` 中的 compare function。\n注意請勿在你的程式碼宣告主函式 `main()` 以及進行任何輸入輸出的動作，否則將會發生不可預期的結果。\n\n\n\n本題沒有輸入，隨意輸入將會得到不可預期的結果。\n\n本題沒有輸出，隨意輸出將會得到不可預期的結果。\n\n",
    "output": "#include \"function07.h\"\n#include <bits/stdc++.h>\n#include <cstring>\nusing namespace std;\n\nint cmpf(char str1[], char str2[]) {\n    int res = strlen(str2) - strlen(str1);\n    if (res != 0) return res > 0;\n    return strcmp(str2, str1) > 0;\n}\n\nvoid sort_by_length (char* strings[], int size) {\n    sort(strings, strings + size, cmpf);\n    return;\n}\n"
  },
  {
    "id": "function08",
    "instruction": "小 M 在學習矩陣乘法，但是覺得矩陣的乘法很麻煩，不想要動手算，於是想請你幫忙。聰明的你想到可以用程式來解決矩陣乘法的問題，請你動動手幫助小 M 吧！\n\n請在程式碼的第一行引入標頭檔 `function08.h`，並實作以下函數：\n\n- `void mat_mul(int n, int m, int k, int mat1[][1000], int mat2[][1000], int result[][1000])`：\n  - `mat1` 是一個 $n\\times m$ 的矩陣，`mat2` 是一個 $m\\times k$ 的矩陣。\n  - 請將 `mat1`$\\cdot$`mat2` 的結果存到 `result` 中。\n\n注意請勿在你的程式碼宣告主函式 `main()` 以及進行任何輸入輸出的動作，否則將會發生不可預期的結果。\n題目保證 $1\\le n, m\\le 1000$ ，且矩陣內每個元素 $a$ 滿足 $-1000\\le a\\le 1000$。\n\n本題沒有輸入，隨意輸入將會得到不可預期的結果。\n\n本題沒有輸出，隨意輸出將會得到不可預期的結果。\n\n",
    "output": "#include \"function08.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid mat_mul(int n, int m, int k, int mat1[][1000], int mat2[][1000], int result[][1000]) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < k; j++) {\n            result[i][j] = 0;\n            for(int l = 0; l < m; l++) {\n                result[i][j] += mat1[i][l] * mat2[l][j];\n            }\n        }\n    }\n}\n"
  },
  {
    "id": "function09",
    "instruction": "小風在上數學課，老師出了一道一元二次方程式 $ax^2 + bx + c = 0$ 讓大家練習，可是懶惰的小風想請你幫他用程式解解看這道問題是否有實數解，請勤勞的你幫助懶惰的小風吧！\n\n請在程式碼的第一行引入標頭檔 `function09.h`，並實作以下函數：\n\n- `bool solve_quadratic(int a, int b, int c, double &x1, double &x2)`：\n  - $a, b, c$：代表一元二次方程式 $ax^2 + bx + c = 0$ 的三個係數，保證滿足 $-10^5 \\leq a, b, c, \\leq 10^5$。\n  - 此函數需回傳一個布林值 `true/false`，如果有實數解請回傳 `true`，否則請回傳 `false`。\n  - 如果有實數解，請將兩個實數解分別存在變數 $x_1$ 以及 $x_2$ 中，並且必須滿足 $x_1 \\leq x_2$。\n  - 如果有重根的話，請將 $x_1$ 及 $x_2$ 都設為重根的值。\n\n注意請勿在你的程式碼宣告主函式 `main()` 以及進行任何輸入輸出的動作，否則將會發生不可預期的結果。\n\n\n本題沒有輸入，隨意輸入將會得到不可預期的結果。\n\n本題沒有輸出，隨意輸出將會得到不可預期的結果。\n\n",
    "output": "#include \"function09.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool solve_quadratic(int a, int b, int c, double &x1, double &x2) {\n  long long delta = 1LL * b * b - 4LL * a * c;\n  if(delta < 0) return 0;\n  \n  x1 = (-b - sqrt(delta)) / (2 * a);\n  x2 = (-b + sqrt(delta)) / (2 * a);\n  if(x1 > x2) swap(x1, x2);\n  return 1;\n}\n"
  },
  {
    "id": "function10",
    "instruction": "踩地雷是一個經典的小遊戲，透過點擊遊戲中空白的格子，就可以知道附近炸彈的數量，但是如果點擊的位置恰巧就是炸彈的位置，那麼遊戲就輸了。\n\n給定炸彈的位置，現在就來製造一個地圖，能夠依照遊戲規則顯示附近的炸彈數量，附近的意思是指八方位相鄰的格子。但如果那個位置剛好就是炸彈的話，就以 `-1` 表示，下圖為一個範例：\n\n![](https://i.imgur.com/PvSmT0z.png)\n\n請在程式碼的第一行引入標頭檔 `function10.h`，並實作以下函數：\n\n- `void calc_bombs(int n, int m, bool **is_bomb, int **count)`：\n  - $n, m$：代表地圖是一個 $n\\times m$ 的矩陣。\n  - $is$_$bomb$: 代表給定的炸彈位置，`true` 代表有炸彈，`false` 代表沒有炸彈。\n  - $count$: 代表依照題目要求輸出的地圖結果。\n\n保證對於所有測試資料 $1 \\leq n, m \\leq 1000$\n\n注意請勿在你的程式碼宣告主函式 `main()` 以及進行任何輸入輸出的動作，否則將會發生不可預期的結果。\n\n本題沒有輸入，隨意輸入將會得到不可預期的結果。\n\n本題沒有輸出，隨意輸出將會得到不可預期的結果。\n\n",
    "output": "#include \"function10.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid calc_bombs(int n, int m, bool **is_bomb, int **count) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int cnt = 0;\n            if (is_bomb[i][j]) {\n                count[i][j] = -1;\n                continue;\n            }\n            for(int k = max(0, i-1); k < min(n, i+2); k++) {\n                for(int l = max(0, j-1); l < min(m, j+2); l++) {\n                    if(is_bomb[k][l]) cnt++;\n                }\n            }\n            count[i][j] = cnt;\n        }\n    }\n}"
  },
  {
    "id": "function11",
    "instruction": "質因數分解（prime factorization）是 NP 問題的一種，但究竟是不是 P 問題一直是數學界尚未解開的難題之一。但當數字不是非常大時仍然是現今電腦可以解決的問題。\n\n在程式碼第一行加入 `#include \"function11.h\"`，並完成以下的函數：\n\n- `int factorize(int x, int primes[], int powers[])`\n    - 此函數將會回傳正整數 $x$ 的質因數個數 $n$，即 $x={p_1}^{k_1}\\cdot{p_2}^{k_2}\\cdots{p_n}^{k_n}$。\n    - 將 $x$ 的質因數 $p_i$ 由小到大存在 $primes$ 陣列中。\n    - $x$ 的第 $i$ 個質因數 $p_i$ 對應到的冪次 $k_i$ 請存在 $powers$ 陣列中。\n\n請勿在程式碼中加入 `main` 函式。\n\n不需進行額外的輸入或輸出。保證 $x$ 為大於 $1$ 的正整數。\n\n\n不需進行額外的輸入或輸出。\n\n",
    "output": "#include \"function11.h\"\n#include <cmath>\n#include <iostream>\n\nint factorize(int x, int primes[], int powers[]) {\n    int sqrtx = sqrt(x);\n    int idx = 0;\n    while (x != 1) {\n        int xi = x;\n        for (int i = 2; i <= sqrtx; i++) {\n            if (x % i == 0) {\n                powers[idx] = 0;\n                primes[idx] = i;\n                while (x % i == 0) {\n                    powers[idx]++;\n                    x /= i;\n                }\n                idx++;\n            }\n        }\n        if (x == xi) {\n            powers[idx] = 1;\n            primes[idx] = x;\n            idx++;\n            break;\n        }\n    }\n    return idx;\n}"
  },
  {
    "id": "function12",
    "instruction": "Max 發現 c++ 的 `algorithm` 標頭檔居然有 `max` 這個函式，自戀的他想要用這個函式解決大部分的題目。\n\n然而這裡當然只有一個題目，這個題目的目標是要用 `max` 找到三個正整數的中位數。\n\n註：只能使用 `algorithm` 裡的 `std::max` 函式及加減運算子，不能使用條件判斷式、`if`、`for`、`do`、`while`、或其他函式。\n\n輸入三個整數 $1 \\leq a, b, c \\leq 5$，以空格分隔。\n\n輸出中位數。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main ()\n{\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\n\tint big = max({a, b, c});\n\n\tint small = - max({-a, -b, -c});\n\n\tcout << a + b + c - big - small << '\\n';\n}\n"
  },
  {
    "id": "function13",
    "instruction": "最近空污嚴重，桃子突然想到可以賣新鮮竹子空氣賺錢。桃子有很多長方形的盒子，然而他數學不好，不知道這些盒子總共可以裝多少空氣。請你幫他算出一個盒子可以裝多少空氣，這樣他就能靠加法自己算出總和了。\n\n註：此題為互動題，請以下面的格式提交 code，你只需要完成函式的部分（提交時要交包含以下部分的 code）。\n\n```cpp\n#include \"function13.h\"\nint box_volume (int length, int width, int height)\n{\n    // your code\n}\n```\n\n函式的三個參數請參考題敘，單位為公尺。\n\n- $1 \\leq \\textrm{length, width, height} \\leq 1000$\n\n請不要動到輸入，否則你會得到 WA 或 RE。\n\n讓函式回傳體積，單位為立方公尺。\n請不要動到輸出，否則你會得到 WA。\n\n",
    "output": "#include \"function13.h\"\nint box_volume (int length, int width, int height)\n{\n    return length * width * height;\n}\n"
  },
  {
    "id": "function14",
    "instruction": "小 U 最近在複習排列組合，想請你幫他驗算排列組合的答案。他需要你幫忙寫出計算階乘和排列組合數的函式。\n\n階乘參考計算方法:\n$m! = \\begin{cases}\n1,\\quad \\texttt{if}\\ m=0 \\\\\n1 \\times 2 \\times\\dots\\times m,\\quad \\texttt{if}\\ m>0\n\\end{cases}$\n\n排列組合參考計算方法:\n$C(n,k) = \\frac{n!}{k!(n-k)!}$\n\n註：此題為互動題，請以下面的格式提交 code，你只需要完成函式的部分（提交時要交包含以下部分的 code）。\n```cpp\n#include \"function14.h\"\nint factorial(int m)\n{\n    // your code\n}\n\nint comb(int n,int k){\n    // your code\n}\n```\n\n函式的三個參數請參考題敘。\n\n- $0 \\leq \\textrm{n, m} \\leq 12$\n- $0 \\leq k \\leq n$\n\n請不要輸入任何東西。\n\n讓回傳函式計算結果。\n請不要輸出任何東西。\n\n",
    "output": "#include \"function14.h\"\nint factorial(int m)\n{\n    if(m == 0) return 1;\n    int r = 1;\n    for(int i=2;i<=m;i++) r *= i;\n    return r;\n}\nint comb(int n,int k){\n    return factorial(n)/factorial(k)/factorial(n-k);\n}"
  },
  {
    "id": "function15",
    "instruction": "最近作物收成。小 E 可以賣新鮮蔥和蒜賺錢。他現在有 $n$ 根蔥和大蒜，每根蔥和每顆大蒜都有他的重量。\n對於所有介在 $0$ 到 $n-1$ 之間的 $i$ 和 $j$ ，第 $i$ 根蔥的重量是 $a_i$，第 $j$ 顆大蒜的重量是 $b_j$。\n他將蔥和大蒜按順序配對起來販售，他發現只要 蔥的重量 $\\times$ 大蒜的重量 超過 $\\texttt{threshold}$ 的組合都能成功賣出。\n請你幫他計算按順序配對可以賣出多少份。\n \n註：此題為互動題，請以下面的格式提交程式碼，你只需要完成函式的部分（提交時只要交包含以下部分的程式碼）。\n\n```cpp\n#include \"function15.h\"\nvoid array_filter(int n, int *a, int *b, int threshold, int &ans)\n{\n    // your code\n}\n```\n\n函式的參數請參考題敘。\n\n- $1 \\leq n \\leq 1000$\n- $1 \\leq a_i,b_j \\leq 1000$\n- $1 \\leq \\texttt{threshold} \\leq 1000000$\n\n請不要輸入任何東西。\n\n將答案存入 ans 中。\n請不要輸出任何東西。\n\n",
    "output": "#include \"function15.h\"\nvoid array_filter(int n, int *a, int *b, int threshold, int &ans)\n{\n    ans = 0;\n    for(int i=0;i<n;i++) \n        if(a[i]*b[i] > threshold) ans++;\n}"
  },
  {
    "id": "graph01",
    "instruction": "將樹上的某個點移除後，樹將分成若干個子樹，定義其中最小化最大子樹的點為樹重心。現給一棵樹，請求其樹重心。\n\n輸入第一行是一個正整數 $N$ 表示樹的節點數。\n\n接著有 $N-1$ 行每行空白分開的兩個數 $u,v$，代表樹上的邊。\n\n輸入保證 $1\\le N\\le 10^5$，$0\\le u,v < N$，且邊集構成一棵樹。\n\n假設樹有 $c$ 個重心，由小到大輸出 $c$ 行，每行包含一個整數，代表樹的重心位置。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nvector<int> e[maxn];\nint sz[maxn], n;\nvector<int> res;\nvoid dfs(int x, int src) {\n    // Maintain subtree sizes\n    sz[x] = 1;\n    // Track the max-subtree size\n    int mx = 0;\n    for(auto k: e[x]) {\n        if(k == src) continue;\n        dfs(k, x);\n        sz[x] += sz[k];\n        mx = max(mx, sz[k]);\n    }\n    mx = max(mx, n-sz[x]);\n    // Output solution\n    if(mx <= n/2) {\n        res.push_back(x);\n    }\n}\nint main() {\n    // Read input\n    cin >> n;\n    for(int i = 1; i < n; i++) {\n        int u,v;\n        cin >> u >> v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    // dfs\n    dfs(0, -1);\n    sort(res.begin(), res.end());\n    for(auto k: res)\n        cout << k << endl;\n}\n"
  },
  {
    "id": "graph02",
    "instruction": "作為一個軌道機關設計師，你製作了一連串小球下落的軌道。這個軌道有 $N-1$ 個中繼點編號 $1\\sim N-1$ 以及 $N$ 個終點編號 $N\\sim 2N-1$，其中編號 $1$ 的中繼點是小球進入的起點。這個機關每個中繼點都連接左右兩個出口，出口可能連接其他中繼點或終點。而終點便是囤積小球的地方，所有先前抵達的小球都會累積在這。\n\n對於每個中繼點，所有從左側出口能到達的終點所累積的小球重量都會成為左側軌道的負重，同理右側軌道也有負重。每次小球都會選擇負重較輕的那側出口離開，如果一樣重則選擇左邊。現在請你模擬 $M$ 個小球依序落下的過程，並回答這 $M$ 個小球分別落入哪個終點。在開始之前，終點可能已累積了一些小球。\n\n輸入第一行是兩個整數 $N, M$，分別代表軌道終點數量和要模擬的小球數量。\n輸入第二行是 $N$ 個整數 $w_N, w_{N+1}, \\dots, w_{2N-1}$，分別代表編號 $N, N+1, \\dots, 2N-1$ 終點的初始重量。\n輸入第三行是 $M$ 個整數 $b_1, b_2, \\dots, b_M$，代表依序進入軌道的小球重量。\n接著有 $N-1$ 行，每行有三個數字 $p, s, t$，代表編號 $p$ 的中繼點連接 $s, t$ 兩個出口。\n所有數字皆以空白分隔。\n\n輸入保證 $1\\le N\\le 10^5$，$1\\le M\\le 100$，所有初始重量加上小球重量不超過 $10^9$，且一定是合法軌道，軌道連通且小球下落一定會結束在某個終點。\n\n輸出一行 $M$ 個空白分隔的整數，代表小球抵達哪個終點。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\nint w[maxn], a[maxn][2], b[maxn], val, n;\nvoid pull(int x) {\n    if(x >= n) return;\n    pull(a[x][0]);\n    pull(a[x][1]);\n    w[x] = w[a[x][0]] + w[a[x][1]];\n}\nint roll(int x) {\n    if(x >= n) return x;\n    if(w[a[x][0]] <= w[a[x][1]]) return roll(a[x][0]);\n    else return roll(a[x][1]);\n}\nint main() {\n    int m;\n    cin >> n >> m;\n    for(int i = n; i < n*2; i++) cin >> w[i];\n    for(int i = 0; i < m; i++) cin >> b[i];\n    for(int i = 1; i < n; i++) {\n        int p;\n        cin >> p;\n        cin >> a[p][0] >> a[p][1];\n    }\n    for(int i = 0; i < m; i++) {\n        val = b[i];\n        pull(1);\n        int ans = roll(1);\n        w[ans] += b[i];\n        if(i) cout << \" \";\n        cout << ans;\n    }\n    cout << endl;\n}\n"
  },
  {
    "id": "graph03",
    "instruction": "本題改寫自 2016 年 3 月 APCS 考古題。\n\n小 Y 是歪皮有限公司的大老闆，這家公司有著嚴格的企業管理階層，每個員工都被指定了一個位階。此外，除了小 Y 以外的每個人都配有一個直屬上司，直屬上司的位階一定會比自己高。小 Y 是全公司位階最高的人。\n\n\n因為有著這樣的特色，員工們彼此溝通喜歡透過直屬上司或直屬下屬傳話。舉例來說，下圖是公司直屬關係圖，在上面的節點表示位階較高者，連邊表示兩人有直屬關係。如果 $1$ 號和 $3$ 號員工需要傳話，$1$ 號會通過直屬上司 $4$ 號，$4$ 號的直屬下屬 $2$ 號，$2$ 號的直屬下屬 $3$ 號來完成，這中間經過 $3$ 次傳話。\n![](https://i.imgur.com/lBfoUgP.png)\n\n這樣的過程不盡然有效率，因此小 Y 想知道直屬關係最遠的兩個員工需要通過幾次傳話才能完成溝通。\n\n輸入包含多筆測資。\n\n每筆測資中，\n第一行為一個正整數 $N$ 代表成員的個數，每人以 $0\\sim N-1$ 之間唯一的編號代表。\n接著的 $N-1$ 行，每行有兩個以一個空白隔開的整數 $a$ 與 $b$ ($0 \\le a, b \\le N-1$)，代表 $a$ 是 $b$ 的直屬上司。\n\n假設 $S$ 是一次執行中所有測資的 $N$ 總和。\n在 $10\\%$ 的測資中，$2 \\le S \\le 100$ ，小 Y 最多有 $2$ 個直屬下屬，其他人最多一個直屬下屬。\n其中 $40\\%$ 的測資滿足，$2 \\le S \\le 100$。\n其中 $70\\%$ 的測資滿足，$2 \\le S \\le 2000$。\n其中 $100\\%$ 的測資滿足，$2 \\le S \\le 100000$。\n\n每筆測資輸出一行，輸出兩名員工需要的最多傳話次數。\n\n",
    "output": "#include <iostream>\n#include <vector>\nusing namespace std;\nconst int maxn = 100010;\nvector<int> edge[maxn]; // Stores the children of a vertex\nint indeg[maxn]; // Counts the in-degree of an vertex to find the tree root\nint ans = 0; // Tracks the answer\nint height[maxn]; // Stores the vertex height\n\n// Traverse the tree\nvoid dfs(int x) {\n    int largest = 0, second_largest = 0;\n    for(auto k:edge[x]) {\n        dfs(k);\n        // Maintain the two highest children\n        if(height[k]+1 > largest) {\n            second_largest = largest;\n            largest = height[k]+1;\n        }\n        else if (height[k]+1 > second_largest) {\n            second_largest = height[k]+1;\n        }\n        // Maintain height[x]\n        height[x] = max(height[k]+1, height[x]);\n    }\n    // Update answer\n    ans = max(ans, largest + second_largest);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    while(cin >> n) {\n        // Initialize\n        ans = 0;\n        for(int i = 0; i <= n; i++) {\n            edge[i].clear();\n            indeg[i] = height[i] = 0;\n        }\n        // Read input\n        int a,b;\n        for(int i = 1; i < n; i++) {\n            cin >> a >> b;\n            edge[a].push_back(b);\n            indeg[b]++;\n        }\n        // The vertex without in-degree is the root\n        int root = -1;\n        for(int i = 0; i < n; i++) if(indeg[i] == 0) root = i;\n        dfs(root);\n        cout << ans << '\\n';\n    }\n}\n"
  },
  {
    "id": "graph04",
    "instruction": "皮皮經常穿梭世界各地，也因此他拿到了航空公司的優惠券，可以免費搭乘一趟飛機。假設世界上一共有 $N$ 個編號 $1\\sim N$ 的城市以及 $M$ 條票價不盡相同的航線。皮皮想要從 $S$ 城市出發到 $T$ 城市，中間可能要經過幾趟轉機才能到達，但是免費優惠券只能用在途中的一條航班上，而其他航班仍須正常收費。請問皮皮的最小花費為何。\n\n輸入第一行是四個空白分隔的整數 $N, M, S, T$，分別代表城市數量，航班數量，以及起點和終點城市。\n\n接下來有 $M$ 行每行三個空白分隔的整數 $u,v,w$，分別代表航班起點和終點，以及票價。特別注意航班都是單向的。\n\n輸入保證 $2\\le N\\le 10^5$，$1\\le M\\le 10^5$，$1\\le w\\le 10^9$，$1\\le S, T, u, v\\le N$，$S\\ne T$，$u\\ne v$，以及沒有兩個航班有相同起終點。\n\n輸出一行一個整數表示皮皮的最小花費。如果皮皮無法用提供的航班抵達 $T$ 城市，請輸出 $-1$。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nvector<pair<int, int>> e[maxn];\nlong long dis[maxn];\nbool vis[maxn];\nint main() {\n    int N, M, S, T;\n    cin >> N >> M >> S >> T;\n    // Read input\n    for(int i = 0; i < M; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        e[u].push_back({v,w});\n        e[u].push_back({v+N, 0});\n        e[u+N].push_back({v+N, w});\n    }\n    memset(dis, 0x3f, sizeof(dis));\n    // Dijkstra\n    dis[S] = 0;\n    priority_queue<pair<long long,int>> pq;\n    pq.push({0, S});\n    while(!pq.empty()) {\n        int x = pq.top().second;\n        pq.pop();\n        if(vis[x]) continue;\n        vis[x] = 1;\n        for(auto edge: e[x]) {\n            if(!vis[edge.first] && dis[x] + edge.second < dis[edge.first]) {\n                dis[edge.first] = dis[x] + edge.second;\n                pq.push({-dis[edge.first], edge.first});\n            }\n        }\n    }\n    long long ans = min(dis[T], dis[T+N]);\n    if(ans > 1e15) ans = -1;\n    cout << ans << endl;\n}\n"
  },
  {
    "id": "graph05",
    "instruction": "帥氣總召舉辦了 APCS 營隊，營隊中共有 $N$ 位學生，為了營隊中活動需求，他想將所有學生分成兩個組別，但是有些學生們互相討厭，他們永遠不想被分到同一組。帥氣總召想問問同學們是否有辦法將所有同學分成兩組，使得同一組內任兩位學生都沒有互相討厭，注意到不能有任何一個組別是空的。\n\n輸入第一行有兩個正整數 $N, M (2 \\leq N \\leq 100000, 1 \\leq M \\leq 100000)$，學生們以 $1, 2, \\ldots, N$ 進行編號。\n接下來 $M$ 行，第 $i$ 行有兩個正整數 $x_i, y_i (1 \\leq x_i, y_i \\leq N, x_i \\neq y_i)$，代表學生 $x_i$ 和學生 $y_i$ 互相討厭，不想被分在同一組。\n輸入保證對於所有 $i \\neq j$ 皆有 $\\lbrace x_i, y_i\\rbrace \\neq \\lbrace x_j, y_j\\rbrace$，即同一對學生之間不會重複敘述兩次討厭關係。\n\n輸出只有一行，若可以將學生們分成兩組，請輸出 `Yes`，否則請輸出 `No`。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXn 100000\n#define pb emplace_back\nvector<vector<int>> g;\nvector<pair<int, int>> e;\nint z[MAXn + 5], vis[MAXn + 5];\nvoid dfs(int x, int a){\n    z[x] = a, vis[x] = 1;\n    for (int y : g[x])\n        if (!vis[y])\n            dfs(y, a ^ 1);\n}\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m; cin >> n >> m;\n    g.resize(n);\n    for (int i = 0, a, b; i < m; i++)\n        cin >> a >> b, --a, --b, g[a].pb(b), g[b].pb(a), e.pb(a, b);\n    for (int i = 0; i < n; i++)\n        if (!vis[i])\n            dfs(i, 0);\n    for (auto [a, b] : e)\n        if (z[a] == z[b])\n            return cout << \"No\\n\", 0;\n    cout << \"Yes\\n\";\n    return 0;\n}\n"
  },
  {
    "id": "graph06",
    "instruction": "小風手上拿著一棵具有 $N$ 個節點的樹，這棵樹的節點以 $1, 2, \\ldots, N$ 表示。然而，標號為 $1$ 的節點上有一株病毒，這個病毒會沿著樹上的邊擴散，為了盡可能保護這棵樹，小風想要切除樹上的一些邊，使得被感染的節點不超過 $K$ 個，不過有些邊是沒辦法被切除的，請幫小風計算至少要切除幾條邊才能夠達成目標？\n\n\n輸入第一行包含兩個正整數 $N, K (1 \\leq K \\leq N \\leq 5 \\times 10^5)$。\n接下來 $N - 1$ 行每一行都有三個整數 $a, b, c (1 \\leq a, b \\leq n, c \\in {0, 1})$，代表著樹上的一條邊 $(a, b)$，若 $c = 1$ 代表這條邊可以被切除，否則該條邊不能被切除，輸入保證會形成一棵樹。\n\n\n請輸出一個整數代表至少要移除多少條邊才能讓被感染的節點不超過 $K$ 個，如果無法達成，請輸出 $-1$。\n\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int n, k; cin >> n >> k;\n  vector<vector<pair<int, int>>> g(n + 1, vector<pair<int, int>>{});\n\n  for(int i = 1; i < n; i++) {\n    int x, y, c; cin >> x >> y >> c;\n    g[x].emplace_back(y, c), g[y].emplace_back(x, c);\n  }\n\n  if(n == k) return cout << 0 << '\\n', 0;\n\n  vector<int> com;\n  vector<int> sz(n + 1);\n  function<void(int, int, bool)> Dfs = [&](int u, int fa, bool flag) {\n    sz[u] = 1;\n    for(auto [v, c] : g[u]) if(v != fa) {\n      Dfs(v, u, flag || c), sz[u] += sz[v];\n      if(!flag && c) com.push_back(sz[v]);\n    }\n  };\n\n  Dfs(1, -1, 0);\n  sort(com.begin(), com.end(), greater<int>());\n  int ans = 0, sum = 0;\n  for(int x : com) {\n    ans++, sum += x;\n    if(sum >= n - k) break;\n  }\n\n  cout << (sum >= n - k ? ans : -1) << '\\n';\n  return 0;\n}\n\n"
  },
  {
    "id": "graph07",
    "instruction": "Portal 是一款拿著傳送槍跑來跑去的解謎遊戲，老張想要做一款對它~~抄襲~~致敬的遊戲，名字叫 Partol。遊戲是在一個一維世界中進行的，以 $[0,1,\\ldots,n-1]$ 代表位置，玩家會從位置 $0$ 開始進行遊戲，目標是走到位置 $p$ 的出口。\n操作方式如下，每個回合玩家可以選擇往左走 $l$ 步或往右走 $r$ 步，如果走超過邊界，也就是位置 $<0$ 或 $>n-1$ 會 Game Over。\n\n回合結束時，如果玩家停在位置 $i$，且 $s(i) \\neq i$，則玩家會被神秘的量子物理傳送門傳送到 $s(i)$，有些 $s(i)$ 會比 $n$ 還大，這些傳送門會把玩家丟到虛空，也會導致 Game over。保證 $s(0) = 0, s(p) = p$（起點與出口是不動點），並且 $s(s(i)) = s(i) \\ \\ \\forall s(i) \\in [0,n-1]$，也就是不會發生連續傳送的現象。老張想要知道從起點走到出口最少要幾個回合，請幫他算算看。如果沒辦法走出口，也告訴他一聲。\n\n第一行有 $4$ 個整數 $n,p,l,r$，分別代表遊戲空間長度，目標位置，往左/右移動的距離。\n第二行有 $n$ 個整數，代表 $s(0),s(1),...,s(n-1)$。\n\n- $2 \\leq n \\leq 10^6$\n- $1 \\leq p \\leq n-1$ \n- $1 \\leq l,r \\leq n-1$\n- $-10^8 \\leq s(i) \\leq 10^8, \\forall i$\n\n從起點走到出口最少要幾個回合，如果沒辦法走到出口，請輸出 $-1$。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n#define max_n 10000000\nint main() {\n\tint n,p,L,R;\n\tcin >> n >> p >> L >> R;\n\tvector<int> s;\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tint in;\n\t\tcin >> in;\n\t\ts.push_back(in);\n\t\tif( s[i] >= n || s[i] < 0)\n\t\t\ts[i] = -1;\n\t}\n\tvector<int> l_to,r_to;\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tif( i - L < 0 || i - L >= n)\n\t\t\tl_to.push_back(-1);\n\t\telse\n\t\t\tl_to.push_back(s[ i - L ]);\n\n\t\tif( i + R < 0 || i + R >= n)\n\t\t\tr_to.push_back(-1);\n\t\telse\n\t\t\tr_to.push_back(s[ i + R ]);\n\t}\n\tvector<bool> in_queue(n,false);\n\tqueue< pair<int,int> > Q;//first:pos,second:dis\n\tQ.push( make_pair(0,0) );\n\twhile(!Q.empty())\n\t{\n\t\tint cur_pos = Q.front().first;\n\t\tint cur_dis = Q.front().second;\n\t\tQ.pop();\n#ifdef Debug\n\t\tprintf(\"pos: %d, dis: %d\\n\",cur_pos,cur_dis);\n#endif\n\t\tif( cur_pos < 0 || cur_pos >= n)\n\t\t\tcontinue;\n\t\tif( cur_pos == p )\n\t\t{\n\t\t\tcout << cur_dis << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif( l_to[cur_pos] == p || r_to[cur_pos] == p )\n\t\t{\n\t\t\tcout << cur_dis+1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif( l_to[ cur_pos ] != -1 )\n\t\t{\n\t\t\tif(!in_queue[ l_to[cur_pos] ])\n\t\t\t{\n\t\t\t\tQ.push( make_pair(l_to[cur_pos], cur_dis+1));\n\t\t\t\tin_queue[ l_to[cur_pos] ] = true;\n\t\t\t}\n\t\t}\n\t\tif( r_to[ cur_pos ] != -1 )\n\t\t{\n\t\t\tif(!in_queue[ r_to[cur_pos] ])\n\t\t\t{\n\t\t\t\tQ.push( make_pair(r_to[cur_pos], cur_dis+1));\n\t\t\t\tin_queue[ r_to[cur_pos] ] = true;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"-1\" << endl;\n}\n"
  },
  {
    "id": "graph08",
    "instruction": "一間教室裡面有 $N$ 行 $M$ 列的座位，有些座位坐著學生，有一些座位則是空的。第一天的時候，一個坐在第 $s$ 橫列第 $t$ 直行的學生生病了，接下來的每一天，坐在生病同學前後左右的學生都會生病，而生過病的同學會產生抵抗力，因此不會重複生病。請計算出每位同學會在第幾天生病。\n\n輸入第一行有兩個正整數 $N$ 和 $M$，代表教室的大小。第二行有兩個正整數 $s, t$，代表第一個生病的學生的位置。接下來 $N$ 行，第 $i$ 行有一個字串代表座位第 $i$ 橫列的狀況，若該列第 $j$ 直行的座位沒有學生，則第 $j$ 個字元為 `X`，否則為 `.`。\n\n- $1 \\le N \\le 500$\n- $1 \\le M \\le 500$\n- $1 \\le s \\le N$\n- $1 \\le t \\le M$\n- 保證一開始生病學生的座位不是空座位\n\n輸出有 $N$ 行，第 $i$ 行有第 $i$ 橫列的學生狀況，包含 $M$ 個空格分隔的整數，如果對應的學生在第 $x$ 天生病，則輸出 $x$，若該位置沒有學生或該學生永遠不會生病則輸出 `-1`。\n\n",
    "output": "/*input\n3 3\n2 2\n.X.\n...\nX..\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=505;\n\nstring g[maxn];\nint ans[maxn][maxn];\nint n, m, s, t;\n\nbool isValid(int x,int y){\n\treturn 0 <= x && x < n && 0 <= y && y < m && g[x][y] == '.' && ans[x][y] == -1;\n}\n\nint main(){\n\tcin>>n>>m>>s>>t;\n\ts--; t--;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tans[i][j]= -1;\n\tfor(int i = 0; i < n; i++) cin>>g[i];\n\tans[s][t] = 0;\n\tvector<pair<int, int>> q;\n\tq.emplace_back(s, t);\n\tint pt = 0;\n\twhile(pt < q.size()){\n\t\tint x = q[pt].first, y = q[pt].second;\n\t\tpt ++;\n\t\tif(isValid(x + 1, y)){\n\t\t\tans[x + 1][y] = ans[x][y] + 1;\n\t\t\tq.emplace_back(x + 1, y);\n\t\t}\n\t\tif(isValid(x - 1, y)){\n\t\t\tans[x - 1][y] = ans[x][y] + 1;\n\t\t\tq.emplace_back(x - 1, y);\n\t\t}\n\t\tif(isValid(x, y + 1)){\n\t\t\tans[x][y + 1] = ans[x][y] + 1;\n\t\t\tq.emplace_back(x, y + 1);\n\t\t}\n\t\tif(isValid(x, y - 1)){\n\t\t\tans[x][y - 1] = ans[x][y] + 1;\n\t\t\tq.emplace_back(x, y - 1);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++) {\n      if (ans[i][j] == -1)\n        cout<<ans[i][j]<<\" \\n\"[j == m - 1];\n      else\n        cout<<ans[i][j] + 1<<\" \\n\"[j == m - 1];\n    }\n\treturn 0;\n}\n"
  },
  {
    "id": "graph09",
    "instruction": "在一個 $N \\times N$ 的西洋棋盤上，有一隻騎士在第 $a$ 行第 $b$ 列的格子上，這隻騎士想要移動到第 $c$ 行第 $d$ 列的格子，但是只能照著西洋棋騎士日字形的走法 ( https://zh.wikipedia.org/zh-tw/%E9%A6%AC_(%E5%9C%8B%E9%9A%9B%E8%B1%A1%E6%A3%8B) ) ，另外有幾個格子有陷阱，所以騎士不能停在這些格子上，請問到目的地所需的最少步數為多少？\n輸入第一行有一個正整數 $N$ 代表棋盤的大小，輸入的第二行有四個正整數 $a,b,c,d$ 代表騎士的初始位置和目的地位置，輸入第三行有一個整數 $T$ 代表陷阱格子的數目，接下來 $T$ 行中每一行都有兩個正整數 $x, y$ 代表第 $x$ 行第 $y$ 列的格子是陷阱。\n\n- $2 \\le N \\le 1000$\n- $1 \\le a, b, c, d \\le N$\n- $0 \\le T \\le N^2 - 2$\n- $1 \\le x, y \\le N$\n- 保證不會有位置重複的陷阱且初始位置和目的地都不是陷阱。\n\n輸出一個整數代表需要的步數，若騎士永遠無法達到目的地，則輸出 ```-1``` 。\n",
    "output": "/*input\n4\n1 1 1 3\n1\n3 2\n*/\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int maxn=1005;\n\nint ans[maxn][maxn];\nbool trap[maxn][maxn];\nint n;\nint a,b,c,d;\n\nbool isValid(int x,int y){\n\treturn 0 <= x && x < n && 0 <= y && y < n && !trap[x][y] && ans[x][y] == -1;\n}\n\nint main(){\n\tcin>>n;\n\tcin>>a>>b>>c>>d;\n\ta--; b--; c--; d--;\n\n\tint T;\n\tcin>>T;\n\twhile(T--){\n\t\tint x, y;\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\ttrap[x][y] = 1;\n\t}\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < n; j++) ans[i][j] = -1;\n\tans[a][b] = 0;\n\tvector<pair<int,int>> q;\n\tq.emplace_back(a, b);\n\tint pt = 0;\n\twhile(pt < q.size()){\n\t\tint x = q[pt].first, y = q[pt].second;\n\t\tpt ++;\n\t\tif(isValid(x + 2, y + 1)){\n\t\t\tans[x + 2][y + 1] = ans[x][y] + 1;\n\t\t\tq.emplace_back(x + 2, y + 1);\n\t\t}\n\t\tif(isValid(x + 2, y - 1)){\n\t\t\tans[x + 2][y - 1] = ans[x][y] + 1;\n\t\t\tq.emplace_back(x + 2, y - 1);\n\t\t}\n\t\tif(isValid(x + 1, y + 2)){\n\t\t\tans[x + 1][y + 2] = ans[x][y] + 1;\n\t\t\tq.emplace_back(x + 1, y + 2);\n\t\t}\n\t\tif(isValid(x + 1, y - 2)){\n\t\t\tans[x + 1][y - 2] = ans[x][y] + 1;\n\t\t\tq.emplace_back(x + 1, y - 2);\n\t\t}\n\t\tif(isValid(x - 2, y + 1)){\n\t\t\tans[x - 2][y + 1] = ans[x][y] + 1;\n\t\t\tq.emplace_back(x - 2, y + 1);\n\t\t}\n\t\tif(isValid(x - 2, y - 1)){\n\t\t\tans[x - 2][y - 1] = ans[x][y] + 1;\n\t\t\tq.emplace_back(x - 2, y - 1);\n\t\t}\n\t\tif(isValid(x - 1, y + 2)){\n\t\t\tans[x - 1][y + 2] = ans[x][y] + 1;\n\t\t\tq.emplace_back(x - 1, y + 2);\n\t\t}\n\t\tif(isValid(x - 1, y - 2)){\n\t\t\tans[x - 1][y - 2] = ans[x][y] + 1;\n\t\t\tq.emplace_back(x - 1, y - 2);\n\t\t}\n\t}\n\tcout<<ans[c][d]<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "id": "graph10",
    "instruction": "學姐喜歡遞增字串 – 一個字串是遞增字串若且唯若這個字串的字母相異且照著字母的順序排列，例如 `abc`，`apz` 是遞增字串，但 `acb`，`qqq` 就不是遞增字串。學姐搜集所有長度不超過 $5$ 的遞增字串，並且照著長度排序，如果長度一樣則照著字典序排序，因此排列以後大致會像是 `[\"a\", \"b\", \"c\", ... , \"z\", \"ab\", \"ac\", ... \"yz\", \"abc\", ... \"vwxyz\"]` 。\n\n現在給你一個遞增字串，請回答排序後，這個遞增字串是第幾個出現的。\n\n輸入第一行有一個正整數 $T$ 代表詢問的次數，接下來 $T$ 行，每一行有一個遞增字串。\n\n- $1 \\le T \\le 83681$\n- 保證詢問的字串是遞增字串且長度不超過 $5$\n\n對於每一個詢問的遞增字串，輸出一個正整數代表他在排序後出現的位置。\n",
    "output": "/*input\n3\nz\naz\nboy\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=505;\n\nmap<string, int> mp;\nvector<string> q;\nint pt = 0;\n\nint main(){\n\tfor(int i = 0; i < 26; i++){\n\t\tstring tmp = \"\";\n\t\ttmp.push_back(char('a' + i));\n\t\tmp[tmp] = i;\n\t\tq.push_back(tmp);\n\t}\n\twhile(pt < q.size()){\n\t\tstring cur = q[pt++];\n\t\tif(cur.size() == 5) continue;\n\t\tfor(char c = cur.back() + 1; c <= 'z'; c++){\n\t\t\tstring nxt = cur;\n\t\t\tnxt.push_back(c);\n\t\t\tmp[nxt] = q.size();\n\t\t\tq.push_back(nxt);\n\t\t}\n\t}\n\tint T;\n\tcin>>T;\n\twhile(T--){\n\t\tstring s;\n\t\tcin>>s;\n\t\tcout<<mp[s] + 1<<'\\n';\n\t}\n}\n"
  },
  {
    "id": "graph11",
    "instruction": "某座格局方正的城市可以被視為一個 $N\\times M$ 的方格，並且建築都是佔據 $1\\times 1$ 的單位方格，假設沒有建築的地方都是可以行走的道路，兩格空地視為相鄰如果他們有共同邊。\n\n你現在要為一個機車充電站評估設點位置是否方便使用者，充電站一定會設置在空地上。你想要計算對於每塊空地，他到最近充電站的距離總和是多少？其中兩空地 $A, B$ 間距離表示至少要從 $A$ 移動幾次到相鄰空地才能到 $B$，充電站所在空地到最近充電站距離為 $0$。\n\n保證對任意兩空地，都有路可以從其中一邊走到另外一邊。\n\n輸入第一行是三個空白分隔的整數 $N,M,K$，分別代表城市長寬以及充電站數。\n接下來 $N$ 行每行 $M$ 個字元代表城市的地圖，第 $i$ 行第 $j$ 個字元代表座標 $(i,j)$ 的情況 $(1\\le i\\le N, 1\\le j\\le M)$，如果字元是 `#` 代表是建築，如果是 `.` 代表是空地。\n接下來 $K$ 行每行兩個空白分隔的整數 $x,y$，代表座標 $(x,y)$ 有充電站。\n\n輸入保證 $1\\le N, M\\le 1000$，$1\\le K\\le \\min(10000, N\\times M)$，$1\\le x\\le N$，$1\\le y\\le M$，並保證所有充電站都在空地上且位置兩兩相異。\n\n輸出一行一個整數表示總距離和。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n#define pii pair<int,int>\nconst int maxn = 1010;\nstring s[maxn];\nint dis[maxn][maxn];\nint main() {\n    int n,m,k;\n    cin >> n >> m >> k;\n    for(int i = 0; i < n; i++) cin >> s[i];\n    memset(dis, -1, sizeof(dis));\n    queue<pii> q;\n    for(int i = 0; i < k; i++) {\n        int x,y;\n        cin >> x >> y;\n        q.push({x-1, y-1});\n        dis[x-1][y-1] = 0;\n    }\n    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n    while(!q.empty()) {\n        pii x = q.front();\n        q.pop();\n        for(int i = 0; i < 4; i++) {\n            int u = x.first + dx[i], v = x.second + dy[i];\n            if(u < 0 || u == n || v < 0 || v == m || s[u][v] == '#' || dis[u][v] >= 0) continue;\n            dis[u][v] = dis[x.first][x.second] + 1;\n            q.push({u,v});\n        }\n    }\n    long long ans = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++) {\n            if(dis[i][j] >= 0) ans += dis[i][j];\n            assert(s[i][j] == '#' || s[i][j] >= 0);\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "id": "graph12",
    "instruction": "在疫情嚴重之際，小風城研擬了一個封城規定。每個人只能在以住處為圓心，半徑 $R$ 的圓內活動。在允許的活動範圍內，活動區域有相交的兩個居民可以互相傳遞物品，活動區域只相交於一點也可以。\n\n如果有兩個居民無法通過一系列傳遞互相來往，那他們生活會很不方便。小風想知道最小的整數 $R$，使得在這樣的封城狀態下，任兩位居民還是能通過一系列傳遞來往。\n\n輸入包含多筆測資。輸入的第一行是一個整數 $T$ 代表測資筆數。\n每一筆測試資料第一行是一個整數 $N$，代表小風城一共有幾個居民。接下來的 $N$ 行是兩個以空白分隔的正整數，分別代表該居民所在位置的 $x,y$ 座標。\n\n對於所有測資，保證 $T\\le 100$，$2\\le N\\le 1000$，$-10^9\\le x,y\\le 10^9$。\n測資額外保證單筆輸入 $N$ 的總和不超過 $2000$。注意到可能有兩個居民在同一個位置。\n\n每筆測資輸出一行一個整數，代表最小的封城半徑 $R$。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1010;\nstruct edge {\n    int st, ed;\n    long long w;\n    edge(){}\n    edge(int _st, int _ed, int _w): st(_st), ed(_ed), w(_w){}\n    bool operator < (const edge& e) const {\n        return w < e.w;\n    }\n};\nvector<edge> edges;\nlong long x[maxn], y[maxn];\nlong long dis(int u, int v) {\n    // Careful deal with the floating point error\n    long long d = ceil(sqrt((x[u] - x[v]) * (x[u] - x[v]) + (y[u] - y[v]) * (y[u] - y[v])));\n    if(d * d < (x[u] - x[v]) * (x[u] - x[v]) + (y[u] - y[v]) * (y[u] - y[v])) d++;\n    return (d+1)/2;\n}\nint fa[maxn];\nint union_find(int e) {\n    return (fa[e] == e ? e:fa[e] = union_find(fa[e]));\n}\nint main() {\n    int T;\n    cin >> T;\n    while(T--) {\n        // Initialize\n        edges.clear();\n        // Read input\n        int n;\n        cin >> n;\n        for(int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i];\n        }\n        // Computes all edges\n        for(int i = 0; i < n; i++) {\n            for(int j = i+1; j < n; j++) {\n                edges.push_back(edge(i, j, dis(i,j)));\n            }\n        }\n        // Perform Kruscal\n        sort(edges.begin(), edges.end());\n        for(int i = 0; i < n; i++) fa[i] = i;\n        int cnt = n-1, ans = -1; // Process ends when n-1 edges are connected\n        for(auto e:edges) {\n            if(union_find(e.st) == union_find(e.ed)) continue;\n            fa[union_find(e.st)] = union_find(e.ed);\n            cnt--;\n            // When the process ends, records the largest edge weight.\n            if(cnt == 0) {\n                ans = e.w;\n                break;\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "id": "graph13",
    "instruction": "紅白對抗賽是一個邀請性質的歌唱比賽，主辦方找來了 $N$ 個歌手編號 $0\\sim N-1$，並分成兩組紅隊和白隊進行比賽，其中兩隊人數不一定要一樣。但這次比賽特別的是，主辦方開放觀眾提出分隊意見，一個觀眾可以指定兩個成員 $u,v$ 必須同隊或不同隊。\n\n請你實作一個模擬程式，支援觀眾的操作並提供實時查詢兩個歌手是否一定同隊或敵對。\n\n輸入第一行是一個數字 $N$ 表示歌手人數。\n接著若干行有三個變數 $cmd, u, v$，其中：\n\n- $cmd = 1$ 時表示觀眾希望 $u, v$ 同隊。如果此要求和先前分隊規則相牴觸則此操作無效，並輸出 $-1$。\n- $cmd = 2$ 時表示觀眾希望 $u, v$ 敵隊。如果此要求和先前分隊規則相牴觸則此操作無效，並輸出 $-1$。\n- $cmd = 3$ 時表示查詢 $u,v$ 是否一定同隊。如果一定同隊輸出 $1$，否則輸出 $0$。\n- $cmd = 4$ 時表示查詢 $u,v$ 是否一定敵隊。如果一定敵隊輸出 $1$，否則輸出 $0$。\n\n當 $cmd = u = v = 0$ 時表示系統關閉不再接受回應。此時請直接結束程式，並不需處理這筆輸入。\n其他操作保證 $1\\le N\\le 2\\times10^5$，$1\\le cmd\\le 4$，$0\\le u,v \\le N-1$，$u\\ne v$，且總操作數不超過 $2\\times 10^5$。\n\n請依照以上規則輸出結果，數字間以換行分隔。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200000 + 10;\n// tag: product of tag[x] ~ tag[root] is the party of x, value range = {+1, -1}\n// the tag of root is always +1\nint fa[maxn], tag[maxn];\npair<int,int> get_root_party(int x) {\n    if(x == fa[x]) {\n        return make_pair(x, 1);\n    }\n    pair<int, int> result = get_root_party(fa[x]);\n    result.second *= tag[x];\n    fa[x] = result.first;\n    tag[x] = result.second;\n    return result;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; i++) {\n        fa[i] = i;\n        tag[i] = 1;\n    }\n    // cmd = 1: set u,v to freiends\n    // cmd = 2: set u,v to enemies\n    // cmd = 3: check if u,v are friends\n    // cmd = 4: check if u,v are enemies\n    int cmd, u, v;\n    while(cin >> cmd >> u >> v && cmd) {\n        if(cmd == 1) {\n            pair<int, int> infou = get_root_party(u);\n            pair<int, int> infov = get_root_party(v);\n            if(infou.first == infov.first) {\n                // u, v are enemies\n                if(infou.second != infov.second) {\n                    cout << -1 << endl;\n                }\n                continue;\n            }\n            fa[infou.first] = infov.first;\n            // Make u, v the same party\n            if(infou.second != infov.second) {\n                tag[infou.first] *= -1;\n            }\n        }\n        if(cmd == 2) {\n            pair<int, int> infou = get_root_party(u);\n            pair<int, int> infov = get_root_party(v);\n            if(infou.first == infov.first) {\n                // u, v are friends\n                if(infou.second == infov.second) {\n                    cout << -1 << endl;\n                }\n                continue;\n            }\n            fa[infou.first] = infov.first;\n            // Make u, v the different party\n            if(infou.second == infov.second) {\n                tag[infou.first] *= -1;\n            }\n        }\n        if(cmd == 3) {\n            pair<int, int> infou = get_root_party(u);\n            pair<int, int> infov = get_root_party(v);\n            // u,v in different cluster\n            if(infou.first != infov.first) {\n                cout << 0 << endl;\n            }\n            else {\n                if(infou.second == infov.second)\n                    cout << 1 << endl;\n                else\n                    cout << 0 << endl;\n            }\n\n        }\n        if(cmd == 4) {\n            pair<int, int> infou = get_root_party(u);\n            pair<int, int> infov = get_root_party(v);\n            // u,v in different cluster\n            if(infou.first != infov.first) {\n                cout << 0 << endl;\n            }\n            else {\n                if(infou.second != infov.second)\n                    cout << 1 << endl;\n                else\n                    cout << 0 << endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "id": "graph14",
    "instruction": "小乖自救會是一個由世界各地幼稚園小孩組成的大家庭，其中有些人彼此是朋友。眼看團體愈發不團結，小圈圈愈來愈多，會長開始正視了問題。\n\n在自救會中，一個小圈圈是指 \n1. 小圈圈內的所有人和圈外人都沒有朋友關係。\n2. 小圈圈本身不能分成兩組人，兩組之間的人互相沒有朋友關係。\n\n小乖自救會時常傳出一對朋友決裂的情況，身為會長，你想時刻知道當前有幾個小圈圈以及最大的小圈圈還有多少人。\n\n輸入第一行是三個整數 $N,M,Q$，分別代表小乖自救會人數、朋友對數、事件數量，會員編號為 $1\\sim N$。\n\n接下來有 $M$ 行兩個以空白分隔的整數 $u,v$，代表 $u,v$ 是朋友。\n\n接下來有 $Q$ 行，每一行的格式皆為下列其中之一：\n\n- `1 x y`：代表 $x, y$ 兩人決裂好友關係，輸入保證當下 $x, y$ 是好友。\n- `2`：代表會長詢問當下的小圈圈數量以及最大小圈圈的人數。\n\n輸入保證 $2\\le N\\le 10^5$，$1\\le M,Q\\le 10^5$，$1\\le u,v,x,y\\le N$，$u < v, x < y$，且不會有兩組同樣的朋友對 $u,v$ 出現。\n\n對於每次會長的詢問，輸出一行兩個以空白分隔的整數，分別表示當前有多少小圈圈和最大的小圈圈有幾人。\n\n",
    "output": "#include <iostream>\n#include <set>\n#include <stack>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nset<pair<int,int> > s;\nint cmd[maxn][3];\nint fa[maxn], sz[maxn];\nint union_find(int x) {\n    return (fa[x] == x ? x : fa[x] = union_find(fa[x]));\n}\nint main() {\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N,M,Q;\n    cin >> N >> M >> Q;\n    // Initialize\n    for(int i = 1; i <= N; i++) {\n        fa[i] = i;\n        sz[i] = 1;\n    }\n    // Read input\n    for(int i = 0; i < M; i++) {\n        int u,v;\n        cin >> u >> v;\n        s.insert({u,v});\n    }\n    // Store all the operations\n    for(int i = 0; i < Q; i++) {\n        cin >> cmd[i][0];\n        if(cmd[i][0] == 1) {\n            cin >> cmd[i][1] >> cmd[i][2];\n            s.erase({cmd[i][1], cmd[i][2]});\n        }\n    }\n    // Construct the final state\n    int group_max = 1, group_cnt = N;\n    for(auto e:s) {\n        if(union_find(e.first) == union_find(e.second)) continue;\n        sz[union_find(e.first)] += sz[union_find(e.second)];\n        fa[union_find(e.second)] = union_find(e.first);\n        group_max = max(group_max, sz[union_find(e.first)]);\n        group_cnt--;\n    }\n    // Do reversely\n    stack<pair<int,int> > res;\n    for(int i = Q-1; i >= 0; i--) {\n        // If an edge links vertices from different groups, group count -= 1.\n        if(cmd[i][0] == 1) {\n            if(union_find(cmd[i][1]) == union_find(cmd[i][2])) continue;\n            sz[union_find(cmd[i][1])] += sz[union_find(cmd[i][2])];\n            fa[union_find(cmd[i][2])] = cmd[i][1];\n            group_max = max(group_max, sz[union_find(cmd[i][1])]);\n            group_cnt--;\n        }\n        if(cmd[i][0] == 2) {\n            res.push({group_cnt, group_max});\n        }\n    }\n    while(!res.empty()) {\n        cout << res.top().first << \" \" << res.top().second << '\\n';\n        res.pop();\n    }\n}\n"
  },
  {
    "id": "graph15",
    "instruction": "粉紅豬佩佩喜歡跳水坑，他會在土堆上挖坑，在坑內注入水之後開始玩跳水坑的遊戲。佩佩的庭院被劃分成 $M \\times N$ 個大小相同的方格，每個方格可能是土堆或水坑，一個水坑格子會和上下左右四個方向的水坑格子被視為一個連通的水坑，我們要幫佩佩計算庭院內共有幾個水坑以及最大的水坑站有幾個格子。\n\n除了一開始的水坑格子外，佩佩每次會指定將一個格子變成水坑格子，如果這個格子是新被挖出來的水坑格子，就有可能將附近的水坑連在一起變成一個更大的水坑。佩佩一共挖了 $K$ 次，請你計算出每一次挖了之後的水坑數與最大的水坑面積。\n\n土堆與水坑的資訊可以看成一個二維矩陣，並以 $0$ 表示土堆，以 $1$ 表示水坑，位置的標示以左上角為 $(1, 1)$，右下角為 $(M, N)$。以下是一個 $M = 3, N = 5$ 的例子，一開始的水坑資料如下：\n\n<table border=\"1\">\n    <tr><td style=\"padding:8px;\"><center> $1$ </center> </td> <td style=\"padding:8px;\"><center> $0$ </center></td> <td style=\"padding:8px;\"><center> $0$ </center></td> <td style=\"padding:8px;\"><center> $\\boldsymbol{1}$ </center></td> <td style=\"padding:8px;\"><center> $\\boldsymbol{1}$ </center></td> </tr>\n    <tr><td style=\"padding:8px;\"><center> $0$ </center> </td> <td style=\"padding:8px;\"><center> $\\boldsymbol{1}$ </center></td> <td style=\"padding:8px;\"><center> $\\boldsymbol{1}$ </center></td> <td style=\"padding:8px;\"><center> $\\color{red}{\\boldsymbol{0}}$ </center></td> <td style=\"padding:8px;\"><center> $\\boldsymbol{1}$ </center></td> </tr>\n    <tr><td style=\"padding:8px;\"><center> $\\boldsymbol{1}$ </center> </td> <td style=\"padding:8px;\"><center> $\\boldsymbol{1}$ </center></td> <td style=\"padding:8px;\"><center> $0$ </center></td> <td style=\"padding:8px;\"><center> $0$ </center></td> <td style=\"padding:8px;\"><center> $\\boldsymbol{1}$ </center></td> </tr>\n</table>\n\n<p></p>\n\n一開始有三個水坑：左上角只佔據 $1$ 格的水坑、左下有一個 $4$ 格的水坑、以及右方有一個 $4$ 格的水坑。現在假設佩佩將 $(2, 4)$ 處的土堆改成水坑（紅色粗體處），那麼左下和右方的水坑就會連接成一個大小為 $9$ 的水坑。\n\n輸入第一行有三個整數 $M, N, K (1 \\leq M, N \\leq 500, 1 \\leq K \\leq 20000)$，分別代表庭院的形狀以及事件次數。\n\n接下來 $M$ 行是庭院的資訊，每一行有 $N$ 個 $0$ 或 $1$ 的數字，順序由上至下，由左至右分別代表每一個格子的資訊。\n接下來 $K$ 行，每一行各有兩個數字 $x, y$，代表每一個被挖成水坑的位置 $(x, y)$。如果該位置本來就是水坑，則不會有任何動作發生。\n\n請輸出兩行，第一行是每次最大水坑面積的總和（包含一開始，所以共有 $K + 1$ 次）。第二行請輸出每次水坑個數的總和。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n\n  int n, m, q; cin >> n >> m >> q;\n  vector<vector<int>> grid(n, vector<int>(m));\n  for(int i = 0; i < n; i++) {\n    for(int j = 0; j < m; j++) cin >> grid[i][j];\n  }\n\n  auto ID = [&](int x, int y) {\n    return x * m + y;\n  };\n\n  const vector<int> dx = {1, -1, 0, 0};\n  const vector<int> dy = {0, 0, 1, -1};\n  auto Check = [&](int x, int y) {\n    if(x >= 0 && x < n && y >= 0 && y < m) return 1;\n    else return 0;\n  };\n\n  vector<int> p(n * m, -1), sz(n * m);\n  int max_size = 0, num = 0;\n  for(int x = 0; x < n; x++) {\n    for(int y = 0; y < m; y++) if(grid[x][y]) {\n      int id = ID(x, y);\n      p[id] = id, sz[id] = 1;\n      max_size = 1, num++;\n    }\n  }\n\n  function<int(int)> Find = [&](int x) {return p[x] == x ? x : p[x] = Find(p[x]);};\n  auto Union = [&](int x, int y) {\n    x = Find(x), y = Find(y);\n    if(x == y) return 0;\n    if(sz[x] < sz[y]) swap(x, y);\n    sz[x] += sz[y], p[y] = x;\n    max_size = max(max_size, sz[x]);\n    return 1;\n  };\n  for(int x = 0; x < n; x++) {\n    for(int y = 0; y < m; y++) {\n      int u = ID(x, y);\n      if(p[u] == -1) continue;\n      for(int o = 0; o < 4; o++) {\n        int nx = x + dx[o], ny = y + dy[o];\n        if(!Check(nx, ny)) continue;\n        int v = ID(nx, ny);\n        if(p[v] == -1) continue;\n        //cerr << \"Merge \" << u << ' ' << v << '\\n';\n        if(Union(u, v)) num--;\n      }\n    }\n  }\n\n  long long ans_size = max_size, ans_num = num;\n  //cerr << \"max_size = \" << max_size << \", num = \" << num << '\\n';\n  while(q--) {\n    int x, y; cin >> x >> y; x--, y--;\n    if(grid[x][y]) {\n      ans_size += max_size, ans_num += num;\n      continue;\n    }\n\n    grid[x][y] = 1;\n\n    int u = ID(x, y);\n    p[u] = u, sz[u] = 1;\n    max_size = max(max_size, sz[u]);\n    num++;\n\n    for(int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if(!Check(nx, ny)) continue;\n      int v = ID(nx, ny);\n      if(p[v] == -1) continue;\n      //cerr << \"Merge \" << u << ' ' << v << '\\n';\n      if(Union(u, v)) num--;\n    }\n\n    ans_size += max_size, ans_num += num;\n    //cerr << \"max_size = \" << max_size << \", num = \" << num << '\\n';\n  }\n  cout << ans_size << '\\n' << ans_num << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "id": "graph16",
    "instruction": "小風是圖書館的志工，負責處理線上預約借書等雜務。一天，有 $N$ 本不同的書被開放預約，他發現使用預約系統的 $M$ 位客人每個人都恰好預約了兩本書，由於借書系統的限制，小風需要幫這些客人進行排序，接著按照順序，每一位客人都可以成功預約到所有還沒有被其他人預約過的書，萬一一名客人所有想借的書都被借走，他就會很生氣並投訴圖書館。小風想盡量避免此事發生，所以他必須妥善安排這些客人的順位，讓來投訴圖書館的客人越少越好，你能幫助他達成目標嗎？\n\n輸入第一行包含兩個正整數 $N, M (2 \\leq N \\leq 10^5, 1 \\leq M \\leq 10^5)$，分別代表書及客人的數量。\n接下來 $M$ 行，每一行均有兩個正整數 $x, y (1 \\leq x, y \\leq N, x \\neq y)$，代表某一位客人預約的書本號碼。\n\n請輸出一個整數代表最少可能來投訴圖書館的客人數量。\n\n",
    "output": "#include <iostream>\n#include <vector>\n#include <functional>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int n, m; cin >> n >> m;\n\n  vector<int> p(n + 1);\n  for(int i = 1; i <= n; i++) p[i] = i;\n  function<int(int)> Find = [&](int x) {return p[x] == x ? x : p[x] = Find(p[x]);};\n\n  for(int i = 0; i < m; i++) {\n    int x, y; cin >> x >> y;\n    x = Find(x), y = Find(y);\n    p[x] = y;\n  }\n\n  int ans = m - n;\n  for(int i = 1; i <= n; i++) ans += p[i] == i;\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "graph17",
    "instruction": "在 TOI 國有 $N$ 種幣值，都是正整數且依照嚴格遞增的順序為 $c_1, c_2, c_3, \\dots, c_N$，而每一種幣值都有無限多個。現在，你有 $M$ 個物品，價值分別為 $p_1, p_2, p_3, \\dots, p_M$。請問你有沒有辦法用 TOI 國有的錢幣湊出每一個物品的價值呢？\n\n一個價錢 $x$ 能夠被湊得出來若且唯若存在 $N$ 個數字 $w_i$ 滿足 $w_i \\geq 0$ 且 $\\sum c_i w_i = x$。\n輸入有三行。第一行有兩個數字 $N,M(1\\leq N \\leq 60,1\\leq M \\leq 10^5)$。第二行有 $N$ 個數字 $c_i(0 < c_1 < c_2 < \\dots < c_N \\leq 10^5)$ 代表有的幣值。第三行有 $M$ 個數字 $p_i(0 \\leq p_i \\leq 10^9)$，代表有的物品的價值。\n\n請輸出一個長度為 $M$ 的字串 $S$，滿足：$S$ 的第 $i$ 個字元為 `Y` 若且唯若 $p_i$ 能夠被湊出來；否則就是 `N`。\n",
    "output": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\n#define int long long int\nusing namespace std;\n\nconst int maxC = 1e5 + 10, maxN = 1e5 + 10, INF = 1e9;\n\nstruct Dijkstra{\n\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\tint dist[maxC];\n\tbool vis[maxC];\n\tvector<pair<int, int>> adj[maxC];\n\tinline void addEdge(int u, int v, int w){ //Adds an edge from u to v with weight w\n\t\tadj[u].emplace_back(v, w);\n\t}\n\tinline void run(int st = 0){\n\t\tfill(dist, dist + maxC, INF);\n\t\tfill(vis, vis + maxC, 0);\n\t\tdist[st] = 0;\n\t\tpq = priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>();\n\t\tpq.push({0, st});\n\t\tpair<int,int> cur;\n\t\twhile(pq.size()){\n\t\t\tcur = pq.top();\n\t\t\tpq.pop();\n\t\t\tif(vis[cur.second]) continue;\n\t\t\tvis[cur.second] = true;\n\t\t\tfor(auto e : adj[cur.second]){\n\t\t\t\tif(vis[e.first]) continue;\n\t\t\t\tif(dist[e.first] > dist[cur.second] + e.second){\n\t\t\t\t\tdist[e.first] = dist[cur.second] + e.second;\n\t\t\t\t\tpq.push({dist[e.first], e.first});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} sssp;\n\nsigned main(){\n\tint N, M;\n\tint c[maxN + 10], p[maxN + 10];\n\tcin >> N >> M;\n\tfor(int i = 0; i < N; i++) cin >> c[i];\n\tfor(int i = 0; i < M; i++) cin >> p[i];\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < c[0]; j++) sssp.addEdge(j, (c[i] + j) % c[0], (c[i] + j) / c[0]);\t\n\t}\n\tsssp.run();\n\tfor(int i = 0; i < M; i++){\n\t\tif((p[i] / c[0]) >= sssp.dist[p[i] % c[0]]) cout << \"Y\";\n\t\telse cout << \"N\";\n\t}\n\tcout << endl;\n}\n"
  },
  {
    "id": "graph18",
    "instruction": "作為一個派對負責人，你想要舉辦兩場派對並邀請 $N$ 個朋友到其中一場。每個朋友都對派對有所期待，他們一共提出 $L$ 個派對應具備的特質，例如派對蛋糕上有沒有香菜。這些特質有些人贊成，也有些人反對，也有些人沒意見。你可以自由規劃派對，然而當有兩個人對某個特質意見互相衝突時 (一人贊成一人反對)，勢必會有一人感到不開心。想請問你是否能適當安排 $N$ 個朋友到兩場派對的其中一場，使得同一場派對沒有兩個人有衝突意見？\n\n本題含多筆測試資料，第一行代表測試資料筆數 $T$。\n每筆測試資料第一行是兩個空白分隔的正整數 $N, L$，分別代表朋友人數和派對特質數。\n接著有 $N$ 行每行有若干個空白分隔的整數，並恰有兩個 $0$，其中第二個 $0$ 一定在結尾。\n在第 $i$ 行第一個 $0$ 以前的正整數代表朋友 $i$ 贊成的特質，第一個 $0$ 以後第二個 $0$ 以前的正整數是朋友 $i$ 反對的特質。\n\n輸入保證 $T\\le 100$，$N\\le 1000$，$L \\leq 10^6$，派對特質編號 $1\\sim L$。假設 $S$ 是總意見數，那麼保證 $S\\le 10^5$。\n\n對於每筆測試資料輸出一行，如果可以適當安排請輸出 `Yes`，否則輸出 `No`。\n\n",
    "output": "#include <iostream>\n#include <set>\nusing namespace std;\n#define pii pair<int,int>\nconst int maxn = 1010;\nset<int> zeros[maxn], ones[maxn];\nint fa[maxn], party[maxn];\nbool valid = 1;\n// uf returns a pair {first: its head id, second: its party in bipartite graph}\npii uf(int x) {\n    if(fa[x] == x) return make_pair(x, party[x]);\n    pii res = uf(fa[x]);\n    res.second *= party[x];\n    fa[x] = res.first;\n    party[x] = party[res.first] * res.second;\n    return make_pair(fa[x], party[x] * party[fa[x]]);\n}\nvoid split(int x, int y) {\n    if(uf(x).first == uf(y).first) {\n        if(uf(x).second == uf(y).second) valid = 0;\n        return;\n    }\n    if(uf(x).second == uf(y).second) {\n        party[uf(x).first] = -party[uf(x).first];\n    }\n    fa[uf(x).first] = uf(y).first;\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T;\n    cin >> T;\n    while(T--) {\n        // Initialize\n        int n, L;\n        cin >> n >> L;\n        for(int i = 1; i <= n; i++) {\n            fa[i] = i;\n            party[i] = 1;\n        }\n        valid = 1;\n        // Read input\n        for(int i = 1; i <= n; i++) {\n            zeros[i].clear();\n            ones[i].clear();\n            int x;\n            while(cin >> x && x)\n                zeros[i].insert(x);\n            while(cin >> x && x)\n                ones[i].insert(x);\n        }\n        // Main algo\n        for(int i = 1; i <= n; i++) {\n            for(int j = 1; j < i; j++) {\n                // Find edge and split\n                for(auto p: zeros[i]) {\n                    if(ones[j].count(p))\n                        split(i, j);\n                }\n                for(auto p: ones[i]) {\n                    if(zeros[j].count(p))\n                        split(i, j);\n                }\n                if(!valid) break;\n            }\n            if(!valid) break;\n        }\n        // Output\n        if(valid) cout << \"Yes\" << '\\n';\n        else cout << \"No\" << '\\n';\n    }\n}\n"
  },
  {
    "id": "graph19",
    "instruction": "有 $N$ 個無刻度量杯分別有容量 $A_1, A_2, \\dots, A_N$，你能做的操作有：\n\n- 把某個量杯加滿水\n- 把某個量杯倒空\n- 把某量杯的水全部倒入另一量杯中，如果沒滿出來則倒光為止\n- 把某量杯的水全部倒入另一量杯中，如果滿出來則倒滿為止\n\n請問你至少要做幾次操作才能量出 $T$ 公升的水在某個量杯中。\n\n輸入第一行是一個正整數 $N$ 代表量杯數，$1\\le N\\le 4$。\n第二行有 $N$ 個空白分隔的正整數 $A_1, A_2, \\dots, A_N$ 表示量杯容量，$1\\le A_i\\le 50$。\n第三行有一個正整數 $T$ 表示目標容量，$1\\le T\\le 50$。\n\n輸出一行一個整數代表最少操作次數，如果做不到請輸出 $-1$。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nint a[6], N, T;\nset<vector<int> > visited;\nmap<vector<int>, int> mp;\nint gcd(int x, int y) {\n    while((x%=y) && (y%=x));\n    return x+y;\n}\nint bfs() {\n    vector<int> vec;\n    vec.resize(N);\n    visited.insert(vec);\n    mp[vec] = 0;\n    queue<vector<int> > q;\n    q.push(vec);\n    visited.insert(vec);\n    while(!q.empty()) {\n        vector<int> vec = q.front();\n        q.pop();\n        int steps = mp[vec] + 1;\n        for(auto k: vec) {\n            if(k == T) return mp[vec];\n        }\n        vector<int> nxt;\n        for(int i = 0; i < N; i++) {\n            nxt = vec;\n            nxt[i] = 0;\n            if(!visited.count(nxt)) {\n                q.push(nxt);\n                mp[nxt] = steps;\n                visited.insert(nxt);\n            }\n        }\n        for(int i = 0; i < N; i++) {\n            nxt = vec;\n            nxt[i] = a[i];\n            if(!visited.count(nxt)) {\n                q.push(nxt);\n                mp[nxt] = steps;\n                visited.insert(nxt);\n            }\n        }\n        for(int i = 0; i < N; i++) {\n            for(int j = 0; j < N; j++) {\n                if(i == j) continue;\n                int d = min(vec[i], a[j]-vec[j]);\n                if(d == 0) continue;\n                nxt = vec;\n                nxt[i] -= d;\n                nxt[j] += d;\n                if(!visited.count(nxt)) {\n                    q.push(nxt);\n                    mp[nxt] = steps;\n                    visited.insert(nxt);\n                }\n            }\n        }\n    }\n    return -1;\n}\nint main() {\n    cin >> N;\n    for(int i = 0; i < N; i++) {\n        cin >> a[i];\n    }\n    cin >> T;\n    cout << bfs() << endl;\n}\n"
  },
  {
    "id": "graph20",
    "instruction": "小明一覺醒來，發現自己身陷在 TOI 地下大迷宮裡，迷宮可以表示成由 $1 \\times 1$ 的神祕方格所組成的 $n \\times m$ 矩形。每一個神祕方格可能有 $0$ 到 $4$ 個門，相鄰方格的兩扇門必須要對上小明才能通過。\n小明發現自己的手上還有一個神奇的按鈕，按下去後，迷宮中所有神祕方格都會順時鐘旋轉 $90$ 度，過程消耗一單位時間。另外，移動到下一個房間也需要一單位時間，請根據地圖幫助小明計算出抵達迷宮的出口所需的最短時間。\n第一行包含兩個由空白隔開的整數 $n,m(1\\le n,m \\le 1000)$，代表 TOI 地下大迷宮的長和寬。\n接下來 $n$ 行，每行有 $m$ 個字母，用來表示迷宮地圖的樣子，字母的種類有：\n\n* «+» 代表該神秘方格有四個門分別通往上下左右的相鄰方格；\n* «-» 代表該神秘方格有兩個門分別通往左右的相鄰方格；\n* «|» 代表該神秘方格有兩個門分別通往上下的相鄰方格；\n* «^» 代表該神秘方格有一個門通往上面的相鄰方格；\n* «>» 代表該神秘方格有一個門通往右邊的相鄰方格；\n* «<» 代表該神秘方格有一個門通往左邊的相鄰方格；\n* «v» 代表該神秘方格有一個門通往下面的相鄰方格；\n* «L» 代表該神秘方格有三個門分別通往上下右的相鄰方格；\n* «R» 代表該神秘方格有三個門分別通往上下左的相鄰方格；\n* «U» 代表該神秘方格有三個門分別通往下左右的相鄰方格；\n* «D» 代表該神秘方格有三個門分別通往上左右的相鄰方格；\n* «*» 代表該神秘方格沒有門只是一塊牆壁。\n\n下一行包含兩個由空白隔開的整數 $x_s, y_s\\ (1 \\leq x_s \\leq n,\\ 1 \\leq y_s \\leq m)$ 代表小明的位置。\n最後一行包含兩個由空白隔開的整數 $x_t, y_t\\ (1 \\leq x_t \\leq n,\\ 1 \\leq y_t \\leq m)$ 代表迷宮出口的位置。\n\n保證位於小明的位置和迷宮出口的位置的神祕方塊不是牆壁。\n迷宮由上到下每行編號為 $1$ 到 $n$，由左到右每列編號為 $1$ 到 $m$。\n\n輸出一個整數，代表小明抵達迷宮的出口所需的最短時間，若小明不可能抵達出口，輸出 `-1`。\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n \nchar rotate(char c){\n    switch (c){\n    case '+':\n        return '+';\n    case '-':\n        return '|';\n    case '|':\n        return '-';\n    case '^':\n        return '>';\n    case '>':\n        return 'v';\n    case 'v':\n        return '<';\n    case '<':\n        return '^';\n    case 'L':\n        return 'U';\n    case 'R':\n        return 'D';\n    case 'U':\n        return 'R';\n    case 'D':\n        return 'L';\n    default:\n        return '*';\n    }\n    return '*';\n}\n \nchar board[4][1008][1008];\nint vis[4][1008][1008];\nint dx[4] = {1,0,0,-1};\nint dy[4] = {0,1,-1,0};\n//////////// v > < ^\n \nstruct item{\n    int d,x,y;\n};\nqueue<item> q;\nitem s,t; \n \nbool check(item &b,int dir){\n    vector<int> v;\n    switch (board[b.d][b.x][b.y]){\n    case '+':\n        v = {1,2,3,0};\n        break;\n    case '-':\n        v = {1,2};\n        break;\n    case '|':\n        v = {0,3};\n        break;\n    case '^':\n        v = {3};\n        break;\n    case '>':\n        v = {1};\n        break;\n    case 'v':\n        v = {0};\n        break;\n    case '<':\n        v = {2};\n        break;\n    case 'L':\n        v = {0,1,3};\n        break;\n    case 'R':\n        v = {0,2,3};\n        break;\n    case 'U':\n        v = {0,1,2};\n        break;\n    case 'D':\n        v = {1,2,3};\n        break;\n    default:\n        break;\n    }\n    return find(v.begin(),v.end(),dir) != v.end();\n}\n \nvoid expand(vector<int> v){\n    //cout << \"exp: \"; for(int i : v) cout << i << ' '; cout << '\\n';\n    for(int i : v){\n        item next = {s.d, s.x + dx[i], s.y + dy[i]};\n        //cout << \"expand: \" << i << ' ' << next.d << ' ' << next.x << ' ' << next.y << '\\n';\n        if(board[next.d][next.x][next.y] && board[next.d][next.x][next.y] != '*' && !~vis[next.d][next.x][next.y] && check(next, 3-i) ){\n            q.push(next);\n            vis[next.d][next.x][next.y] = vis[s.d][s.x][s.y] + 1;\n        }\n    }\n}\n \n \n \nint main(){\n    memset(vis,-1,sizeof(vis));\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    for(int i=1;i<=n;i++) cin >> (board[0][i] + 1);\n    for(int d=1;d<4;d++){\n        for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) board[d][i][j] = rotate(board[d-1][i][j]);\n    }\n    s.d = 0; \n    cin >> s.x >> s.y;\n    cin >> t.x >> t.y;\n    q.push(s);\n    vis[s.d][s.x][s.y] = 0;\n    while(!q.empty()){\n        s = q.front(); q.pop();\n        //cout << \"db: \" << s.d << ' ' << s.x << ' ' << s.y << ' ' << vis[s.d][s.x][s.y] << '\\n';\n        if(s.x == t.x && s.y == t.y) break;\n        if(!~vis[(s.d+1)%4][s.x][s.y]){\n            q.push({(s.d+1)%4,s.x,s.y});\n            vis[(s.d+1)%4][s.x][s.y] = vis[s.d][s.x][s.y] + 1;\n        }\n        switch (board[s.d][s.x][s.y])\n        {\n        case '+':\n            expand({1,2,3,0});\n            break;\n        case '-':\n            expand({1,2});\n            break;\n        case '|':\n            expand({0,3});\n            break;\n        case '^':\n            expand({3});\n            break;\n        case '>':\n            expand({1});\n            break;\n        case 'v':\n            expand({0});\n            break;\n        case '<':\n            expand({2});\n            break;\n        case 'L':\n            expand({0,1,3});\n            break;\n        case 'R':\n            expand({0,2,3});\n            break;\n        case 'U':\n            expand({0,1,2});\n            break;\n        case 'D':\n            expand({1,2,3});\n            break;\n        default:\n            break;\n        }\n    }\n    if(s.x == t.x && s.y == t.y) cout << vis[s.d][s.x][s.y] << '\\n';\n    else cout << \"-1\\n\";\n}"
  },
  {
    "id": "graph21",
    "instruction": "小黃瓜是蔬菜界的最高神，統領非常多的世界。這些世界之間有一些傳送門可以讓不同世界互相通行。小黃瓜在閒閒沒事做的時候隨便亂設了幾組傳送們，然而他發現還是有一些世界沒辦法互相通行。小黃瓜現在不想動腦，請你幫小黃瓜算一下他最少還要再設幾組傳送門才能讓所有世界互通，如果你算對了他也許會送你幾根小黃瓜作為謝禮。\n\n註：如果 A 世界與 B 世界互通，B 世界與 C 世界互通，那麼 A 世界與 C 世界互通。\n\n輸入第一行有兩個整數 $N, M$，$N$ 代表世界的數目、$M$ 代表傳送門的數目 (組)。\n接下來有 $M$ 行，每一行有兩個數字 $a, b$，$a, b$ 是世界的編號，而傳送門的兩端分別被設在 $a$ 世界與 $b$ 世界。\n\n限制：\n- $1 \\leq N, M \\leq 10^5$\n- 世界的編號從 $1$ 到 $N$\n\n輸出一個數字，代表小黃瓜還需要設幾組傳送門才能讓所有世界互通。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main ()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> edges[100001];\n\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\n\tbool visited[100001] = {};\n\n\tfunction<void(int)> traverse = [&] (int a)\n\t{\n\t\tif (visited[a]) return;\n\t\t\n\t\tvisited[a] = true;\n\t\twhile (edges[a].size())\n\t\t{\n\t\t\ttraverse(edges[a].back());\n\t\t\tedges[a].pop_back();\n\t\t}\n\t};\n\n\tint count = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!visited[i])\n\t\t{\n\t\t\tcount++;\n\t\t\ttraverse(i);\n\t\t}\n\t}\n\n\tcout << count - 1 << '\\n';\n}\n"
  },
  {
    "id": "graph22",
    "instruction": "上課中，我們有學到「Minimum Spanning Tree最小生成樹」，現在小熊手上有一些無向圖（不一定會連通喔 ><），興高采烈地求出了最小生成森林拿給老師看，老師卻說小熊沒有考慮到重邊與自環的問題，小熊十分懊惱！聰明的你可以幫助小熊，在圖有可能有重邊與自環的情況下，求出最小生成森林的邊權和嗎？\n\n第一行會輸入兩個正整數 $N$, $M$ 代表點數跟邊數\n接下來 $M$ 行每行有三個正整數 $a, b, c$，代表 $a, b$ 之間有一條權重為 $c$ 的邊\n\n* $1 \\le N \\le 2 \\cdot 10^5$\n* $1 \\le M \\le 4 \\cdot 10^5$\n* $1 \\le a, b \\le N$\n* $1 \\le c \\le 10^9$\n\n輸出只有一行，代表這個最小生成森林邊權的和。\n\n",
    "output": "#include <bits/stdc++.h>\n#define pb emplace_back\n#define int long long\nusing namespace std;\n\nstruct Edge{\n  int a, b, c;\n  Edge() {}\n};\n\nconst int MAXN = 200000;\nint N, M;\nint a, b, c;\nint dsu[MAXN+1];\nvector <Edge> E;\nint ans;\n\nint fnd(int a) {\n  return a == dsu[a] ? a : dsu[a] = fnd(dsu[a]);\n}\n\nvoid Union(int a, int b) {\n  dsu[fnd(a)] = fnd(b);\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  cin >> N >> M;\n  for (int i = 1; i <= N; i++) {\n    dsu[i] = i;\n  }\n  E.resize(M);\n  for (int i = 0; i < M; i++) {\n    auto &[a, b, c] = E[i];\n    cin >> a >> b >> c;\n  }\n  sort(E.begin(), E.end(), [](const Edge e1, const Edge e2){\n    return e1.c < e2.c;\n  });\n  for (auto [a, b, c] : E) {\n    if (fnd(a) == fnd(b)) continue;\n    ans += c;\n    Union(a, b);\n  }\n  cout << ans << '\\n';\n}"
  },
  {
    "id": "graph23",
    "instruction": "某天小 Q 發現自己在一棵陌生的樹上醒來，身為 APCSC 的學員小 Q 馬上發現這棵樹總共有 $N$ 個節點。但是，在某個節點上有一隻飢餓的獅子（對沒錯，懂圖論的獅子也會爬樹），獅子也發現了小 Q，並且以最短的路徑朝小 Q 前進。已知小 Q 與獅子每單位時間內都只能跳到相鄰的節點上，且小 Q 會選**最慢才被獅子追上**的逃生路線。每單位時間中會是小 Q 先移動，獅子再移動。請你寫個程式計算獅子最快需要移動多少步數才能抓到小 Q ？\n\n\n\n\n輸入的第一行有三個以空個分隔的數字 $N, u, v$，分別代表樹的節點數 $N$（$2\\le N \\le 10^5$）、小 Q 的初始節點編號、獅子的初始節點編號（$1\\le u,v \\le N$ 且 $u \\ne v$）。樹的節點編號是從 $1$ 到 $N$。\n\n接下來會有 $N-1$ 行，每行有兩個以空個分隔的數字 $a_i, b_i$（$1\\le a_i,b_i \\le N$），表示編號 $a_i$ 的節點與編號 $b_i$ 的節點之間有邊，即小 Q 與獅子可以在 $a_i, b_i$ 之間跳躍。\n\n輸出一個整數 $t$，表示獅子需要移動的最少步數。\n\n\n",
    "output": "// #include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n\nvoid bfs(vector<vector<int>> &t, vector<int> &dis, int s) {\n    queue<pii> q;\n    vector<int> visited(t.end()-t.begin(), 0);\n    q.push({s, 0});\n    while (!q.empty()) {\n        pii cur = q.front();\n        q.pop();\n        visited[cur.x] = 1;\n        dis[cur.x] = cur.y;\n        for (auto p: t[cur.x]) {\n            if (!visited[p]) {\n                q.push({p, cur.y+1});\n            }\n        }\n    }\n}\n\nint main() {\n    int N, u, v;\n    cin >> N >> u >> v;\n    u--, v--;\n    vector<vector<int>> t(N);\n    for (int i = 0, l, r; i < N-1; i++) {\n        cin >> l >> r;\n        l--, r--;\n        t[l].push_back(r);\n        t[r].push_back(l);\n    }\n    vector<int> dis(N, 1e7), dis2(N, 1e7);\n    \n    bfs(t, dis, u);\n    bfs(t, dis2, v);\n\n    int ans = -1;\n    for (int i = 0; i < N; i++) {\n        if (dis[i] < dis2[i]) {\n            ans = max(ans, dis2[i]);\n        }\n    }\n\n    cout << ans-1;\n\n    return 0;\n}\n"
  },
  {
    "id": "graph24",
    "instruction": "  本題改自 2020 TOI pB，原題要求嚴格次長樹直徑。\n\n  「你好阿小晨，真沒想到你可以解決樹直徑呢！\n  不過就到這裡為止了，接下來由我『非嚴格的次長樹直徑』來做為你的對手！」\n\n  沒錯，請你幫小晨找到這棵樹的非嚴格次長樹直徑。\n  更確切地說，請你先找到一條樹直徑，接者找到另外一條**不同的路徑**，使得這條新路徑的權重和越大越好。\n  請注意這條新路徑的權重和可能跟原先樹直徑一樣。\n第一行包含一個正整數 $N$ 代表節點數量。\n\n接下來 $N-1$ 行每行有三個整數 $a, b, c$，代表 $a, b$ 之間有一條權重為 $c$ 的邊。\n\n* $3 \\le N \\le 2 \\cdot 10^5$\n* $1 \\le a, b \\le N$\n* $a \\neq b$\n* $0 \\le c \\le 10^9$\n* 保證整張圖連通\n輸出一個整數，代表這個非嚴格次長樹直徑的長度。\n",
    "output": "#include <iostream>\n#include <vector>\nusing namespace std ;\n\nusing ll = long long ;\nusing pii = pair<int,int> ;\nconst int N = 200010 ;\nvector<pii> G[N] ;\nll dis[N] ;\nbool flag[N], isLeaf[N] ;\nint n ;\n\nvoid dfs(int x, int p) {\n  for(auto i:G[x]) {\n    if(i.first != p && !flag[i.first]) {\n      dis[i.first] = dis[x] + i.second ;\n      dfs(i.first, x) ;\n    }\n  }\n}\n\nint cal(int x) {\n  for(int i=1; i<=n; ++i)\n    dis[i] = 0 ; \n  dfs(x, 0) ;\n  int ret = x ;\n  for(int i=1; i<=n; ++i)\n    if(dis[ret] < dis[i] && isLeaf[i]) \n      ret = i ;\n  return ret ;\n}\n\nint main() {\n  cin >> n ;\n\n  for(int i=1; i<n; ++i) {\n    int a, b, c ;\n    cin >> a >> b >> c ;\n    G[a].emplace_back(b, c) ;\n    G[b].emplace_back(a, c) ;\n  }\n\n  for(int i=1; i<=n; ++i)\n    if(G[i].size() == 1)\n      isLeaf[i] = true ;\n\n  int pa = cal(1) ;\n  int pb = cal(pa) ;\n\n  ll ans = 0 ;\n  flag[pa] = true ;\n  isLeaf[G[pa][0].first] = true ;\n  ans = max(ans, dis[cal(cal(pb))]) ;\n  \n  flag[pa] = false ;\n  isLeaf[G[pa][0].first] = false ;\n  flag[pb] = true ;\n  isLeaf[G[pb][0].first] = true ;\n  ans = max(ans, dis[cal(cal(pa))]) ;\n\n  cout << ans << endl ;\n}\n"
  },
  {
    "id": "graph25",
    "instruction": "身為大地主的小 Q，有 n （$1\\le n\\le 2000$）座座標為 $(x_i,y_i)$ 的農田（$1\\le x_i,y_i\\le 10^6$）。某天小 Q 心血來潮想為他廣大的農田設置一套水利系統。已知小 Q 可以建造取水站、水管等兩種設施：\n\n- 取水站：在第 $i$ 座農田上設置取水站將會花費 $c_i$ 元（$1\\le c_i\\le 10^9$），可以供給該農田本身以及其他與該農田以水管相連的農田水源。\n- 水管：已知水管只能為水平或鉛直的方向，因此建造由農田 $i$ 連至農田 $j$ 的水管會需要長度為 $\\mid x_i-x_j\\mid + \\mid y_i-y_j\\mid$ 單位長的水管，且每單位長的造價為 $k_i+k_j$（$1\\le k_i,k_j\\le 10^9$）\n\n已知每個農田都要有水源，且兩條水管的路徑之間彼此可以交叉重疊，一條水管只能用於連接兩座農田。\n\n由於大地主小 Q 實在是擁有太多農地了，因此小 Q 想請你幫他寫一支程式來求出**最少要花多少錢**設計此套水利系統，以及取水站與水管的位置。\n\n若有多種可以花最少錢設計的水利系統，輸出任意一種系統配置即可。\n\n第一行輸入只有一個正整數 $n$（$1\\le n\\le 2000$），代表農田的數目。\n\n在接下來的 $n$ 行中，每行有兩個以空白分開的數字 $x_i,y_i$（$1\\le x_i,y_i \\le 10^6$）代表第 $i$ 座農田的座標。\n\n輸入的再下一行包含 $n$ 個以空白分開的正整數 $c_i$（$1\\le c_i \\le 10^9$）代表在第 $i$ 座農田建造取水站的花費。\n\n最後一行包含 $n$ 個以空白分開的正整數 $k_i$（$1\\le k_i \\le 10^9$），用於計算在建造與第 $i$ 座農田相連的水管時的係數。\n\n輸出的第一行為一個正整數，代表建造此水利系統的最小花費。\n\n下一行請輸出一個正整數 $v$，代表總共需建造 $v$ 個取水站。\n\n再下一行請輸出 $v$ 個以空白分隔的整數，代表建造取水站的農田編號 $v_i$，可以以任意順序輸出。\n\n下一行請輸出一個正整數 $e$，代表總共建造的水管數 $e$。\n\n最後請輸出 $e$ 行以空格分開的數對 $a, b$（$1\\le a,b \\le n, a\\ne b$）表示連接農地 $a,b$ 的水管，這些數對也可以用任意順序輸出。\n\n若有多個可以達到最小花費的水利設施配置，則輸出任意一組解答即可。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii=pair<int,int>;\n#define x first\n#define y second\n\nint main() {\n    int n = 0;\n    vector<pii> points;\n    vector<long long> c, k;\n\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        long long x, y;\n        cin >> x >> y;\n        points.push_back({x,y});\n    }\n    for (int i = 0; i < n; i++) {\n        long long tmp;\n        cin >> tmp;\n        c.push_back(tmp);\n    }\n    for (int i = 0; i < n; i++) {\n        long long tmp;\n        cin >> tmp;\n        k.push_back(tmp);\n    }\n\n    vector<vector<long long>> w(n+1, vector<long long>(n+1, -1));\n    vector<long long> dis(n+1, 0);\n    for (int i = 1; i <= n; i++) {\n        for (int j = i+1; j <= n; j++) {\n            w[i][j] = w[j][i] = (abs(points[i-1].x - points[j-1].x)+abs(points[i-1].y - points[j-1].y)) * (k[i-1]+k[j-1]);\n        }\n        w[i][0] = w[0][i] = c[i-1];\n        dis[i] = 1e18;\n    }\n\n    vector<int> done(n+1, 0);\n    vector<int> par(n+1);\n    vector<pii> mst;\n    vector<int> powerStation;\n    long long ans = 0;\n\n    for (int i = 0; i <= n; i++) {\n        long long m = 1e18;\n        int idx = -1;\n        for (int j = 0; j <= n; j++) {\n            if (!done[j] && dis[j] < m) {\n                idx = j;\n                m = dis[j];\n            }\n        }\n\n        done[idx] = 1;\n        ans += dis[idx];\n        if (idx == 0) {\n            par.push_back(-1);\n        }\n        else {\n            if (par[idx] != 0)\n                mst.push_back({par[idx], idx});\n            else\n                powerStation.push_back(idx);\n        }\n\n        for (int j = 0; j <= n; j++) {\n            if (dis[j] > w[j][idx]) {\n                dis[j] = w[j][idx];\n                par[j] = idx;\n            }\n        }\n    }\n    cout << ans << endl << powerStation.end() - powerStation.begin() << endl;\n    for (int &num: powerStation) cout << num << ' ';\n    cout << endl << mst.end() - mst.begin() << endl;\n    for (auto pp: mst) {\n        cout << pp.x << ' ' << pp.y << endl;\n    }\n}"
  },
  {
    "id": "graph26",
    "instruction": "現在有一張 $N$ 個點 $M$ 條邊的有向圖，代表有 $N$ 個城市 ( 編號 $1$ 到 $N$ )， 由 $M$ 條有向道路連接 ( 城市之間有可能不連通，無法抵達 )。 \n每條道路都有各自的長度。請你設計一份程式計算從城市 $S$ 出發抵達城市 $T$ 的最短路徑。若無法抵達，請輸出 $-1$。\n第一行包含兩個正整數 $N$, $M$ 以空白隔開，代表有 $N$ 座城市，有 $M$ 條道路\n第 $2$ 行至第 $M+1$ 行，每行有三個正整數 $a$, $b$, $c$ 以空白隔開，代表城市 $a$ 有一條長度為 $c$ 的單向道路通往城市 $b$。\n第 $M+2$ 行包含兩個正整數 $S$, $T$\n\n$1 \\le N \\le 10^5$\n$1 \\le M \\le 10^5$\n$1 \\le a,b,S,T \\le N$ 且 $a \\neq b$\n$1 \\le c \\le 10^9$\n\n輸出 1 個正整數代表從城市 $S$ 出發抵達城市 $T$ 的最短路徑長度。若無法抵達，請輸出 $-1$。\n",
    "output": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 100008;\nconst long long INF = (long long)1e18 + 8;\nvector<pair<int,int> > v[N];\nlong long dis[N];\nbitset<N> vis;\n\nlong long dijk(int s,int t){\n\tdis[s] = 0;\n\tpriority_queue<pair<long long,int>,vector<pair<long long,int> >, greater<pair<long long,int> > > pq;\n\tpq.push({dis[s],s});\n\twhile(!pq.empty()){\n\t\tauto x = pq.top(); pq.pop();\n\t\twhile(pq.size() && vis[x.second]) x = pq.top(), pq.pop();\n\t\tif(x.second == t) return dis[t];\n\t\tvis[x.second] = 1;\n\t\tfor(auto i : v[x.second]) if(dis[i.first] > dis[x.second] + i.second){\n\t\t\tdis[i.first] = dis[x.second] + i.second;\n\t\t\tpq.push({dis[i.first],i.first});\n\t\t}\n\t}\n\treturn dis[t];\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m, a, b, c, s, t; // add a super source\n    cin >> n >> m;\n    fill(dis, dis+n+1, INF);\n    for(int i=1;i<=m;i++) {\n        cin >> a >> b >> c;\n        v[a].emplace_back(b, c);\n    }\n    cin >> s >> t;\n    long long ans = dijk(s,t);\n    if(ans < INF) cout << ans << '\\n';\n    else cout << \"-1\\n\";\n}"
  },
  {
    "id": "graph27",
    "instruction": "現在有一張 $N$ 個點 $M$ 條邊的有向圖，代表有 $N$ 個城市（編號 $1$ 到 $N$）， 由 $M$ 條有向道路連接（城市之間有可能不連通，無法抵達）。 \n小 D 是一個旅行商人，他會在旅途的同時做生意賺錢。而且小 D 非常精明，他在地圖上紀錄好了經過每條道路他可以獲利多少錢，但是由於有山賊出沒，有些道路的獲利可能是負的。\n\n小 D 好奇是否存在一條從**某城市出發，且最後回到該城市**的旅途可以保證賺到錢，同一條道路可以重複經過。請你寫程式幫助小 D 發大財。\n\n第一行包含兩個整數 $N, M$ 以空白隔開，代表有 $N$ 座城市，有 $M$ 條道路。\n第二行至第 $M+1$ 行，每行有三個數字 $a, b, c$ 以空白隔開，代表城市 $a$ 和城市 $b$ 之間有一條可以獲利 $c$ 元的單向道路。\n\n- $3 \\le N \\le 2000$\n- $1 \\le M \\le \\min(N(N-1),\\ 2000)$\n- $1 \\le a,b \\le N$ 且 $a \\neq b$\n- $|c| \\le 10^4$\n- 所有 $(a, b)$ 的有序對（順序重要，$(a, b)$ 和 $(b, a)$ 不同）不重覆。\n\n輸出一行 `YES` 或 `NO` 代表是否存在一條從某城市出發，且最後回到該城市的旅途可以保證賺到錢。\n\n",
    "output": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 5005;\nint u[N], v[N], w[N];\nint dis[N];\nbool flag;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m, source = 0; // add a super source\n    cin >> n >> m;\n    fill(dis+1, dis+n+1, (int)1e9); // initial distance\n    for(int i=1;i<=m;i++) {\n        cin >> u[i] >> v[i] >> w[i];\n        w[i] = -w[i]; // find a cycle that is \"profitable\"\n    }\n    for(int i=1;i<=n;i++){\n        u[m+i] = source; v[m+i] = i; w[m+i] = 0;\n    }\n    // Bellman-Fold\n    for(int ep=1;ep<=n;ep++) for(int i=1;i<=m+n;i++)\n        dis[v[i]] = min(dis[v[i]], dis[u[i]] + w[i]);    \n    // Negative Cycle Step\n    for(int i=1;i<=m+n;i++) flag |= (dis[v[i]] > dis[u[i]] + w[i]);\n    if(flag) cout << \"YES\\n\";\n    else cout << \"NO\\n\";\n}"
  },
  {
    "id": "graph28",
    "instruction": "現在有一張 $N$ 個點 $M$ 條邊的無向圖，代表有 $N$ 個城市（編號 $1$ 到 $N$），由 $M$ 條道路連接。\n每條道路都有各自的長度，兩個城市 $s$ 和 $t$ 的距離為從 $s$ 到 $t$ 要經過的所有道路長度總和。\n注意有可能不存在任何道路可以從某個城市 $s$ 出發抵達另個城市 $t$。\n\n現在請你輸出從每座城市出發，在行駛距離不超過 $K$ 的前提下，能到達哪些城市？\n\n第一行包含三個整數 $N$, $M$, $K$ 以空白隔開，代表有 $N$ 座城市，有 $M$ 條道路\n第二行至第 $M+1$ 行，每行有三個數字 $a$, $b$, $c$ 以空白隔開，代表城市 $a$ 和城市 $b$ 之間有一條長度為 $c$ 的雙向道路。\n\n- $3 \\le N \\le 500$\n- $1 \\le M \\le \\frac{N(N-1)}{2}$\n- $1 \\le K \\le 10^9$\n- $1 \\le a,b \\le N$ 且 $a \\neq b$\n- $1 \\le c \\le 10^4$\n- 所有 $(a, b)$ 的無序對（順序不重要，$(a, b)$ 和 $(b, a)$ 視為相同）不重覆。\n\n輸出 $N$ 行。\n第 $i$ 行輸出從編號為 $i$ 的城市出發，在行駛距離不超過 $K$ 的前提下，能到達的城市編號。\n城市編號請由小到大輸出並以空白隔開。\n",
    "output": "#include<bits/stdc++.h>\nusing namespace std;\nlong long dp[505][505];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n,m,k,a,b,c;\n    cin >> n >> m >> k;\n    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++){\n        if(i == j) dp[i][j] = 0;\n        else dp[i][j] = (long long)1e10+1;\n    }\n    for(int i=1;i<=m;i++) {\n        cin >> a >> b >> c;\n        dp[a][b] = dp[b][a] = c;\n    }\n    for(int s=1;s<=n;s++) for(int i=1;i<=n;i++) for(int j=1;j<=n;j++){\n        dp[i][j] = min(dp[i][j], dp[i][s] + dp[s][j]);\n    }\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) if(dp[i][j] <= k){\n            cout << j << ' ';\n        }\n        cout << '\\n';\n    }\n}"
  },
  {
    "id": "graph29",
    "instruction": "充滿戰亂的福文大地上共有 $N$ 座城市，城市之間共有 $M$ 條雙向道路。\n每次經過一條道路，就會被駐守在該地的聯盟軍攻擊，損失 $C_i$ 的血量。\n同時每經過一座城市，就會被收取 $f_i$ 的過路費 （包括起點和終點）。\n\n小晨攜帶著蒂瑪西亞人民的希望，從城市 $1$ 出發，要穿越重重危險到達城市 $N$ 尋求戰力支援。\n出發時小晨的血量為 $H$ ，請你考慮所有血量不降到負數且到達城市 $N$ 的的路線中，能最小化路線上「最多的那次城市過路費」的路線並輸出該費用。\n如果無論如何小晨都無法順利到達城市 $N$，請你輸出 $-1$。\n\n第一行包含三個正整數 $N$, $M$, $H$ 以空白隔開，代表有 $N$ 座城市，有 $M$ 條道路，小晨的血量為 $H$。\n接下來有 $n$ 行，每行一個正整數 $f_i$，表示經過城市 $i$ 會被收取 $f_i$ 的過路費。\n再接下來有 $m$ 行，每行有三個正整數 $a$, $b$, $c$ 以空白隔開，代表城市 $a$ 和城市 $b$ 之間有一條道路。如果從城市 $a$ 到城市 $b$，或者從城市 $b$ 到城市 $a$ 會損失 $c$ 的血量。\n\n* $N \\le 10^4$\n* $M \\le 5\\times 10^4$\n* $1 \\le a,b \\le N$ 且 $a \\neq b$\n* $H,c,f_i \\le 10^9$\n\n輸出一個整數代表所經過的所有城市中「最多的那次城市過路費」的最小值\n如果無法抵達，請輸出 $-1$。\n",
    "output": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 10005;\nvector<pair<int,int> > v[N];\nint f[N];\nlong long dis[N];\nvector<int> f_sorted;\nbitset<N> inq;\n\nbool spfa(int n,int fm, int h){\n    if(f[1] > fm) return false;\n    fill(dis+1, dis+n+1, h+1);\n    dis[1] = 0;\n    inq.reset();\n    queue<int> q;\n    q.push(1);\n    inq[1] = 1;\n    while(!q.empty() && dis[n] > h){\n        int x = q.front(); q.pop();\n        //cout << q.size() << ' ' << x << ' ' << dis[x] << '\\n';\n        inq[x] = 0; \n        for(auto &pr : v[x]){\n            //if(x == 1) cout << pr.first << ' ' << pr.second << ' ' << f[pr.first] << ' ' << fm << '\\n';\n            if(dis[pr.first] > dis[x] + pr.second && f[pr.first] <= fm){\n                dis[pr.first] = dis[x] + pr.second;\n                if(!inq[pr.first]) {\n                    q.push(pr.first);\n                    inq[pr.first] = 1;\n                }\n            }\n        }\n    }\n    //cout << q.size() << ' ' << fm << ' ' << h << ' '<< dis[n] << '\\n';\n    return dis[n] <= h;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m, h, a, b, c; \n    cin >> n >> m >> h; \n    for(int i=1;i<=n;i++) {\n        cin >> f[i];\n        f_sorted.emplace_back(f[i]);\n    }\n    sort(f_sorted.begin(), f_sorted.end());\n    f_sorted.resize(unique(f_sorted.begin(), f_sorted.end()) - f_sorted.begin());\n    for(int i=0;i<m;i++){\n        cin >> a >> b >> c;\n        v[a].emplace_back(b, c);\n        v[b].emplace_back(a, c);\n    }\n    if(!spfa(n, f_sorted.back()+1, h)){\n        cout << \"-1\\n\";\n        return 0;\n    }\n    int l = 0, r = (int)f_sorted.size();\n    while (l != r)\n    {\n        int md = (l+r) >> 1;\n        int fm = f_sorted[md];\n        if(spfa(n, fm, h)) r = md;\n        else l = md+1;\n    }\n    cout << f_sorted[l] << '\\n';\n    return 0;\n}"
  },
  {
    "id": "graph30",
    "instruction": "給你一個有向圖（directed graph），請問該圖的最小圈（cycle）長度為何？\n\n輸入檔的第一列有兩個正整數 $n$, $m$ ，代表該圖的點數和邊數。\n頂點的編號從 $1$ 到 $n$。\n接下來有 $m$ 列，每列用兩個整數 $i,j$（$1\\le i,j \\le n$）描述一條有向邊，從編號 $i$ 到編號 $j$。\n你可以假設輸入的圖不會有自環（self-cycle）的出現。\n\n* $1 \\le n \\le 500$\n* $1 \\le m \\le n(n-1)$\n\n對於每筆測試資料，請輸出最小圈的邊長。如果該圖沒有圈，請輸出 $0$。\n\n",
    "output": "#include<bits/stdc++.h>\n#include<stdint.h>\nusing namespace std;\n#define IOS {cin.tie(0);ios_base::sync_with_stdio(false);}\n#define N 2506\n\nvector<int> v[N];\nbitset<N> in,out;\nint dis[N],ans;\n\nvoid dfs(int x,int p){\n\tif(x == p) dis[x] = 0;\n\telse dis[x] = dis[p] + 1;\n\tin[x] = 1;\n\tout[x] = 0;\n\tfor(int i : v[x]) {\n\t\tif(!in[i] || dis[i] > dis[x] + 1) dfs(i,x);\n\t\telse{\n\t\t\tif(!out[i]) ans = min(dis[x] - dis[i] + 1,ans);\n\t\t}\n\t}\n\tout[x] = 1;\n}\n\nint main()\n{\n\tIOS;\n\tint n,m,a,b;\n\twhile(cin >> n >> m && (n|m)){\n\t\tfor(int i=1;i<=n;i++) v[i].clear();\n\t\tin.reset();\n\t\tout.reset();\n\t\tmemset(dis,0,sizeof(dis));\n\t\tans = N;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a >> b;\n\t\t\tv[a].push_back(b);\n\t\t}\n\t\tfor(int i=1;i<=n;i++) if(!in[i]) dfs(i,i);\n\t\tif(ans == N) cout << 0 << '\\n';\n\t\telse cout << ans << '\\n';\n\t}\n   return 0;\n}\n"
  },
  {
    "id": "graph31",
    "instruction": "你聽你的同學說他前陣子參加了7/19-7/24的2022臺大資訊營《早安美資程》，並玩了有趣的RPG闖關遊戲。他說起了之前玩遊戲的故事：\n\n「\n我們那套遊戲有 $N$ 道關卡，比賽的規則就是看哪個小隊先解完所有 $N$ 道關卡。只要完成第 $i$ 關，就會獲得 $i$ 號道具──這些道具是用來解鎖更多關卡用的。\n\n瞭解這個遊戲架構後，大關主在遊戲開始前給我們每個小隊一張通關祕笈，祕笈上有 $M + 1$ 條規則，前 $M$ 條規則每條的格式都是『必須要有道具 $a$ 才能解鎖關卡 $b$ 』。\n\n而最後一條（第 $M + 1$ 條規則）寫著：『除了上述的 $M$ 條規則以外，沒有其他能阻止你們解鎖關卡的障礙了... 去闖吧！』\n\n我們那隊太興奮地去闖關了所以幾乎沒有讀那個複雜的祕笈。因為這樣，我們常常跑個大老遠卻到了還沒解鎖的關卡，於是往前追溯需要的道具又發現能拿那個道具的關卡根本也還沒解鎖，總之我們就這樣玩得亂七八糟的 QQ\n」\n\n「如果能重來一遍呢？你會怎麼做？」你問道。\n\n「呃...」他沉默了一陣子。\n\n「要不要寫成表格？」\n\n他莞爾一笑，「我寫歌。」\n\n第一行會包含兩個以空白分隔的正整數 $N, M$，代表關卡的數量和規則的數量。\n接下來 $M$ 行都會是兩個以空白分隔的正整數 $a_i, b_i$，代表第 $i$ 條規則的具體內容是「必須要有道具 $a_i$ 才能解鎖關卡 $b_i$」。\n\n* $1 \\leq N \\leq 10^5$\n* $1 \\leq M \\leq 2 \\cdot 10^5$\n* $1 \\leq a_i, b_i \\leq N, \\forall i = 1, 2, \\ldots, N$\n\n他講完好冷的笑話之後，你提議可以寫好一個計畫好的闖關順序，只要按照這個順序闖關，就可以完成所有 $N$ 道關卡且不會在任何一個關卡吃閉門羹。\n\n如果這個計畫是可行的，請在第一行輸出`POSSIBLE`；反之，請在第一行輸出`IMPOSSIBLE`。\n\n如果這個計畫是可行的，請在第二行具體提出一種順序：輸出 $N$ 個以空白分隔的正整數 $p_1, p_2, \\ldots, p_N$ ，代表只要先闖第 $p_1$ 關、接著闖第 $p_2$ 關、...、最後闖第 $p_N$ 關，便可以過程不碰壁地完成所有 $N$ 道關卡。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m; cin >> n >> m;\n    vector<vector<int>> g(n + 1);\n    vector<int> indeg(n + 1);\n    for (int i = 0; i < m; i++){\n        int a, b; cin >> a >> b;\n        g[a].push_back(b);\n        indeg[b]++;\n    }\n    queue<int> q;\n    for (int i = 1; i <= n; i++)\n        if (indeg[i] == 0)\n            q.push(i);\n    vector<int> ans;\n    while (!q.empty()){\n        int x = q.front();\n        q.pop();\n        ans.push_back(x);\n        for (int y : g[x])\n            if (--indeg[y] == 0)\n                q.push(y);\n    }\n    if ((int)ans.size() < n)\n        cout << \"IMPOSSIBLE\\n\";\n    else {\n        cout << \"POSSIBLE\\n\";\n        for (int i = 0; i < n; i++)\n            cout << ans[i] << \" \\n\"[i == n - 1];\n    }\n    return 0;\n}\n"
  },
  {
    "id": "graph32",
    "instruction": "甘蔗有一本神秘筆記本，裡面寫滿了許多人的名字。有一天甘蔗發現筆記本裡面的人名順序太過混亂，所以他想好好做個排序，然而求新求變的甘蔗認為每次都按照舊有的字典序排序太無聊了，所以決定先打亂各個字母的順序，然後再把新的字母順序應用到字典序上進行排序。\n\n可是當甘蔗排完之後才發現，他忘記新的字母順序了，所以他決定請你寫一支程式來幫助他找到任意一組符合甘蔗的排序方式的字母順序，如果沒有一種字母順序符合，就代表甘蔗排錯了，此時請好好糾正他。\n\n第一行有一個正整數 $n\\ (1\\le n\\le 100)$ 代表筆記本中名字的數量。\n接下來有 $n$ 行，其中的第 $i$ 行有一個以小寫英文字母所組成的字串 $s$（$s$ 的長度不超過 $100$），代表筆記本中第 $i$ 個名字。\n\n輸出佔一行，如果存在字母順序符合甘蔗的排序方式，請輸出任意一組；否則請輸出 `sugar cane is thunderous`。\n\n",
    "output": "#include <bits/stdc++.h>\n\n#define ALPHA_CNT 26\n\nusing namespace std;\n\nint alpha_table[ALPHA_CNT][ALPHA_CNT] = {};\n\nint main() {\n    int n;\n    int is_possible = 1;\n    cin >> n;\n    string prev = \"\";\n    while (n--) {\n        string input;\n        cin >> input;\n        int len = min(prev.size(), input.size());\n\n        char small = 'a', large = 'a';\n\n        for (int i = 0; i < len; ++i) {\n            if (prev[i] != input[i]) {\n                small = prev[i];\n                large = input[i];\n                break;\n            }\n        }\n\n        if (small != large) {\n            alpha_table[small - 'a'][large - 'a'] = 1;\n        }\n        else if (prev.size() > input.size()) {\n            is_possible = 0;\n        }\n        prev = input;\n    }\n\n    char ret[ALPHA_CNT] = {};\n    int is_used[ALPHA_CNT] = {};\n    for (int l = 0; l < ALPHA_CNT; ++l) {\n        for (int i = 0; i < ALPHA_CNT; ++i) {\n            if (is_used[i])\n                continue;\n\n            int in_deg = 0;\n            for (int j = 0; j < ALPHA_CNT; ++j) {\n                if (alpha_table[j][i])\n                    in_deg++;\n            }\n\n            if (in_deg == 0) {\n                for (int j = 0; j < ALPHA_CNT; ++j) {\n                    alpha_table[i][j] = 0;\n                }\n                is_used[i] = 1;\n                ret[l] = 'a' + i;\n                break;\n            }\n        }\n    }\n\n    for (int i = 0; i < ALPHA_CNT; ++i) {\n        if (!is_used[i]) {\n            is_possible = 0;\n        }\n    }\n\n    if (is_possible) {\n        for (char c : ret) {\n            cout << c;\n        }\n        cout << '\\n';\n    }\n    else {\n        cout << \"sugar cane is thunderous\\n\";\n    }\n}\n"
  },
  {
    "id": "graph33",
    "instruction": "實驗室警鈴大作，你聽廣播後得知在$t$秒前，位於$V$有人不小心將試管打破，導致病毒外漏。該病毒傳播迅速，如果在某個時間內某個區域已經有病毒，則下一秒病毒就會擴散到相鄰的區域。因為該種病毒很怕陽光，所以有陽光的區域不會有病毒。整個實驗室唯一有陽光的地方是$S$，你現在在$P$，你決定逃到$S$，等待救援。你每秒只能從當前的區域移動到相鄰的區域，並且你不想到有病毒的區域，因為沒有人知道這個病毒的副作用是什麼。\n\n第一行有三個整數$n, m, t,\\ (1\\leq n, m\\leq1000,\\ 0\\leq t\\leq1000000)$，代表實驗室的大小為$n\\times m$，並且$t$秒前試管被打破。\n接下來有$n$行，每行是一個長度為$m$的字串。這$n$行是實驗室的地圖，左上角為$(0, 0)$，右下角是$(n-1, m-1)$，標記為*的是牆壁，人和病毒都不能通行；標記為$P$的是你現在的位置；標記為$V$的是病毒外漏的區域；標記為$S$的是有陽光的區域；剩下的區域則標記為.。\n\n若可以到達$S$，請輸出最少需要幾秒；若無法到達$S$，請輸出\"Goodbye world!\"。\n\n",
    "output": "#include <bits/stdc++.h>\n//#define special 1\nusing namespace std;\n#define kN 1003\n#define oo 1000000007\n\nstruct P{\n    int x, y, t;\n    P(){}\n    P(int x, int y):x(x), y(y){}\n    P(int x, int y, int t):x(x), y(y), t(t){}\n    int operator-(const P r)const{return abs(x-r.x)+abs(y-r.y);}\n};\n\nbool M[kN][kN], used[kN][kN];\nP F, S, E; int T, wid, hei, dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1}, ans, d[kN][kN];\nqueue<P> bfs;\n#ifdef special\nstring dm=\"*****************\\\n*...*.......**..*\\\n**..*....*.*.*..*\\\n*......*.**.**.**\\\n*..**...**..**.**\\\n**.....**..*.*..*\\\n*....*..........*\\\n*.....****.*...**\\\n****.*.*........*\\\n*****************\";\n#endif\n\nsigned main(){\n#ifdef special\n    wid=10, hei=17;\n    for(int i=0; i<wid; ++i)for(int j=0; j<hei; ++j)M[i][j]=dm[i*hei+j]=='*';\n#else\n    cin>>wid>>hei>>T;\n    string s;\n    for(int i=0; i<wid; ++i){\n        cin>>s;\n        assert(s.size()==hei);\n        for(int j=0; j<hei; ++j){\n            M[i][j]=s[j]=='*';\n            if(s[j]=='P')S=P(i, j);\n            else if(s[j]=='S')E=P(i, j);\n            else if(s[j]=='V')F=P(i, j);\n        }\n    }\n#endif\n    //for(int i=0; i<wid; ++i)for(int j=0; j<hei; ++j)cout<<M[i][j]<<\" \\n\"[j==hei-1];\n    for(int i=0; i<wid; ++i)for(int j=0; j<hei; ++j)used[i][j]=0, d[i][j]=oo;\n#ifdef special\n    cin>>F.x>>F.y>>T>>S.x>>S.y>>E.x>>E.y;\n#endif\n    d[F.x][F.y]=0, bfs.push(F), used[F.x][F.y]=1;\n    while(!bfs.empty()){\n        P a=bfs.front(); bfs.pop();\n        for(int i=0; i<4; ++i){\n            P b=P(a.x+dx[i], a.y+dy[i]);\n            if(b.x<0||b.x>=wid||b.y<0||b.y>=hei)continue;\n            if(!used[b.x][b.y]&&!M[b.x][b.y]&&(b.x!=E.x||b.y!=E.y))bfs.push(b), d[b.x][b.y]=d[a.x][a.y]+1, used[b.x][b.y]=1;\n        }\n    }\n    //for(int i=0; i<wid; ++i)for(int j=0; j<hei; ++j)cout<<setw(10)<<d[i][j]<<\" \\n\"[j==hei-1];\n    for(int i=0; i<wid; ++i)for(int j=0; j<hei; ++j)used[i][j]=0;\n    S.t=T, bfs.push(S), used[S.x][S.y]=1, ans=-1, d[E.x][E.y]=oo;\n    while(!bfs.empty()){\n        P a=bfs.front(); bfs.pop();\n        //cout<<a.x<<' '<<a.y<<endl;\n        for(int i=0; i<4; ++i){\n            P b=P(a.x+dx[i], a.y+dy[i], a.t+1);\n            if(b.x<0||b.x>=wid||b.y<0||b.y>=hei)continue;\n            if(!used[b.x][b.y]&&!M[b.x][b.y]&&d[b.x][b.y]>b.t){\n                bfs.push(b), used[b.x][b.y]=1;\n                if(b.x==E.x&&b.y==E.y)ans=b.t-T;\n                //cout<<b.x<<' '<<b.y<<endl;\n            }\n            //cout<<F-b<<' '<<i<<endl;\n            if(ans!=-1)break;\n        }\n        if(ans!=-1)break;\n    }\n    if(d[S.x][S.y]<=T)ans=-1;\n    if(ans==-1)cout<<\"Goodbye world!\\n\";\n    else cout<<ans<<endl;\n}\n"
  },
  {
    "id": "greedy01",
    "instruction": "本題改編自 2016 年 10 月 APCS 考古題。\n\n玫瑰班的小孩們喜歡吃糖果，他們想比賽誰能從家裡帶來最大的糖果袋。一共有 $N$ 個小孩加入比賽，且每個小孩家裡都各有 $M$ 個容量不一的糖果袋。在第二天，這 $N$ 個小孩會從家裡選出最大的糖果袋裝滿糖果並帶來班上。此外還有一個特別規則，如果一個糖果袋容量整除現場總糖果數，那該糖果袋會被加冕為完美糖果袋。\n\n請你求出帶來班上的一共有幾個糖果，並且有哪些糖果袋是完美糖果袋。\n\n輸入第一行是兩個空白分隔的數字 $N, M$，分別代表參戰人數和每人家中有多少糖果袋。\n\n接著有 $N$ 行每行 $M$ 個空白分隔的數字 $a_{ij}$，第 $i$ 行代表第 $i$ 個人家中的所有糖果袋容量（$1 \\leq i \\leq N$、$1 \\leq j \\leq M$）。\n\n對於 $20\\%$ 的輸入保證 $1\\le N\\le 20$，$M = 1$。\n對於 $30\\%$ 的輸入保證 $1\\le N\\le 20$，$M = 2$。\n對於全部輸入保證 $1\\le N, M\\le 20$，$1\\le a_{ij}\\le 256$。\n\n輸出第一行是一個整數代表帶來班上的總糖果數。\n\n第二行是所有完美糖果袋的容量，如果有多個請依照將他帶來的人的編號順序排序，數字間以空白分隔。如果沒有任何完美糖果袋，請在該行輸出 $-1$。\n\n",
    "output": "#include <iostream>\nusing namespace std;\nint a[30][30];\nint main() {\n    int n,m;\n    cin >> n >> m;\n    int sum = 0;\n    for(int i = 0; i < n; i++) {\n        int mx = 0;\n        for(int j = 0; j < m; j++) {\n            cin >> a[i][j];\n            mx = max(mx, a[i][j]);\n        }\n        sum += mx;\n    }\n    cout << sum << endl;\n    int printed = 0;\n    for(int i = 0; i < n; i++) {\n        int mx = 0;\n        for(int j = 0; j < m; j++) {\n            mx = max(mx, a[i][j]);\n        }\n        if(sum % mx == 0) {\n            if(!printed) {\n                printed = 1;\n            }\n            else cout << \" \";\n            cout << mx;\n        }\n    }\n    if(!printed) cout << -1;\n    cout << endl;\n\n}\n"
  },
  {
    "id": "greedy02",
    "instruction": "學姐作為一名餐廳廚師，除了要做出好吃的料理，還要盡早完成菜單，讓客人不要等太久。今天餐廳突然**同時**來了 $N$ 名客人，每個人都會點一道菜，第 $i$ 個客人的餐點需要 $A_i$ 分鐘來完成，學姐一次只能做一道菜，而且開始做一道菜就一定要先把這道菜做完，她希望讓客人等待的時間總和越少越好，請告訴她怎麼最小化等待時間的總和。\n\n輸入有兩行，第一行包含一個正整數 $N$ 代表客人的數量。\n第二行有 $N$ 個正整數，第 $i$ 個正整數 $A_i$ 代表完成第 $i$ 個客人的餐點所需的時間。\n\n- $1 \\le N \\le 10^5$\n- $1 \\le A_i \\le 10^5$\n\n輸出只有一行，包含一個正整數代表客人總等待時間的最小值。\n",
    "output": "/*input\n3\n1 2 3\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100005;\n\nint n;\nlong long a[maxn];\n\nint main() {\n\tcin>>n;\n\tfor(int i = 0; i < n; i++) cin>>a[i];\n\tsort(a, a + n);\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += a[i] * (n - i);\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "id": "greedy03",
    "instruction": "在接下來的 $N$ 天，學姐打算每天打工。第 $i$ 天打工可以賺到的錢是 $A_i$，但是如果她選擇偷懶的話當天的薪水會降到 $B_i(B_i \\le A_i)$，為了生存，這 $N$ 天學姐至少要賺到 $K$ 塊錢，請問她最多可以偷懶幾天？\n\n輸入有三行，第一行包含兩個正整數分別對應到題目中的 $N$ 和 $K$，第二行有 $N$ 個正整數，第 $i$ 個正整數代表題目中的 $A_i$，第三行也有 $N$ 個正整數，第 $i$ 個正整數則代表題目中的 $B_i$。\n\n- $1 \\le N \\le 10^5, 0 \\le K \\le 10^9$ \n- $0 \\le A_i, B_i \\le 10^4$\n- $B_i \\le A_i$, $\\forall$ $i$\n- $\\sum A_i \\ge K$\n\n輸出只有一行，包含一個整數代表最多能偷懶幾天。\n\n",
    "output": "/*input\n5 35\n10 10 10 10 10\n3 4 5 6 7\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=300005;\n\nint a[maxn], b[maxn];\n\nint main(){\n\tint n, k;\n\tcin>>n>>k;\n\tfor(int i = 0; i < n; i++) cin>>a[i];\n\tfor(int i = 0; i < n; i++) cin>>b[i];\n\tvector<int> v;\n\tfor(int i = 0; i < n; i++) v.push_back(a[i] - b[i]);\n\tfor(int i = 0; i < n; i++) k -= a[i];\n\tk = -k;\n\tint ans = 0;\n\tsort(v.begin(), v.end());\n\tfor(int i : v){\n\t\tif(k >= i){\n\t\t\tk -= i;\n\t\t\tans ++;\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "id": "greedy04",
    "instruction": "在卡加布列島上發行的硬幣有 $N$ 種，分別價值 $A_1, A_2, \\cdots, A_N$ 塊，已知 $1 = A_1 < A_2 < \\cdots < A_N$，而且對於所有可能的 $i$，$A_i$ 是 $A_{i+1}$ 的因數。學姐帶了價值 $K$ 塊錢的小說去卡加布列島想要換成現金，但她希望拿到的硬幣越少越好，作為收銀員的你能滿足學姐的需求嗎？\n\n(注意到最小硬幣是 $1$ 塊錢，所以一定有辦法換錢)\n\n輸入有兩行，第一行包含兩個正整數 $N, K$，代表硬幣的種數和小說的價值。\n第二行則有 $N$ 個正整數 $1 = A_1, A_2, \\cdots ,A_N$，分別代表硬幣的價值，保證輸入的數字從小到大排列。\n\n- $1 \\le N \\le 10$\n- $1 \\le K \\le 10^{12}$\n- $1 \\le A_i \\le 10^{12}$,  $\\forall$ $i$\n- $A_1 < A_2 < \\cdots < A_N$\n- $A_i | A_{i+1}$,  $\\forall$ $i < N$\n\n輸出有一行。這一行只有一個正整數，代表可能的最少硬幣數量。\n",
    "output": "/*input\n5 123\n1 5 10 20 100\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nlong long k;\nlong long a[15];\n\nint main(){\n\tcin>>n>>k;\n\tfor(int i = 0; i < n; i++) cin>>a[i];\n\tlong long ans = 0;\n\tfor(int i = n - 1; i >= 0; i--){\n\t\tans += k / a[i];\n\t\tk %= a[i];\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "id": "greedy05",
    "instruction": "卡加布列島上發行的硬幣有 $N$ 種，分別價值 $A_1, A_2, \\cdots, A_N$ 塊，已知 $1 = A_1 < A_2 < \\cdots < A_N$，而且對於所有可能的 $i$，$A_i$ 是 $A_{i+1}$ 的因數。\n\n學姐這次帶了價值 $K$ 塊錢的遊戲王卡去卡加布列島想要換成現金，她一樣希望拿到的硬幣越少越好。作為收銀員的你，這次每個硬幣的數量都只有 $C_i$ 個可以給學姐換錢，不然你會被老闆罵。這次你能滿足學姐的需求嗎？\n\n因為這裡的最小硬幣是 $1$ 塊錢而且你可以給學姐的 $1$ 塊錢有 $K$ 個，所以一定有辦法換錢，不用考慮無解的狀況。\n\n輸入有兩行，第一行包含兩個正整數 $N, K$，代表硬幣的種數和遊戲王卡的價值。\n第二行則有 $N$ 個正整數 $1 = A_1, A_2, \\cdots ,A_N$，分別代表硬幣的價值，保證輸入的數字從小到大排列。\n第三行則有 $N$ 個正整數 $1 = C_1, C_2, \\cdots ,C_N$，分別代表硬幣的數量。\n\n* $1 \\le N \\le 10$\n* $1 \\le K \\le 10^{12}$\n* $1 \\le A_i \\le 10^{12}$,  $\\forall$ $i$\n* $1 = A_1 < A_2 < \\cdots < A_N$\n* $A_i | A_{i+1}$,  $\\forall$ $i < N$\n* $C_1 = K$\n* $1 \\le C_i \\le 10^9 \\forall i > 1$\n\n其中保證一定有解，不會發生湊不出來的狀況。\n\n輸出一個正整數，代表需要的最少硬幣數量。\n\n",
    "output": "#include <iostream>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint main() {\n\tlong long n, k;\n\tlong long a[10];\n\tlong long c[10];\n\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> c[i];\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tlong long x = min(k / a[i], c[i]);\n\t\tans += x;\n\t\tk -= a[i] * x;\n\t}\n\n\tassert(k == 0);\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "id": "greedy06",
    "instruction": "小 L 和小 F 是天生的死對頭，他們不管什麼都要進行比較，而近年來圍棋 AI 正夯，於是他們分別訓練了 $N$ 個圍棋 AI 準備來進行一場大對決，雙方各位將自己的 AI 們排好順序，形成 $N$ 場一對一的對決。已知每一台 AI 都有自己的「能力值」，當兩台 AI 進行對戰的時候，總會是能力值比較高的 AI 獲勝，如果雙方的能力值相同則會平手。心機很重的小 L 駭進了小 F 的系統，得到了小 F 所有 AI 的能力值以及排點順序，小 L 希望在這個情況下他能夠贏越多場越好，請幫小 L 計算他至多能夠獲勝幾場。\n\n輸入第一行包含一個正整數 $N (1 \\leq N \\leq 10^5)$，代表雙方分別擁有的 AI 數量。\n輸入第二行有 $N$ 個正整數 $F_1, F_2, \\ldots, F_N (1 \\leq F_i \\leq 10^5)$，代表小 F 的 AI 們的能力值。\n輸入第三行有 $N$ 個正整數 $L_1, L_2, \\ldots, L_N (1 \\leq L_i \\leq 10^5)$，代表小 L 的 AI 們的能力值。\n\n請輸出一個整數代表小 L 的勝場數最大可能值。\n\n",
    "output": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int n; cin >> n;\n  vector<int> a(n), b(n);\n  for(int i = 0; i < n; i++) cin >> b[i];\n  for(int i = 0; i < n; i++) cin >> a[i];\n  sort(a.begin(), a.end()); sort(b.begin(), b.end());\n\n  int ans = 0;\n  priority_queue<int> pq;\n  for(int i = 0, j = 0; i < n; i++) {\n    while(j < n && b[j] < a[i]) pq.push(b[j++]);\n    if(!pq.empty() && pq.top() < a[i]) {\n      ans++, pq.pop();\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "greedy07",
    "instruction": "學姐最近開始打工，第 $i$ 天她賺了 $A_i$ 塊錢。她決定跟朋友炫耀她平均一天能賺多少錢，所以她打算找 $L$ 和 $R$ 使得在第 $L$ 天到第 $R$ 天之間每天平均賺的錢最多，但是如果這個期間只有一天的話會被他的朋友抓包，換句話說，學姐想要找 $L, R$ 使得 $[A_L, A_{L+1}, \\cdots, A_R]$ 的平均最大且 $L \\ne R$ 。請幫學姐找到最好的平均日薪吧！\n輸入有兩行，第一行包含一個正整數 $N$，代表學姐打工了 $N$ 天，第二行有 $N$ 個正整數，第 $i$ 個正整數是 $A_i$，代表第 $i$ 天打工的薪資。\n\n- $2 \\le N \\le 3 \\cdot 10^5$\n- $0 \\le A_i \\le 10^8$\n\n輸出只有一行，包含兩個正整數 $P$ 和 $Q$，代表最大的平均日薪為 $\\frac{P}{Q}$，這必須是一個最簡分數，也就是說 $P, Q$ 互質。\n\n",
    "output": "/*input\n5\n1 3 4 2 3\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=300005;\n\nint a[maxn];\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++) cin>>a[i];\n\n\t// the computation below is scaled by 6 to avoid non-integer number\n\tint best = 0;\n\tfor(int i = 0; i < n - 1; i++){\n\t\tbest = max(best, (a[i] + a[i + 1]) * 3);\n\t}\n\tfor(int i = 0; i < n - 2; i++){\n\t\tbest = max(best, (a[i] + a[i + 1] + a[i + 2]) * 2);\n\t}\n\t// scaled back and simplify the fraction\n\tint q = 6;\n\tif(best % 2 == 0){\n\t\tq /= 2;\n\t\tbest /= 2;\n\t}\n\tif(best % 3 == 0){\n\t\tq /= 3;\n\t\tbest /= 3;\n\t}\n\tcout<<best<<' '<<q<<'\\n';\n}\n"
  },
  {
    "id": "greedy08",
    "instruction": "有一隊考古學家到了阿納克的失落遺蹟探險，他們在遺蹟中發現了許多值錢的古代錢幣，因為該文化信奉畢達哥拉斯主義的關係，所有錢幣的重量都互相整除。他們想帶一些錢幣回去補貼探險經費，但背包的負重有限，請幫他們計算最多可以帶價值多少的錢幣回去。\n\n第一行有兩個整數 $N,M$，$N$ 代表找到了幾種錢幣，$M$ 代表最多能帶走多重的錢幣。\n接下來 $N$ 行，每行有一個整數 $v_i,w_i$，代表第 $i$ 種錢幣的價值與重量。\n\n- $1 \\le N \\le 2 \\times 10^5$\n- $1 \\le M \\le 2 \\times 10^9$\n- $1 \\le v_i,w_i \\le 2 \\times 10^9 \\ \\ \\forall i$\n- 對於所有 $i,j$，保證 $w_i | w_j$ 或 $w_j|w_i$\n\n最多能帶走的價值多少的錢幣。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint N,M;\n\tcin >> N >> M;\n\tvector< pair<long long,long long> > coins;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tlong long value,weight;\n\t\tcin >> value >> weight;\n\t\tcoins.push_back( make_pair(value, weight) );\n\t}\n\tsort(coins.begin(), coins.end(), \n\t\t[](pair<long long,long long> a,pair<long long,long long> b) -> bool{\n\t\treturn a.first * b.second > b.first * a.second;\n\t}\n\t);\n\n\tlong long int max_total_value = 0; //Note:answer may exceed range of Int\n\n\tfor(auto coin : coins)\n\t{\n\t\tmax_total_value += (M / coin.second) * coin.first;\n\t\tM %= coin.second;\n\t}\n\n\tcout << max_total_value << endl;\n}\n"
  },
  {
    "id": "greedy09",
    "instruction": "又有一隊考古學家到了阿納克的失落遺蹟探險，他們在遺跡中發現了許多寶石，總共有 $N$ 顆，每顆分別價值 $v_i$ 元，他們的背包最多能裝 $M$ 顆寶石，他們最多能帶走價值多少的寶石呢？\n\n第一行有兩個整數 $N,M$，$N$ 代表找到了幾顆寶石，$M$ 代表最多能帶走幾顆寶石。\n接下來 $N$ 行，每行有一個整數 $v_i$，代表第 $i$ 顆寶石的價值。\n\n- $1 \\le M \\le N \\le 2 \\times 10^5$\n- $1 \\le v_i\\ \\le 2 \\times 10^9 \\ \\ \\forall i$\n\n輸出最多能帶走價值多少的寶石。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint N,M;\n\tcin >> N >> M;\n\tvector<int> v;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tint value;\n\t\tcin >> value;\n\t\tv.push_back( value );\n\t}\n\tsort(v.begin(), v.end(), greater<>());\n\n\tlong long int max_total_value = 0; //Note:answer may exceed range of Int\n\n\tfor(auto itr:v)\n\t{\n\t\tif(M == 0)\n\t\t\tbreak;\n\t\tmax_total_value += itr;\n\t\tM--;\n\t}\n\tcout << max_total_value << endl;\n}\n"
  },
  {
    "id": "greedy10",
    "instruction": "小鴨工廠專門製造黃色小鴨，他們必須和塑膠原料廠訂購塑膠。一共有 $N$ 家塑膠原料廠，其中第 $i$ 家能從第 $s_i$ 天供貨到第 $t_i$ 天。\n\n小鴨工廠想要選一些原料廠當合作對象。假設最早能供貨的原料廠開始時間是第 $S$ 天，能供貨到最晚的原料廠結束於第 $T$ 天，小鴨工廠希望從 $S$ 到 $T$ 的每天都要與一家原料廠合作。在此限制下，小鴨工廠希望合作廠商愈少愈好，請你回答至少需要幾家廠商。\n\n輸入第一行一個整數是 $N$，代表原料廠商數量。\n\n接著有 $N$ 行每行兩個空白相隔的整數 $s_i, t_i$，代表第 $i$ 家廠商的供貨時段 ($1\\le i\\le N$)。\n\n輸入保證 $1\\le N\\le 1000$，$1\\le s_i\\le t_i\\le 10^5$。\n\n特別注意到輸入並沒有保證兩家廠商不會有相同供貨時間。\n\n輸出一行一個整數代表最少的合作廠商，如果無論如何都不可能則請輸出 $-1$。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1010;\n\n// a[i]: time interval (s_i, t_i)\npair<int, int> a[maxn];\n\nint main() {\n    // Read input\n    int N;\n    cin >> N;\n    for(int i = 1; i <= N; i++) {\n        cin >> a[i].first >> a[i].second;\n        a[i].second = -a[i].second;\n    }\n    // Sort by first index, then by second index descending\n    sort(a+1, a+N+1);\n    for(int i = 1; i <= N; i++) a[i].second = -a[i].second;\n\n    // Main greedy algorithm\n    int ans = 1, mx = a[1].second, last = a[1].second;\n    bool touch = 0;\n    for(int i = 2; i <= N; i++) {\n        if(a[i].first > last + 1) {\n            if(a[i].first > mx + 1) {\n                cout << \"-1\" << endl;\n                exit(0);\n            }\n            last = mx;\n            touch = 0;\n        }\n        if(!touch && a[i].second > last) {\n            touch = 1;\n            ans++;\n        }\n        mx = max(a[i].second, mx);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "id": "greedy11",
    "instruction": "胖達是一位全職的 foodpanda 外送員，某天醒來時，胖達突然發現他有了預知未來的超能力，能知道當天每一張外送單的開始和結束時間，它決定用這能力來最大化一天能送的單量。胖達接的任何兩張單時間都不能有重疊，你能幫它算出它一天最多能送幾張單嗎？\n\n第一行有一個整數 $N(1 \\leq N \\leq 5 \\times 10^5)$，代表今天胖達可能接到的外送任務數量。\n接下來 $N$ 行，每行有兩個整數 $s_i , e_i(1 \\leq s_i < e_i \\leq 2 \\times 10^9)$，代表第 $i$ 個外送任務的開始與結束時間。\n\n請輸出一個整數 $M$，代表胖達今天所能完成的最大外送任務數量。\n\nNote：開始與結束時間是 exclusive 的，也就是說胖達可以完成在（$1$ 開始，$10$ 結束）與（$10$ 開始，$20$ 結束）這兩項外送任務。\n\n",
    "output": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nbool compare_second( pair<int,int> A, pair<int,int> B){ return A.second < B.second;}\nint main() {\n\t//This is model solution\n\tint N;\n\tcin >> N;\n\n\tvector< pair<int,int> > segments;\n\tfor(int i = 0 ; i < N; i ++)\n\t{\n\t\tint start, end;\n\t\tcin >> start >> end;\n\t\tsegments.push_back( make_pair( start, end));\n\t}\n\tsort(segments.begin(),segments.end(),compare_second);\n\n\tint end_time_now = 0;\n\tint ans_count = 0;\n\tfor(auto seg : segments)\n\t{\n\t\tif( seg.first >= end_time_now)\n\t\t{\n\t\t\tans_count ++;\n\t\t\tend_time_now = seg.second;\n\t\t}\n\t}\n\tcout << ans_count << endl;\n\treturn 0;\n}\n"
  },
  {
    "id": "greedy12",
    "instruction": "魯夫的夢想是成為航海王，但長榮跌下來以後他就跟身邊的韭菜一樣被割了，現在只能睡公園的紙箱。\n為了重新找回他的夢想，他要打一些奇怪的工籌措資金。\n因為公園不好睡，魯夫每天打完工以後他會直接在打工的地點過夜。\n現在有 $n$ 間公司可以給魯夫打工且這些公司在同一條直線上，公司由近到遠編號 $1, 2, 3, \\ldots, n$，並且從公園到第一間公司需要花 $t_1$ 天時間，從第 $i-1$ 間公司到第 $i$ 間公司需要花 $t_i$ 天時間。\n\n而這些公司特別黑心，會紀錄魯夫總共來了幾天然後依據這個次數扣他的薪水。假設第 $i$ 個公司給你的初始薪水是 $M_i$，他在此公司工作第 $i$ 天時只會給你 $M_i - (i - 1)\\cdot D_i$ 的薪水。請你幫魯夫算一下他在 $T$ 天之內最多可以賺到多少錢？\n\n\n輸入第一行有兩個整數 $T, n$，第二行有 $n$ 個整數 $M_i$，第三行有 $n$ 個整數 $D_i$，第四行有 $n$ 個整數 $t_i$。整數之間以空白分隔。其中保證：\n\n* $0 \\leq T, n, M_i, D_i, t_i \\leq 10^5$\n* $nT \\leq 10^7$\n\n輸出魯夫在第 $T$ 天能賺到的錢的最大值。\n\n",
    "output": "#include <iostream>\n#include <queue>\n#define MAXN 100000\nusing namespace std;\n\nint m[MAXN], d[MAXN], ti[MAXN];\n\nint main() {\n\tlong long t, n;\n\n\tcin >> t >> n;\n\tfor (int i = 0; i < n; i++) cin >> m[i];\n\tfor (int i = 0; i < n; i++) cin >> d[i];\n\tfor (int i = 0; i < n; i++) cin >> ti[i];\n\n\t// solve\n\tlong long ans = 0, cur = 0;\n\tpriority_queue<int, vector<int>, greater<int> > pq;\n\tfor (int i = 0; i < n; i++) {\n\t\tt -= ti[i];\n\t\twhile (t < 0 && !pq.empty()) {\n\t\t\tcur -= pq.top();\n\t\t\tpq.pop();\n\t\t\tt++;\n\t\t}\n\t\twhile (t > 0 && m[i] > 0) {\n\t\t\tcur += m[i];\n\t\t\tpq.push(m[i]);\n\t\t\tm[i] -= d[i];\n\t\t\tt--;\n\t\t}\n\t\twhile (!pq.empty() && m[i] > pq.top()) {\n\t\t\tcur += m[i] - pq.top();\n\t\t\tpq.pop();\n\t\t\tpq.push(m[i]);\n\t\t\tm[i] -= d[i];\n\t\t}\n\t\tans = max(ans, cur);\n\t}\n\tcout << ans << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "id": "greedy13",
    "instruction": "時間回到了 2020 年上半，此時色雷斯資訊奧林匹亞（Thracian Olympiad in Informatics，簡稱 TOI）選訓營正在如火如荼的進行！為了選出全色雷斯最出色的高中程式設計師，他們正在進行第二次的模擬競賽。然而，因為某些不可預測的原因，上傳程式時竟然發現伺服器無法負荷而導致評測時間無限拉長的窘境！此時，這些參賽者透過系統收到這個訊息：\n\n> Ο κριτής βρίσκεται σε πλήρη ταχύτητα, περιμένετε υπομονετικά\n\n翻譯成中文即「評測系統已火力全開，請耐心等候」。已知有 $N$ 份程式碼必須要跑，而第 $i$ 份程式碼需要跑 $t_i$ 毫秒。色雷斯的伺服器是有 $M$ 個核心所組成的電腦，一次可以跑一份程式碼。而且，所有的程式碼必須依序**開始執行**（允許因為需要跑的時間不同而導致後開始跑的程式碼比先開始跑的程式碼率先完成的情況）。而評測團隊需要找出一個最好的分配伺服器資源的方式使得最後一份程式碼跑完的時間是最短的。請寫一支程式幫助色雷斯的評測團隊吧！\n\n輸入將有兩行，第一行包含兩個正整數 $N$ 和 $M$，分別代表有幾份程式碼要跑和伺服器有幾個核心。第二行有 $N(1 \\leq N, M \\leq 10^5)$ 個正整數，依序代表需要執行的第 $i$ 份程式碼所需要執行的時間 $t_i(1 \\leq t_i \\leq 10^9)$。\n\n請輸出一個正整數，代表跑完所有程式的最少時間。\n",
    "output": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nsigned main() {\n    long long int N, M, t, ot, ans;\n    priority_queue<long long int, vector<long long int>, greater<long long int>> pq;\n    cin >> N >> M;\n    for(int i = 0; i < M; i++) pq.push(0);\n    for(int i = 0; i < N; i++){\n        cin >> t;\n        ot = pq.top();\n        pq.pop();\n        pq.push(ot + t);\n    }\n    while(pq.size()){\n        ans = pq.top();\n        pq.pop();\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "id": "greedy14",
    "instruction": "快取是一小塊記憶體儲存空間，儲存在快取內的資料可以被快速提取，你現在要模擬一個快取的讀寫排程工作。假設記憶體一共有 $N$ 個等大的單位，而你的快取可以儲存 $K$ 單位的資料，並且你可以預先知道未來 $P$ 次程式要讀寫的記憶體單位。\n\n你要依序讀寫 $P$ 單位的資料。快取一開始是空的，每當讀寫的資料不在快取中時，就會從後層的記憶體調閱資料再寫入快取中。如果此時快取已將容量 $K$ 單位存滿，則你要選擇一個單位的資料覆蓋掉，覆蓋掉的資料便視為已經不在快取中。請假設當你從快取外讀入了一單位資料後，你一定會將他寫到快取上。\n\n試圖讀寫不是快取的記憶體是讀寫中相對較花時間的一部分，因此你要最小化這個次數。請求出在最佳讀寫安排下，讀寫資料不在快取中的最少次數。\n\n輸入第一行是三個空白分隔的整數 $N, K, P$，分別代表記憶體總單位數，快取容量，以及程式要讀寫的記憶體單位數。\n輸入第二行是 $P$ 個空白分隔的整數，代表依序要讀入的記憶體單位位置 $a_i (1\\le i\\le P)$。\n\n輸入保證 $1\\le N, K\\le 10^5$，$1\\le P\\le 5\\times 10^5$，$1\\le a_i\\le N$。\n\n輸出一行一個整數代表最少讀寫資料不在快取的次數。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e5 + 5;\nint a[maxn], nxt[maxn], pos[maxn];\nset<int> s;\nint main() {\n    int n,k,p;\n    cin >> n >> k >> p;\n    for(int i = 0; i < p; i++) {\n        cin >> a[i];\n    }\n    for(int i = 1; i <= n; i++) pos[i] = p;\n    for(int i = p-1; i >= 0; i--) {\n        nxt[i] = pos[a[i]];\n        pos[a[i]] = i;\n    }\n    int ans = 0;\n    for(int i = 0; i < p; i++) {\n        if(s.count(i)) {\n            s.erase(i);\n            s.insert(nxt[i]);\n            continue;\n        }\n        else {\n            if(s.size() == k)s.erase(prev(s.end()));\n            s.insert(nxt[i]);\n            ans++;\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "id": "greedy15",
    "instruction": "這裡是收錄所有的語言的巴貝爾塔（Tower of Babel）。塔內，有 $M$ 個僧人在值班，需要抄錄 $N$ 本書，編號從 $1$ 至 $N$。在已經知道第 $i$ 本書會花 $t_i$ 天抄錄完畢，而且所有的僧人都要抄錄連續編號的書的情況之下，請問這些僧人最短需要花多少時間才能夠將這些書全部抄錄完畢？請假設工作分配完畢之後，所有的僧人就會同時開始抄錄，並且會晝夜不停地抄錄，而且這些僧人只會抄錄自己被分配到的那些書。請注意，抄錄結束的時間是從所有僧人都開始抄錄開始，直到最後一個僧人抄完最後一本書為止。\n輸入有兩行。第一行有兩個正整數 $N$ 和 $M(1 \\leq N, M \\leq 2 \\times 10^5)$，分別代表書本的數量和僧人的數量。第二行有 $N$ 個正整數 $t_1,t_2,t_3,\\ldots,t_N(1 \\leq t_i \\leq 10^9)$ 依序代表書本需要抄錄的時間。\n\n請輸出一個正整數，代表這些僧人所需要的最短時間。\n",
    "output": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst long long int maxN = 2e5 + 326, INF = 1e18;\nlong long int N, M, book[maxN];\n\ninline bool can(long long int x){\n    long long int cnt = 0, rem = 0;\n    for(long long int i = 0; i < N; i++){\n        if(book[i] > x) return false;\n        if(book[i] > rem){\n            cnt++;\n            rem = x - book[i];\n        } else {\n            rem -= book[i];\n        }\n        if(cnt > M) return false;\n    }\n    return true;\n}\n\nsigned main(){\n    cin >> N >> M;\n    for(int i = 0; i < N; i++) cin >> book[i];\n    long long int l = 0, r = INF, m;\n    while(r - l > 1){\n        m = (l + r) / 2;\n        if(can(m)) r = m;\n        else l = m;\n    }\n    cout << r << endl;\n}\n"
  },
  {
    "id": "greedy16",
    "instruction": "一臺圖靈機是擁有一個讀針和**無限**長的一張充滿格子的紙當作記憶體的機器。今天，你發現圖靈機掉落了 $N$ 張紙片，其中第 $i$ 張上面恰好寫滿了一個由小寫英文字母所組成的字串 $s_i$！你知道，圖靈機在壞掉之前想要做的事是：\n\n- 請將所有的 $s_i$ 排列，使得排列之後將這些字串頭接著尾黏起來的字典序最小。\n\n舉例來說，假設你有三個字串 $[ab, abc, b]$，那如果排成 $[ab, b, abc]$ 的話，就會比 $[abc, b, ab]$ 還要小，因為前者拼起來是 `abbabc` 而後者拼起來是 `abcbab`。\n\n注：如果 $A, B$ 分別為長度 $N, M$ 的字串，且 $N \\le M$ 的話，則若：\n\n- 存在一個 $0 \\le i < N$ 使得 $A[0, i - 1] = B[0, i - 1]$ 且 $A_i < B_i$\n- $A = B[0, N - 1]$ 且 $N < M$\n\n則我們稱 $A$ 的字典序比 $B$ 小。\n輸入有 $N + 1$ 行。第一行為 $N$，接下來 $N$ 行中，每一行都會有一個由小寫英文字母組成的非空字串 $s_i$。\n\n保證 $1 \\leq N, \\sum |s_i| \\leq 10^5$。\n\n請輸出一個字串，代表接起來之後具有最小字典序的字串。\n",
    "output": "#include <iostream>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n\nconst int maxN = 1e5 + 326;\nint N;\nstring s[maxN];\n\nint main() {\n\tios_base::sync_with_stdio(0);cin.tie(0);\n\tcin >> N;\n\tfor(int i = 0; i < N; i++) cin >> s[i];\n\tsort(s, s + N, [&](string &a, string &b){\n\t\treturn a + b < b + a;\n\t});\n\tfor(int i = 0; i < N; i++) cout << s[i];\n\tcout << endl;    \n}\n"
  },
  {
    "id": "greedy17",
    "instruction": "遠古時代，烏龜還不會飛，曾有座由 $N$ 個烏龜想要相互堆疊成一座塔。每一隻烏龜可以用兩個屬性來形容：第 $i$ 隻烏龜有一個「重量」 $w_i$ 與一個「過動度」$f_i$。現在，這些烏龜們想要依某種順序堆疊成一個塔，要最少化「麻煩度」。麻煩度的計算方法如下：\n\n對於每一隻烏龜，其「過動度」$f_i$ 代表了它會想要出去幾次。而每次要出去，在其上方的烏龜都必須移開。具體來說，第 $i$ 隻烏龜會想要出去 $f_i$ 次，且每次都要花費 $w_1 + w_2 + w_3 + \\dots + w_{i - 1}$ 的麻煩度，總麻煩度 $f_i(w_1 + w_2 + w_3 + \\dots + w_{i - 1})$。舉例來說，如果有三隻烏龜烏龜從上到下的重量依序為 $[1, 2, 3]$，過動度為 $[4,5,6]$，則其麻煩度可以計算為 $1 \\times 0 + 2 \\times 4 + 3 \\times (4 + 5) = 35$。\n\n給你這 $N$ 隻烏龜的相關資料，請計算出它們堆疊成塔之後所可以達成的最小「麻煩度」。以上面的例子來說，那三個烏龜的最佳解是從上到下 $w = [3,2,1]$、$f = [6,5,4]$，的話，那麻煩度就是 $3 \\times 0 + 2 \\times 6 + 1 \\times (6 + 5) = 23$（第一個範例測資）。\n\n輸入將有三行。第一行會是 $N$（$1 \\le N \\le 10^5$），代表烏龜的數量。接下來第二行會有 $N$ 個正整數 $w_1, w_2, w_3, w_4 ,\\dots, w_N$，而第三行也會有 $N$ 個正整數 $f_1, f_2, f_3, f_4 ,\\dots, f_N$（$1 \\leq w_i, f_i \\leq 1000$）。\n\n此外：\n\n- 對於佔分 $10\\%$ 的測試資料，額外滿足 $N = 2$，且取用次數 $f_1=f_2=1$。\n- 對於佔分 $20\\%$ 的測試資料，額外滿足 $N = 3$。\n- 對於佔分 $45\\%$ 的測試資料，額外滿足 $N \\le 1000$，且對於所有 $1 \\leq i \\leq N$，$f_i = 1$。\n\n請輸出一個數字代表答案。\n",
    "output": "#include <iostream>\n#include <numeric>\n#include <algorithm>\nusing namespace std;\n\nconst int maxN = 2e5 + 326;\nlong long int N, w[maxN], f[maxN], ord[maxN], ans, sw;\n\nsigned main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    cin >> N;\n    for(int i = 0; i < N; i++) cin >> w[i];\n    for(int i = 0; i < N; i++) cin >> f[i];\n    iota(ord, ord + N, 0);\n    sort(ord, ord + N, [&](long long int a, long long int b){\n        return f[b] * w[a] < f[a] * w[b];\n    });\n    for(int i = 0; i < N; i++){\n        ans += sw * f[ord[i]];\n        sw += w[ord[i]];\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "id": "greedy18",
    "instruction": "小風正在玩一個塔防遊戲，和一般的塔防遊戲不同，這款遊戲是要藉由建造塔本身來進行防禦。在一個關卡中會提供 $N$ 件材料讓玩家建造塔，第 $i$ 件材料有三種屬性：重量 $w_i$、耐久值 $s_i$、以及防禦度 $v_i$。建造塔的方式就是從這些材料選一些出來從上至下排列蓋成一座塔，蓋塔需要滿足一個重要的條件：\n\n- 在塔中的每一件材料 $i$，其耐久度 $s_i$ **不小於**在該材料上方的所有材料重量總和。\n\n小風希望能蓋出防禦度總和最高的塔，請你幫小風計算防禦度最高可以達到多少。\n\n輸入第一行有一個正整數 $N (1 \\leq N \\leq 1000)$，代表材料的數量。\n接下來的 $N$ 行，第 $i$ 行有三個整數 $w_i, s_i, v_i (1 \\leq w_i, s_i \\leq 10000, 1 \\leq v_i \\leq 10^9)$，分別代表第 $i$ 件材料的三種屬性。\n\n請輸出一個整數，代表防禦度總和的最大值。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int n; cin >> n;\n  vector<tuple<int, int, int>> a(n);\n  for(int i = 0; i < n; i++) {\n    int w, s, v; cin >> w >> s >> v;\n    a[i] = make_tuple(w, s, v);\n  }\n  sort(a.begin(), a.end(), [&](auto x, auto y) {return get<0>(x) + get<1>(x) < get<0>(y) + get<1>(y);});\n\n  vector<long long> dp(int(2e4) + 1, (long long)(-1e18));\n  dp[0] = 0;\n  for(int i = 0; i < n; i++) {\n    for(int j = get<1>(a[i]); j >= 0; j--) dp[j + get<0>(a[i])] = max(dp[j + get<0>(a[i])], dp[j] + get<2>(a[i]));\n  }\n  long long ans = *max_element(dp.begin(), dp.end());\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "greedy19",
    "instruction": "在疫情之下，外送業逐漸蓬勃發展，身為一家餐廳的所有者小天也開始提供外送的服務，為了更方便掌管出餐流程，開始營業之後不再受任何預約，當天就只會處理營業開始前的預約。每一個預約單都有預計完成餐點需要花費的時間，因為餐廳內只有一個廚師，所以兩張單子的餐點不能同時製作。除此之外，每一張單子都有一個負責的外送人員來負責外送，所有的外送人員都在餐廳開始營業的時候就就為待命，每一位外送人員都有自己的「怒氣指數」，如果一位外送人員的「怒氣指數」為 $w$，並且在營業開始後 $t$ 分鐘才拿到他所負責的餐點，那他的「怒氣值」就是 $t \\times w$。小天想要妥善為他的廚師安排處理餐點的順序，讓所有外送人員的「怒氣值」總和達到最小，請你幫助小天完成這個任務。\n\n輸入第一行有一個正整數 $N (1 \\leq N \\leq 100000)$，代表該天總共接到的預約個數。\n輸入第二行有 $N$ 個整數 $t_1, t_2, \\ldots, t_N (1 \\leq t_i \\leq 1000)$，分別代表完成每一個餐點所需的時間。\n輸入第三行有 $N$ 個整數 $w_1, w_2, \\ldots, w_N (0 \\leq w_i \\leq 1000)$，分別代表每一位外送人員的「怒氣指數」。\n\n請輸出一個整數，表示「怒氣值」總和的最小可能值。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int n; cin >> n;\n  vector<pair<int, int>> events(n);\n  for(int i = 0; i < n; i++) cin >> events[i].first;\n  for(int i = 0; i < n; i++) cin >> events[i].second;\n  sort(events.begin(), events.end(), [&](auto x, auto y) {return x.first * y.second < x.second * y.first;});\n  \n  long long ans = 0, cur_time = 0;\n  for(int i = 0; i < n; i++) {\n    cur_time += events[i].first;\n    ans += cur_time * events[i].second;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "greedy20",
    "instruction": "假設今天英文字母只有 a, b, c, d 四種，我們可以用以下表格把英文字母轉成二進位：\n\n<table border=\"1\">\n    <tr> <th > <center> 字母 </center> </th>  <th style=\"padding:8px;\"> <center> 二進位表示 </center> </th> </tr>\n    <tr><td style=\"padding:8px;\"><center> <code>a</code> </td></center> <td style=\"padding:8px;\"> <code>00</code> </td> </tr>\n    <tr><td style=\"padding:8px;\"><center> <code>b</code> </td></center> <td style=\"padding:8px;\"> <code>01</code> </td> </tr>\n    <tr><td style=\"padding:8px;\"><center> <code>c</code> </td></center> <td style=\"padding:8px;\"> <code>10</code> </td> </tr>\n    <tr><td style=\"padding:8px;\"><center> <code>d</code> </td></center> <td style=\"padding:8px;\"> <code>11</code> </td> </tr>\n</table>\n\n<p></p>\n\n例如字串 `aaabbcd` 會變成 `00000001011011`，但是如果今天我們換一個二進位轉換：\n\n<table border=\"1\">\n    <tr> <th > <center> 字母 </center> </th>  <th style=\"padding:8px;\"> <center> 二進位表示 </center> </th> </tr>\n    <tr><td style=\"padding:8px;\"><center> <code>a</code> </td></center> <td style=\"padding:8px;\"> <code>0</code> </td> </tr>\n    <tr><td style=\"padding:8px;\"><center> <code>b</code> </td></center> <td style=\"padding:8px;\"> <code>10</code> </td> </tr>\n    <tr><td style=\"padding:8px;\"><center> <code>c</code> </td></center> <td style=\"padding:8px;\"> <code>110</code> </td> </tr>\n    <tr><td style=\"padding:8px;\"><center> <code>d</code> </td></center> <td style=\"padding:8px;\"> <code>1111</code> </td> </tr>\n</table>\n\n<p></p>\n\n那 `aaabbcd` 會轉換成 `00010110111`，比剛剛的短了不少，以電腦來說，佔用的記憶體也變得更少。\n在設計轉換方式時，首先要注意到我們不能造成混肴 — 不能有一個字母的二進位轉換是另外一個字母的二進位轉換前綴，如果 `0` 代表 `a`，`00` 代表 `b`，那我們無法分辨 `aa` 和 `b`。另外，很明顯的，我們只在乎每個字母出現的次數，而不在乎他們出現的順序。\n現在給你一個字串中每個字母出現的次數，請找到一個二進位轉換方式使得這個字串轉換成二進位後最短，並輸出轉換後的二進位字串長度。\n\n輸入第一行有一個正整數 $N$，代表字母的種類數。接下來一行有 $N$ 個以空格分隔的整數 $A_1, A_2, \\ldots, A_N$，代表每個字母各自在字串中出現的次數。\n\n- $1 \\le N \\le 10^5$\n- $1 \\le A_1 \\le A_2 \\le \\cdots \\le A_N \\le 10^5$\n\n輸出一行，包含一個正整數，代表二進位轉換後的字串的最短長度。\n",
    "output": "/*input\n4\n1 1 2 3\n\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long maxn=100005;\n\nlong long a[maxn];\nvector<long long> b;\nint pta = 0, ptb = 0; // use vector to implement queue\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++) cin>>a[i];\n\n  if (n == 1) {\n    cout << a[0] << '\\n';\n    return 0;\n  }\n\tsort(a, a + n);\n\tlong long ans = 0;\n\tfor(int T = 0; T < n - 1; T++){\n\t\t// find the smallest 2 elements\n\t\tlong long mn = -1, mn2 = -1;\n\n\t\tif(b.size() == ptb){\n\t\t\tmn = a[pta++];\n\t\t}\n\t\telse if(pta == n){\n\t\t\tmn = b[ptb++];\n\t\t}\n\t\telse{\n\t\t\tif(b[ptb] < a[pta]){\n\t\t\t\tmn = b[ptb++];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmn = a[pta++];\n\t\t\t}\n\t\t}\n\t\tif(b.size() == ptb){\n\t\t\tmn2 = a[pta++];\n\t\t}\n\t\telse if(pta == n){\n\t\t\tmn2 = b[ptb++];\n\t\t}\n\t\telse{\n\t\t\tif(b[ptb] < a[pta]){\n\t\t\t\tmn2 = b[ptb++];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmn2 = a[pta++];\n\t\t\t}\n\t\t}\n\t\tans += mn + mn2;\n\t\tb.push_back(mn + mn2);\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "id": "greedy21",
    "instruction": "夏天到了！夏天，就是最適合戀愛的季節～～～\n\n現在呢，你是相親活動的主辦活動，想要撮合 $N$ 位男生與 $N$ 位女生，各自皆從 $1$ 編號到 $N$。經過了許多輪的團康活動等等，你讓每個人都將異性依照喜好的程度排序 —— 是的，愛情是殘酷的。你想要找到一種將這 $2N$ 個人分成 $N$ 對男女，而且為了要儘量讓這些男女找到幸福，不要讓有人的伴侶找去找其他人的伴侶玩這種尷尬的事情發生，還必須滿足這個條件：\n\n- 對於任何兩個異性且目前不是一對的人，他們不會兩個都想要換伴侶成對方（也就是兩個對於對方的好感比目前的伴侶都高）。\n\n請幫忙解決這個問題吧！\n\n輸入有 $2N + 1$ 行。第一行是一個數字 $N(1 \\leq N \\leq 800)$，代表有幾個男生與女生。接下來的 $N$ 行的第 $i$ 行中的第 $j$ 個數字 $s_{ij}$ 代表編號為 $i$ 的男生第 $j$ 心儀的女生。然後也會有 $N$ 行，其中第 $i$ 行中的第 $j$ 個數字 $t_{ij}$ 代表編號為 $i$ 的女生第 $j$ 喜歡的男生。\n\n保證所有的資料皆合法，不會出現範圍外的數字與重複的排名。\n\n如果有解，請輸出 $N$ 個數字，第 $i$ 個數字 $x_i$ 代表編號為 $i$ 的男生應該要和編號為 $x_i$ 的女生配對。如果無論如何都無法滿足條件，請輸出 `-1`。倘若有多組解，輸出任意一者即可。\n\n\n\n",
    "output": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nconst int maxN = 1e3 + 326;\nint N, grk[maxN][maxN], brk[maxN][maxN], ans[maxN], match[maxN], x, y, s, t;\n\nqueue<int> que, ord[maxN];\n\nint main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    cin >> N;\n    for(int i = 1; i <= N; i++){\n        que.push(i);\n        for(int j = 1; j <= N; j++){\n            cin >> s;\n            ord[i].push(s);\n            brk[i][s] = j; \n        }\n    }\n    for(int i = 1; i <= N; i++){\n        for(int j = 1; j <= N; j++){\n            cin >> t;\n            grk[i][t] = j;\n        }\n    }\n    while(que.size()){\n        x = que.front();\n        que.pop();\n        y = ord[x].front();\n        ord[x].pop();\n        if(!match[y]){\n            match[y] = x;\n            ans[x] = y;\n        } else {\n            if(grk[y][match[y]] > grk[y][x]){\n                ans[match[y]] = 0;\n                que.push(match[y]);\n                match[y] = x;\n                ans[x] = y;\n            } else que.push(x);\n        }\n    }\n    for(int i = 1; i <= N; i++) cout << ans[i] << \" \\n\"[i == N];\n}\n"
  },
  {
    "id": "greedy22",
    "instruction": "面試麵屋牡丹未果的赤井心，憤而在麵屋牡丹本店對面開了一家烏龍麵，想奪取麵屋牡丹的客源。為了具備和麵屋牡丹對抗的實力，赤井心開始認真研究烏龍麵的配方。她得知了一碗烏龍麵由以下兩個要素組成：麵團配方和調味料配方。\n於是赤井心備齊了 $N$ 種麵團和 $N$ 種調味料，準備大展身手，搭配出 $N$ 碗烏龍麵。她發現每種麵團都與特定一種調味料會產生「絕配」。當第 $i$ 種麵團和某種調味料是絕配，會產生 $c_i$ 的美味程度；但也可能搭配特定一種調味料後會製造出地獄組合，損失 $d_i$ 點的美味程度。\n如果某組麵團和調味料的搭配不是絕配，也不是地獄組合則美味程度為 $0$。浪費食材是不可饒恕的事，因此一種麵團一定跟洽一種調味料搭配，一種調味料也跟洽一種麵團搭配。\n沒有學過演算法的赤井心來找你幫忙，她聽說你是個演算法高手。你能想辦法讓總美味程度最大嗎?\n\n第 $1$ 行輸入 $N$，代表有 $N$ 種麵團與 $N$ 種調味料。\n第 $2$ 到第 $N+1$ 行，每行有兩個數字 $a_i,c_i$，表示第 $i$ 種麵團和第 $a_i$ 種調味料會產生絕配，並且獲得 $c_i$ 美味程度。\n第 $N+2$ 到第 $2N+1$ 行，每行有兩個數字 $b_i,d_i$，表示第 $i$ 種麵團和第 $b_i$ 種調味料會產生地獄組合，並且損失 $d_i$ 美味程度，若 $b_i=d_i=0$，則代表第 $i$ 種麵團不會跟任何調味料產生地獄組合。\n\n* $1\\leq N\\leq 5\\times 10^5$\n* $1\\leq a_i\\leq N$\n* $0\\leq b_i\\leq N$\n* $0\\leq c_i,d_i\\leq 10^9$\n* $a_i\\neq b_i$\n\n一個整數 $k$，代表最大的總美味程度。\n\n",
    "output": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n \nconst ll mx = 5e5+5;\n \nll n, match_id[mx], match_val[mx], match_val2[mx], hateid[mx], hatev[mx];\nbool matched[mx];\n \nsigned main(){\n    cin >> n;\n \n    for(int i = 1, soft, v; i <= n; i++){\n        cin >> soft >> v;\n        if(v > match_val[soft]){\n            match_id[soft] = i;\n            match_val2[soft] = match_val[soft];\n            match_val[soft] = v;\n        }\n        else if (v > match_val2[soft]){\n            match_val2[soft] = v;\n        }\n    }\n \n    for(int i = 1; i <= n; i++){\n        cin >> hateid[i] >> hatev[i];\n    }\n    ll cur = 0;\n    for(int i = 1; i <= n; i++){\n        matched[match_id[i]] = 1;\n        cur += match_val[i];\n    }\n \n    bool all_hate_same = 1;\n    ll be_hated = -1, mn = 1e18;\n    for(int i = 1; i <= n; i++){\n        if(!matched[i]){\n            if(hateid[i] == 0){\n                all_hate_same = 0;\n                break;\n            }\n            if(be_hated == -1) be_hated = hateid[i], mn = hatev[i];\n            else{\n                if(hateid[i] != be_hated) all_hate_same = 0;\n                else{\n                    mn = min(hatev[i], mn);\n                }\n            }\n        }\n    }\n    \n    if(be_hated == -1 || match_val[be_hated] > 0 || !all_hate_same){\n        cout << cur << '\\n';\n        return 0;\n    }\n \n    ll ans = cur - mn;\n    \n    for(int i = 1; i <= n; i++){\n        if(match_id[i] != 0){\n            int id = match_id[i];\n            ll loss = match_val[i] - match_val2[i];\n            if(hateid[id] == be_hated){\n                loss += min(hatev[id], mn);\n            }\n            ans = max(ans, cur - loss);\n        }\n    }\n \n    cout << ans << '\\n';\n}\n"
  },
  {
    "id": "if01",
    "instruction": "> 故事前言請見**裴裴電神推廣記**。\n\nPeipei（裴裴）發現最近好像太多人注意到自己的分數了，於是決定開始不要讓自己考高分，畢竟高分對他來說也不是什麼難事。\n不過如果分數隨便考，這樣就顯得跟其他的凡人差不多了。於是他決定要開始「控分」，具體來說就是讓他每科成績都是剛好 $60$ 分，如此一來雖然自己的分數不再出現在榮譽榜上顯眼，卻也能夠證明自己的不凡之處。\n \n身為 Peipei（裴裴）知己的你，決定要幫 Peipei（裴裴）一把。因此這題的題目為，請寫一個程式給定 Peipei（裴裴）物理，化學，生物成績，如果某科分數剛剛好等於 $60$ 分，則輸出 `\"O\"`，否則請輸出 `\"X\"`。\n\n這個輸出規則是每個科目都要的，簡單來說，Peipei（裴裴）的分數如果是 $60$，$59$，$60$ ，那麼你該輸出**一行（必須換行結尾）** `\"OXO\"`。\n\n輸入只有一行，其包含三個整數，分別為 Peipei（裴裴）的物理，化學，生物成績。\n\n* 這三科的成績皆為介於 $0$ 到 $100$ 的整數。（包含 $0$ 和 $100$。）\n\n\n請輸出一行，這行有三個字，分別代表 Peipei（裴裴）物理，化學，生物成績是否剛剛好等於 $60$ 分，如果有輸出 `\"O\"` ，否則請輸出 `\"X\"` 。輸出完三個圈或叉後請以換行結尾。\n",
    "output": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main() {\n    int a, b, c;\n    cin >> a >> b >> c;\n    if (a == 60)\n        cout << 'O';\n    else\n        cout << 'X';\n    if (b == 60)\n        cout << 'O';\n    else\n        cout << 'X';\n    if (c == 60)\n        cout << 'O';\n    else\n        cout << 'X';\n    cout << endl;\n}\n"
  },
  {
    "id": "if02",
    "instruction": "> 故事前言請見**電神裴裴隱匿錄**。\n\n曾經幫 Peipei（裴裴）寫過無數程式的你，開始想要知道自己跟 Peipei（裴裴）的差距到底在哪，所以想寫個程式來測量自己的能耐。\n\n請寫一個程式給定你自己的物理，化學，生物成績，並依據以下平均分數對換等第的表來輸出你的平均等第。（底下的 $avg\\text{_}score$ 表示你的平均分數。）\n\n<table border=\"1\">\n    <tr> <th > <center> 平均分數 </center> </th>  <th style=\"padding:8px;\"> <center>等第</center> </th>  </tr>\n    <tr><td style=\"padding:8px;\"><center>90 ≤ avg_score     </td></center> <td style=\"padding:8px;\"><center>A+</center></td></tr>\n    <tr><td style=\"padding:8px;\"><center>85 ≤ avg_score < 90</td></center> <td style=\"padding:8px;\"><center>A </center></td></tr>\n    <tr><td style=\"padding:8px;\"><center>80 ≤ avg_score < 85</td></center> <td style=\"padding:8px;\"><center>A-</center></td></tr>\n    <tr><td style=\"padding:8px;\"><center>77 ≤ avg_score < 80</td></center> <td style=\"padding:8px;\"><center>B+</center></td></tr>\n    <tr><td style=\"padding:8px;\"><center>73 ≤ avg_score < 77</td></center> <td style=\"padding:8px;\"><center>B </center></td></tr>\n    <tr><td style=\"padding:8px;\"><center>70 ≤ avg_score < 73</td></center> <td style=\"padding:8px;\"><center>B-</center></td></tr>\n    <tr><td style=\"padding:8px;\"><center>avg_score < 70     </td></center> <td style=\"padding:8px;\"><center>F </center></td></tr>\n</table>\n\n* 舉例來說，如果算出來的分數為 $69.\\bar{6}$ ，那麼你應該輸出一行 `\"F\"` （不含雙引號）。\n* 如果算出來的分數為 $99.\\bar{6}$ ，那麼你應該輸出一行 `\"A+\"` （不含雙引號）\n\n\n輸入只有一行，其包含三個整數，分別為你的物理，化學，生物成績。\n\n* 這三科的成績皆為介於 $0$ 到 $100$ 的整數。（包含 $0$ 和 $100$。）\n\n\n請依據你的平均分數對換等第表來輸出你的等第，句末需換行。\n",
    "output": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main() {\n    int a, b, c;\n    cin >> a >> b >> c;\n    double avg_score = (double)(a+b+c) / 3;\n    if (avg_score >= 90)\n        cout << \"A+\\n\";\n    else if (avg_score >= 85)\n        cout << \"A\\n\";\n    else if (avg_score >= 80)\n        cout << \"A-\\n\";\n    else if (avg_score >= 77)\n        cout << \"B+\\n\";\n    else if (avg_score >= 73)\n        cout << \"B\\n\";\n    else if (avg_score >= 70)\n        cout << \"B-\\n\";\n    else\n        cout << \"F\\n\";\n}\n"
  },
  {
    "id": "if03",
    "instruction": "> 故事前言請見**我們與裴裴的距離**。\n\n有鑒於 Peipei（裴裴）對資訊系的巨大貢獻，系上決定設置「裴裴獎學金」來延續電神裴裴福澤眾生的精神。傳說中，能獲得這個獎學金的人都會瞬間變身系核，坐擁無數朋友和粉絲，因此想要申請的人潮絡繹不絕，從系辦一路往外排宛如五月天演唱會。\n\n理所當然的，你也想申請裴裴獎學金。透過一些內線消息，你得知今年的審查標準如下：\n\n* 最高分的科目至少要獲得 $90$ 分。\n* 平均至少要有 $60$ 分。\n* 不能有任何一個科目不到 $40$ 分。\n\n三個條件都要滿足，你才可以獲得裴裴獎學金。\n\n請寫一個程式給定你自己的物理、化學和生物成績，計算是否能獲得裴裴獎學金。如果可以獲得，請輸出一行 `Y`；否則，請輸出一行 `N`。\n\n輸入只有一行，其包含三個整數，分別為你的物理、化學和生物成績。\n\n* 這三科的成績皆為介於 $0$ 到 $100$ 的整數。（包含 $0$ 和 $100$。）\n\n請輸出一行代表你是否能獲得裴裴獎學金，句末需換行。\n\n",
    "output": "#include <iostream>\n#include <iomanip>\nusing namespace std;\nint main() {\n    int a, b, c;\n    cin >> a >> b >> c;\n    if ((a >= 90 || b >= 90 || c >= 90) && a + b + c >= 180 && (a >= 40 && b >= 40 && c >= 40)) {\n\t\tcout << \"Y\\n\";\n\t}\n\telse {\n\t\tcout << \"N\\n\";\n\t}\n}\n"
  },
  {
    "id": "if04",
    "instruction": "在 IOI 國，有一位勇者，叫做 Zisk。他想要去討伐那時與 IOI 國不斷作對的 JOI 國，而他在每天不斷的打爆 JOI 後，終於迎來了最終的挑戰⋯⋯\n\n然而，已經連續一個禮拜打 JOI 的 Zisk 已經負荷不了了，在最終關卡體力不支昏倒了！作為 Zisk 的跟班，你必須幫忙給 JOI 國的國王最後的一擊，將 JOI 國徹底的消滅！你會同時發動兩個攻擊，攻擊力分別為 $a$ 和 $b$，而 JOI 國的國王會發動他的「最後的守備」。這個「最後的守備」有非常嚴謹的條件：它也會分別產生兩個數字 $c$ 和 $d$，分別會與兩個攻擊產生兩個「共振值」 $a \\text{ and } c$ 和 $b \\text{ and } d$，此處 $x \\text{ and } y$ 指的是邏輯且運算。只要有其中一個非零，就代表 JOI 國王防守成功，而反之則代表你將 JOI 國消滅了。\n\n⋯⋯這是你做的夢：Zisk 是不會被打倒的。但是你在醒來之後，就開始思考，怎麼樣 JOI 的國王才會被消滅呢？？？\n\n輸入只有一行，有 $4$ 個非負整數，分別是 $a, b, c, d(0 \\leq a, b, c, d < 2^{31})$。\n\n如果能夠消滅 JOI 國王，則請輸出一行 `KATSU`；否則，請輸出一行 `MAKE`。\n\n",
    "output": "#include <iostream>\n#define ericxiao ios_base::sync_with_stdio(0);cin.tie(0);\n#define endl '\\n'\nusing namespace std;\n\nint main() {\n\tericxiao\n\tint T, a, b, c, d;\n\tcin >> a >> b >> c >> d;\n\tif((a && c) || (b && d)){\n\t\tcout << \"MAKE\" << endl;\n\t} else {\n\t\tcout << \"KATSU\" << endl;\n\t}\t\n}\n"
  },
  {
    "id": "if05",
    "instruction": "在 Zisk 勇者小隊跟 JOI 國的國王開始交戰之後，他們發現國王異常的強大。然而，已經連續一個禮拜打 JOI 的 Zisk 已經負荷不了了，在最終關卡體力不支昏倒了！作為 Zisk 的跟班，你必須幫忙給 JOI 國的國王最後的一擊，將 JOI 國徹底的消滅！為了貫穿國王的防禦，打倒國王，小隊中的法師部隊和近戰部隊必須通力合作，在突破國王防護盾的瞬間給予致死的打擊。\n根據 Zisk 之前的判斷，小隊中的法師部隊的魔法攻擊力是 $a$，近戰部隊的物理攻擊力是 $b$，而國王防護盾的耐久值是 $c$，國王的體力是 $d$。要做到瞬間打倒國王只有兩種方案：\n1. 法師部隊貫穿國王的防護盾，再由近戰或法師部隊給國王最後的一擊。\n2. 近戰部隊打破國王的防護盾，再由近戰或法師部隊給國王最後的一擊。\n\n防護盾被破壞的條件是：魔法攻擊力大於**兩倍**防護盾的耐久值，或者物理攻擊力大於防護盾的耐久值。\n擊殺國王的條件是：魔法攻擊力大於等於國王的體力，或者物理攻擊力大於等於國王的體力。\n\n⋯⋯這是你做的夢：Zisk 是不會被打倒的。但是你在醒來之後，就開始思考，怎麼樣 JOI 的國王才會被消滅呢？？？\n給你一組這樣的可能設想（即 $a, b, c, d$），你可以對於這樣的設想，回答 JOI 國王是否會被消滅嗎？\n\n第一行包含 $4$ 個正整數，分別是 $a, b, c, d(1 \\leq a, b, c, d \\leq 10^9)$，以空白隔開。\n\n對於這個設想，如果能夠消滅JOI國王，則請輸出一行 `KATSU`；否則，請輸出一行 `MAKE`。\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int a,b,c,d;\n    cin >> a >> b >> c >> d;\n    if( (a > 2*c || b > c) && (a >= d || b >= d) )\n        cout << \"KATSU\\n\";\n    else cout << \"MAKE\\n\";\n}\n"
  },
  {
    "id": "if06",
    "instruction": "小明是個有選擇障礙的人，由於學校附近的食物都很好吃，他每天吃午餐都猶豫不決，常常因為猶豫太久來不及吃午餐而餓肚子。為了解決這個問題，他決定透過一個固定的方法來決定。他的學校附近有八間餐廳：極匠拉麵、勝千代拉麵、山嵐拉麵、小川拉麵、雞二拉麵、海拉麵、真劍拉麵、墨洋拉麵。他決定照天氣好不好、心情好不好把餐廳分類，再不行的話就擲骰子：\n\n* 天氣好\n\t* 心情好\n\t\t* 骰出 `1` 或 `2`：極匠拉麵（代號為 `1`）\n\t\t* 骰出 `3` 或 `4`：勝千代拉麵（代號為 `2`）\n\t\t* 骰出 `5` 或 `6`：山嵐拉麵（代號為 `3`）\n\t* 心情差\n\t\t* 小川拉麵（代號為 `4`）\n* 天氣差\n\t* 心情好\n\t\t* 骰出 `1` 或 `2`：雞二拉麵（代號為 `5`）\n\t\t* 骰出 `3` 或 `4`：海拉麵（代號為 `6`）\n\t\t* 骰出 `5` 或 `6`：真劍拉麵（代號為 `7`）\n\t* 心情差\n\t\t* 墨洋拉麵（代號為 `8`）\n\n現在，給你今天的天氣好壞、小明心情好壞、和骰子骰出的結果，請你預測小明今天的午餐會吃什麼。\n\n輸入總共只有一行。每行會有用空白分隔的三個數字，分別代表\n\n* `0/1`：天氣壞／好\n* `0/1`：心情壞／好\n* `1-6`：擲骰子的結果\n請輸出一個正整數，代表小明會去的餐廳的代號。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint weather, mood, dice;\n\tcin >> weather >> mood >> dice;\n\n\tif (weather) {\n\t\tif (mood) {\n\t\t\tif (dice <= 2) cout << \"1\\n\";\n\t\t\telse if (dice <= 4) cout << \"2\\n\";\n\t\t\telse cout << \"3\\n\";\n\t\t}\n\t\telse cout << \"4\\n\";\n\t} else {\n\t\tif (mood) {\n\t\t\tif (dice <= 2) cout << \"5\\n\";\n\t\t\telse if (dice <= 4) cout << \"6\\n\";\n\t\t\telse cout << \"7\\n\";\n\t\t}\n\t\telse cout << \"8\\n\";\n\t}\n}\n"
  },
  {
    "id": "if07",
    "instruction": "有一天鮑伯和艾麗絲在整理家裡的時候，發現了一個寫著「三角尼姆」的紙盒，打開一看發現裡頭有一個三角形的棋盤和一些棋子，像是某種桌遊。但是左看右看都找不到規則說明書，所以艾麗絲決定求助谷歌大神。他們在危機百科上查到以下規則：\n\n* 棋盤是一個由 $N$ 層圓圈組成的正三角形。\n* 兩方必須輪流在棋盤上擺放棋子，每次可以擺放一枚或三枚棋子，但所擺放的棋子必須相連一直線，且一格中最多只能放一枚棋子。\n* 擺放最後一枚棋子的就輸了。\n\n下圖給出了在 $N=8$ 時的一些可行動作：\n![](https://i.imgur.com/GATtERN.gif)\n\n這時候艾麗絲想知道在他先行的情況下，他有沒有一個必勝的策略。 \n\n本題有多筆輸入。輸入的第一行有一個整數 $T$，代表共有幾筆測試資料。\n\n每筆輸入只有一行包含一個正整數 $N$，代表三角形棋盤的邊長。\n\n* $1 \\le T \\le 100$\n* $1 \\le N \\le 100$\n\n對於每筆測試資料請輸出一行，如果艾麗絲有一個必勝策略請輸出 `Alice`，否則輸出 `Bob`。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint t; cin >> t;\n\twhile (t--) {\n\t\tint n; cin >> n;\n\t\tif ((n * (n + 1) / 2) % 2 == 0) cout << \"Alice\\n\";\n\t\telse cout << \"Bob\\n\";\n\t}\n}\n"
  },
  {
    "id": "if08",
    "instruction": "給你兩個矩形，判斷這兩個矩形是否相交，邊疊合不算。\n關於判斷矩形是否相交的解法可以參考[演算法筆記](https://web.ntnu.edu.tw/~algo/Shape.html)。\n\n輸入兩行，每行有四個整數，前兩個數字代表一個矩形的左下角頂點的座標 $(x, y)$，後兩個數字代表這個矩形的在 $x$ 方向與 $y$ 方向的長度。\n所有數字 $n$ 的範圍都在 $0\\le n\\le 1000$。\n\n如果兩個矩形有相交，輸出 `Yes`，否則輸出 `No`。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\n/* \nbool intersect(Rectangle r1, Rectangle r2)\n{\n\treturn !(r1.x2 < r2.x1 || r1.x1 > r2.x2 ||\n\t\t\tr1.y2 < r2.y1 || r1.y1 > r2.y2);\n}\n*/\n\nint main() {\n\tint a, b, c, d, e, f, g, h;\n\tcin >> a >> b >> c >> d >> e >> f >> g >> h;\n\n\tint x11 = a, y11 = b, x12 = a + c, y12 = b + d;\n\tint x21 = e, y21 = f, x22 = e + g, y22 = f + h;\n\tif (x12 <= x21 || x11 >= x22 || y12 <= y21 || y11 >= y22) {\n\t\tcout << \"No\\n\";\n\t}\n\telse {\n\t\tcout << \"Yes\\n\";\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "id": "if09",
    "instruction": "沒錯，這題和三角形有關。假設三角形的三邊長為 $a, b, c$ 且 $a \\leq b \\leq c$ ，請你依據以下規則來判斷這個三角形是哪種三角形\n\n* 若 $a + b \\leq c$ 則此組合構造不出三角形\n* 若 $a^2 + b^2 < c^2$ 則此三角形為鈍角三角形\n* 若 $a^2 + b^2 = c^2$ 則此三角形為直角三角形\n* 若 $a^2 + b^2 > c^2$ 則此三角形為銳角三角形\n\n輸入三個正整數 $x, y, z$ 代表三角形的三邊長，注意到他們不一定會從小到大排序，因此要先做一些處理才可以使用上述的判斷方法。\n\n* $0 < x, y, z < 30001$\n\n* 如果不能構成三角形，輸出 `Oh! No!`\n* 如果是鈍角三角形，輸出 `Obtuse`\n* 如果是直角三角形，輸出 `Right`\n* 如果是銳角三角形，輸出 `Acute`\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\n\t// sorting\n\tint tmp;\n\tif (a > b) {\n\t\ttmp = a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\n\tif (b > c) {\n\t\ttmp = b;\n\t\tb = c;\n\t\tc = tmp;\n\t}\n\n\tif (a > b) {\n\t\ttmp = a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\n\tstring res;\n\tint a2b2 = a * a + b * b;\n\tint c2 = c * c;\n\tif (a + b <= c) {\n\t\tres = \"Oh! No!\";\n\t} else if (a2b2 < c2) {\n\t\tres = \"Obtuse\";\n\t} else if (a2b2 == c2) {\n\t\tres = \"Right\";\n\t} else {\n\t\tres = \"Acute\";\n\t}\n\tcout << res << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "id": "if10",
    "instruction": "小羅最近在學習三種邏輯運算子 AND, OR 和 XOR。這三種邏輯運算子都是二元運算子，也就是說在運算時需要兩個運算元，例如 $a$ AND $b$。對於整數 $a$ 和 $b$，以下三個二元運算子的運算結果定義如下列三個表格：\n\n<table border=\"1\">\n    <tr> <th > <center> AND </center> </th>  <th style=\"padding:8px;\"> <center> $a = 0$ </center> </th> <th style=\"padding:8px;\"> <center>$a \\neq 0$</center> </th> </tr>\n    <tr><td style=\"padding:8px;\"><center> $b = 0$     </td></center> <td style=\"padding:8px;\"><center>$0$</center></td> </center> <td style=\"padding:8px;\"><center>$0$</center></td></tr>\n    <tr><td style=\"padding:8px;\"><center>$b \\neq 0$</td></center> <td style=\"padding:8px;\"><center>$0$ </center></td> </center> <td style=\"padding:8px;\"><center>$1$</center></td></tr>\n</table>\n\n<p></p>\n\n<table border=\"1\">\n    <tr> <th > <center> OR</center> </th>  <th style=\"padding:8px;\"> <center> $a = 0$ </center> </th> <th style=\"padding:8px;\"> <center>$a \\neq 0$</center> </th> </tr>\n    <tr><td style=\"padding:8px;\"><center> $b = 0$     </td></center> <td style=\"padding:8px;\"><center>$0$</center></td> </center> <td style=\"padding:8px;\"><center>$1$</center></td></tr>\n    <tr><td style=\"padding:8px;\"><center>$b \\neq 0$</td></center> <td style=\"padding:8px;\"><center>$1$ </center></td> </center> <td style=\"padding:8px;\"><center>$1$</center></td></tr>\n</table>\n\n<p></p>\n\n<table border=\"1\">\n    <tr> <th > <center> XOR </center> </th>  <th style=\"padding:8px;\"> <center> $a = 0$ </center> </th> <th style=\"padding:8px;\"> <center>$a \\neq 0$</center> </th> </tr>\n    <tr><td style=\"padding:8px;\"><center> $b = 0$     </td></center> <td style=\"padding:8px;\"><center>$0$</center></td> </center> <td style=\"padding:8px;\"><center>$1$</center></td></tr>\n    <tr><td style=\"padding:8px;\"><center>$b \\neq 0$</td></center> <td style=\"padding:8px;\"><center>$1$ </center></td> </center> <td style=\"padding:8px;\"><center>$0$</center></td></tr>\n</table>\n\n<p></p>\n\n請寫一個程式，輸入 $a, b$ 以及邏輯運算的結果，請輸出可能的邏輯運算為何。\n\n輸入只有一行，共三個整數值，整數間以一個空白隔開。\n第一個整數代表 $a$，第二個整數代表 $b$，這兩數均為非負的整數，且滿足 $0 \\leq a, b \\leq 10000$。\n第三個整數代表邏輯運算的結果，只會是 `0` 或 `1`。\n\n輸出可能得到指定結果的運算，若有多個，輸出順序為 `AND`、`OR`、`XOR`，每個可能的運算單獨輸出一行，每行結尾皆有換行。\n\n若不可能得到指定結果，輸出 `IMPOSSIBLE`。\n\n（注意輸出時所有英文字母均為大寫字母。）\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tif (a > 0) a = 1;\n\tif (b > 0) b = 1;\n\tbool impossible = true;\n\n\tif ((a & b)  == c) {\n\t\tcout << \"AND\\n\";\n\t\timpossible = false;\n\t}\n\t\n\tif ((a | b)  == c) {\n\t\tcout << \"OR\\n\";\n\t\timpossible = false;\n\t}\n\n\tif ((a ^ b)  == c) {\n\t\tcout << \"XOR\\n\";\n\t\timpossible = false;\n\t}\n\n\tif (impossible) {\n\t\tcout << \"IMPOSSIBLE\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "id": "loop01",
    "instruction": "<table style=\"border:1px solid #aaa;background-color:#f9f9f9;\">\n\t<tbody>\n        <tr>\n\t\t\t<td style=\"width:1px\"></td>\n\t\t\t<td>\n                <b><a href=\"/wiki/%E6%9C%AA%E8%A7%A3%E5%86%B3%E7%9A%84%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98\" title=\"\">未解決的數學問題</a>：</b>對所有自然數，如果它是奇數，則對它乘 3 再加 1，如果它是偶數，則對它除以 2，如此循環，最終都能夠得到 1。</td>\n            <td><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/b0/Question_mark2.svg/80px-Question_mark2.svg.png\" /> </td>\n\t\t</tr>\n    </tbody> \n</table>\n\n**考拉茲猜想**（英語：Collatz conjecture），又稱為**奇偶歸一猜想**、**3n+1 猜想**、**冰雹猜想**、**角谷猜想**、**哈塞猜想**、**烏拉姆猜想**或**敘拉古猜想**，是指對於每一個**正整數**，如果它是奇數，則對它乘 $3$ 再加 $1$，如果它是偶數，則對它除以 $2$，如此循環，最終都能夠得到 $1$。\n\n> 以上取自於[維基百科](https://zh.wikipedia.org/wiki/%E8%80%83%E6%8B%89%E5%85%B9%E7%8C%9C%E6%83%B3)。\n\n為了驗證考拉茲猜想的正確性，請你寫出一個程式使其可以輸入一個數字，輸出考拉茲猜想的過程直到 $1$ 為止。\n\n\n輸入只有一行，裡面只有一個數字 $x$，表示請你驗證考拉茲猜想的起始數字。\n* $1 \\le x \\le 1000$，且 $x$ 為整數。\n\n輸出過程的格式，請參照以下格式\n`x -> 下一步的x -> ... -> 1 -> end`，所有的數字以及箭頭都有空格，最後以換行結尾。\n舉例來說，如果輸入為 $1$，則你該輸出一行 `1 -> end`。\n如果輸入為 $18$，則你該輸出以下一行：\n`18 -> 9 -> 28 -> 14 -> 7 -> 22 -> 11 -> 34 -> 17 -> 52 -> 26 -> 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1 -> end`。\n",
    "output": "#include <iostream>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  if (n != 1) {\n    start:\n      cout << n << \" -> \";\n      if (n % 2 == 0) \n        n /= 2;\n      else\n        n = 3 * n + 1;\n      if (n != 1)\n        goto start;\n  }\n  cout << \"1 -> end\" << endl;\n  return 0;\n}"
  },
  {
    "id": "loop02",
    "instruction": "本題需要使用給定的亂數產生器，請以以下的格式送出解答。\n\n```c++\n#include <iostream>\nusing namespace std;\n \nunsigned LFSR() {\n  static unsigned short lfsr = 44257;\n  unsigned bit = ((lfsr >> 0) ^  (lfsr >> 2) ^  (lfsr >> 3) ^  (lfsr >> 5) ) & 1;\n  return lfsr =  (lfsr >> 1) | (bit << 15);\n}\n \nint main () {\n    // your code\n}\n```\n\n呼叫 `LFSR()` 會回傳一個題目需要的亂數。\nex: `int num = LFSR();`\n\n---\n\n<div style=\"display: flex;\"> \n    <div >\n        <h4> 題目本身 </h4>\n        <p> 在現實世界中，有很多是透過電腦生成的亂數來做事情的，最常見的例如虛擬賭場。到這裡如果你足夠聰明，你就會發現一件事情：只要你能夠知道它的亂數生成方式，以及它現在生成出哪些數字，你就可以完美預測之後的數字。因此這題的題目是：我們已經知道某個亂數生成器是利用我們上面所寫的函式 LFSR() 來產生出 0 到 n（包括 0 和 n），且不能被 k 整除（包括 0）的亂數。</p>\n        <span><b>知道這件事情的你，能夠預測這個亂數生成器產生出來的前五個亂數為何嗎？</b></span>\n        <h4> 提示 </h4>\n        <span><b>如果你看不懂上面的題目，可以參考下面的流程圖。</b></span>\n    </div>\n    <div><img src=\"https://i.imgur.com/MyjUeUu.png\" width=200px/>\n    </div>\n</div>\n\n#### 範例測資解說\n\n* 如果題目輸入 $n = 4, k = 3$，那麼我們依序呼叫 `LFSR()` 所產生出來的序列會長的像下面這樣子：\n  * 22128 → 43832 → 21916 → 10958 → 5479 → 35507 → 17753 → 8876 → 37206。\n\n* 如果我們把所有數字都對 $(n+1)$ 取餘數，得到的生成序列會長的像下面這樣子：\n  * 3 → 2 → 1 → 3 → 4 → 2 → 3 → 1 → 1\n* 我們在挑出符合條件的，也就是不能夠被 $k$ 整除的：\n  * 3 → **2** → **1** → 3 → **4** → **2** → 3 → **1** → 1\n* 因此，答案輸出為 `2 1 4 2 1`，**每個數字後接需附加換行**。\n\n輸入只有一行，裡面有兩個數字 $n, k$，代表題目所說的 $n, k$。\n* $1 \\le n, k \\le 65535$，且保證輸出一定會停止。\n\n輸出題目所說的偽亂數生成器產生出來的前五個數字，一行一個。\n",
    "output": "#include <iostream>\nusing namespace std;\n\nunsigned LFSR() {\n    static unsigned short lfsr = 44257;\n    unsigned bit = ((lfsr >> 0) ^ (lfsr >> 2) ^ (lfsr >> 3) ^ (lfsr >> 5)) & 1;\n    return lfsr = (lfsr >> 1) | (bit << 15);\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    int cnt = 0;\nstart:\n    int x = LFSR() % (n + 1);\n    if (x % k == 0)\n        goto start;\n    cout << x << endl;\n    cnt++;\n    if (cnt != 5)\n        goto start;\n    return 0;\n}\n"
  },
  {
    "id": "loop03",
    "instruction": "給你一個數字，請輸出其二進位制的寫法，倒著寫。舉例來說，$13$ 的二進位制是 $1101$，在這題我們需要印出一行 $1011$。\n輸入只有一行，裡面只有一個數字 $x$，代表我們想請你轉的數字。\n* $0 \\le x \\le 2^{60}$，且 $x$ 為整數。\n\n請輸出給定數字的二進位制，倒著的。\n",
    "output": "#include <iostream>\nusing namespace std;\nint main () {\n  long long x;\n  cin >> x;\n  do {\n    cout << x % 2;\n    x /= 2;\n  } while (x != 0);\n  cout << endl;\n  return 0;\n}"
  },
  {
    "id": "loop04",
    "instruction": "給你一個數字，請判斷其到底是否為質數。如果是，請輸出一行 `Yes`，否請輸出 `No`。\n什麼是質數呢？下面普奇神父（出自《JOJO 的奇妙冒險》）會告訴你。但請注意，數字 $1$ 並不算是質數。\n<center><img width=\"80%\" src=\"https://wiki.komica.org/images/1/1c/Img2998.jpg\" /></center>\n\n\n#### 如何對一個數字開根號？\n\n你可以利用官方內建的函式庫 `<cmath>` 裡面的 `sqrt` 函式來做到。其中 `sqrt` 的意思其實就是平方根（<b>SQ</b>uare <b>R</b>oo<b>T</b>）的意思。\n例如下面這份程式就可以對一個數字開根號並且印出來。需要特別注意的是，`sqrt` 所回傳的數字型態是 `double`。\n\n```c++\n#include <iostream>\n#include <cmath>\nusing namespace std;\nint main() {\n  long long x;\n  cin >> x;\n  cout << sqrt(x) << endl;\n  return 0;\n}\n```\n\n為什麼要在這裡講怎麼開根號呢？這個問題就留給你自己想了。\n輸入只有一行，裡面只有一個數字 $x$，代表我們想請你判斷的數字。\n* $1 \\le x \\le 2^{40}$，且 $x$ 為整數。\n\n請判斷給定的數字是否為質數。如果是，請輸出一行 `Yes`，否請輸出 `No`。\n",
    "output": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main() {\n  long long i = 2, x;\n  cin >> x;\n  bool is_prime = (x != 1);\n  while (i <= sqrt(x)) {\n    if (x % i == 0)\n      is_prime = false;\n    i += 1;\n  }\n  cout << (is_prime ? \"Yes\" : \"No\") << endl;\n  return 0;\n}"
  },
  {
    "id": "loop05",
    "instruction": "（註：這題的記憶體限制為 **16 MB**，跟其他題相比較少）\n\n**白銀御行（しろがね みゆき）**，站在第一名的位子是非常有壓力的。為了保證下一次的考試依舊可以穩坐第一名的位子，需要付出常人無法想像的努力以及血汗。不僅如此，在現實世界中，有時候還會被其他人所調侃，更因為自己的特殊地位而與別人之間多了一道旁人不敢攀談的鴻溝。反之，**四宮輝夜（四宮 かぐや）**一直都位居第二，雖然她並不甘心自己屈就第二，但客觀來說，其壓力比第一名的白銀御行要少非常多；畢竟挑戰者以及衛冕者的壓力可是差距非常大的。所以，**帆哥**有時候不禁會開始想：「第一名的位子有這麼重要嗎？」帆哥就因為每次考試與競賽都拿第一名，讓祂的生活處處充滿困擾。舉例來說，每個人見到帆哥的第一句話可能都是：「您。」、「您怎麼可以這麼電？」、「學霸請受我一拜 <(_ _)>。」、「<img width=\"30px;\" src=\"https://truth.bahamut.com.tw/s01/202007/cf15b54dbf2d3d14209371e50ae9edbf.GIF\" />」等等崇拜的話語（僅列舉些皮毛，族繁不及備載）。雖然憑藉祂聰穎的頭腦，並沒有畏懼被第二名反超的壓力，但也攢積了不少社交上的壓力。因此他決定在下次考試讓自己能夠多錯幾題，來使自己退居第二（因為祂就算沒有讀書也可以第一名，所以不讀書不是個選擇），將第一名的榮耀光環拱手讓給其他比較電但還是遠自己一大截的電神。\n\n綜上所說，帆哥有這樣子的困擾，所以想請你幫個忙。請寫出一個程式給定 $n$ 個非負整數的考試成績，輸出這些分數的第二高是多少，來讓帆哥知道第二名的水平究竟與自己差多遠，方便下次考試來推測出知道大概要錯多少題來讓自己的分數退居第二。\n\n一開始輸入一行，其有一個正整數 $n$ 以一個空格間隔，代表你有接下來有幾個分數。\n\n接下來會在輸入一行，這行有 $n$ 個非負整數 $x_i$，分別表示題目所述的 $n$ 個數字。\n\n* $2 \\le n \\le 10^6$\n* $0 \\le x_i \\le 2^{64}-1$，這行的意思是指 $x_i$ 在 `unsigned long long` 可儲存的範圍內\n\n\n輸出一個數字表示第二名的分數是多少，最後請記得換行。\n如果最高的兩個人同分的話，你就需要輸出最高的分數，因為帆哥寧願維持第一也不願落到第三。\n\n",
    "output": "#include <iostream>\nusing namespace std;\nint main () {\n  unsigned long long n, fmax, smax;\n  cin >> n;\n  for (int i=0; i<n; i++) {\n    unsigned long long x;\n    cin >> x;\n    if (i == 0 || x > fmax)\n      smax = fmax, fmax = x;\n    else if (i == 1 || x > smax)\n      smax = x;\n  }\n  cout << smax << endl;\n}"
  },
  {
    "id": "loop06",
    "instruction": "在一場比賽結束後，勝隊有 $N$ 個有投票權的選手選出最有價值玩家 (MVP)，並累積個人積分。如果所有票投給同一個人，那個人可以得到 $2$ 點積分，否則所有至少得到一票的人都可以得到 $1$ 點積分，沒有得到票的人得到 $0$ 點積分。\n\n你是編號 $x$ 的玩家，給一場比賽的投票資訊，請回答你得到了幾點積分。\n\n輸入第一行是兩個空白分隔的數字 $N, x$，分別代表玩家人數和你的編號。\n輸入第二行是 $N$ 個空白分隔的整數 $a_1, a_2, \\dots, a_N$，代表票投給幾號玩家。\n\n輸入保證 $1\\le N\\le 100$，$1\\le x, a_i\\le 1000$。\n\n輸出一行一個整數代表你得到的個人積分。\n\n",
    "output": "#include <iostream>\nusing namespace std;\nint main() {\n    int n,x;\n    cin >> n >> x;\n    bool all = 1, ext = 0;\n    for(int i = 0; i < n; i++) {\n        int y;\n        cin >> y;\n        if(y == x) ext = 1;\n        else all = 0;\n    }\n    cout << all + ext << endl;\n}\n"
  },
  {
    "id": "loop07",
    "instruction": "小 K 在廚房裡做甜點，若甜點中含有 $x$ 的糖（$x$ 為非負整數），則滿足感是 $A 2^x + B x^3 + C x$，已經知道甜點最多可以有 $n$ 的糖，請問滿足感最多是多少？\n\n輸入有兩行，第一行是滿足感係數 $A, B, C$，第二行是一個整數 $n$ 表示糖最多的量，數字間以空白分隔。\n\n輸入保證 $0\\le n \\le 50$，$-1000\\le A, B, C\\le 1000$。\n\n輸出一行一個整數表示最大滿足感。\n\n",
    "output": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main() {\n    long long A, B, C, n, mx;\n    cin >> A >> B >> C >> n;\n    for(long long x = 0; x <= n; x++) {\n        long long score = A * (long long)pow(2,x) + B * x*x*x + C*x;\n        if(x == 0 || score > mx){\n            mx = score;\n        }\n    }\n    cout << mx << endl;\n}\n"
  },
  {
    "id": "loop08",
    "instruction": "你最近在研究一種從暗物質中萃取出來的新粒子－暗粒子，為了更加的深入研究，你決定利用程式模擬在一個大小為 $N\\times M$ 的盒子中，兩顆一模一樣的暗粒子在二維方向上的移動軌跡。\n\n一開始你會設定兩顆暗粒子的初始座標 $(x_1, y_1)$ 以及 $(x_2, y_2)$、以及初始速度 $(dx_1, dy_1)$ 以及 $(dx_2, dy_2)$（單位為單位格／秒），為了兼顧模擬的方便性以及數值的精確性，你決定限制代表速度的四項數值 $dx_1, dx_2, dy_1, dy_2$ 皆為 $1$ 或是 $-1$。\n\n暗粒子屬於一種玻色子，所以暗粒子的位置可以與牆壁或是另一顆暗粒子的位置重合（也就是說其座標可以是 $(0, 0)$），然而此時將會反彈，反彈的方式遵照一般物體的二維彈性碰撞公式。暗粒子最特別的地方就在於，他的移動不是連續的，也就是說一顆位在 $(2, 4)$，速度為 $(1, 1)$ 的暗粒子會在一秒鐘後**瞬移**到 $(3, 5)$，也就是說他和另一顆位在 $(3, 5)$，速度為 $(-1, -1)$ 的暗粒子不會發生碰撞。\n\n請找出模擬 $t$ 秒之後，兩顆暗粒子的位置。\n\n註：兩顆一樣的球發生彈性碰撞時會交換速度。\n\n輸入有四行：\n\n第一行有兩個整數 $N, M\\ (1\\le N, M\\le 300)$，代表模擬場地在 $x$ 方向與 $y$ 方向的長度。\n\n第二行有四個整數 $x_1, y_1, x_2, y_2\\ (0\\le x_1, x_2\\le N)$ 且 $(0\\le y_1, y_2\\le M)$ 代表兩顆粒子的初始位置，保證兩粒子的初始位置不相同。\n\n第三行有四個整數 $dx_1, dy_1, dx_2, dy_2\\ (dx_1, dy_1, dx_2, dy_2 \\in \\lbrace 1, -1\\rbrace)$ 代表兩顆粒子的初始速度。\n\n第四行有一個正整數 $t\\ (1\\le t\\le 100000)$ 代表模擬的時間\n\n請輸出四個整數 $x_1, y_1, x_2, y_2$ 代表兩顆粒子的最終位置，每個數字之間以空白分隔。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    int dx1, dy1, dx2, dy2;\n    cin >> dx1 >> dy1 >> dx2 >> dy2;\n    int t;\n    cin >> t;\n    while (t--) {\n        if ((x1 == 0 and dx1 < 0) or (x1 == N and dx1 > 0))\n            dx1 *= -1;\n        if ((y1 == 0 and dy1 < 0) or (y1 == M and dy1 > 0))\n            dy1 *= -1;\n        if ((x2 == 0 and dx2 < 0) or (x2 == N and dx2 > 0))\n            dx2 *= -1;\n        if ((y2 == 0 and dy2 < 0) or (y2 == M and dy2 > 0))\n            dy2 *= -1;\n        if (x1 == x2 and y1 == y2) {\n            swap(dx1, dx2);\n            swap(dy1, dy2);\n        }\n        x1 += dx1;\n        y1 += dy1;\n        x2 += dx2;\n        y2 += dy2;\n    }\n    cout << x1 << ' ' << y1 << ' ';\n    cout << x2 << ' ' << y2 << '\\n';\n}\n"
  },
  {
    "id": "loop09",
    "instruction": "小瓏和小月一共要吃掉 $n$ 個快過期的西瓜，吃愈多西瓜可能會愈快樂，但也可能會愈不舒服。小瓏評估自己吃掉 $x$ 個西瓜的快樂值是 $A_1 x^2 + B_1 x + C_1$，小月評估自己吃掉 $x$ 個西瓜的快樂值是 $A_2 x^2 + B_2 x + C_2$，兩人想要分配這些西瓜使得他們吃完這些西瓜的總快樂值最大。請你回答這個最大總快樂值。西瓜一定要被吃完而不能丟掉。\n\n輸入有三行，第一行是小瓏的快樂係數 $A_1, B_1, C_1$，第二行是小月的快樂係數 $A_2, B_2, C_2$，第三行是一個整數 $n$ 表示西瓜數量，數字間以空白分隔。\n\n輸入保證 $1\\le n \\le 100$，$-1000\\le A_1, B_1, C_1, A_2, B_2, C_2\\le 1000$。\n其中 $50\\%$ 的測資保證 $n = 2$。\n\n輸出一行一個整數表示最大總快樂度。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int A1, B1, C1;\n    cin >> A1 >> B1 >> C1;\n    int A2, B2, C2;\n    cin >> A2 >> B2 >> C2;\n    int n;\n    cin >> n;\n    int mx = -1e9;\n    for(int i = 0; i <= n; i++) {\n        int score = A1 * i * i + B1 * i + C1 + A2 * (n-i) * (n-i) + B2 * (n-i) + C2;\n        mx = max(mx, score);\n    }\n    cout << mx << endl;\n}\n"
  },
  {
    "id": "loop10",
    "instruction": "小雞和小鴨常常講別人聽不懂的話，讓別人很困擾。經過多次觀察，你破譯了 `A B C D E F` 六個字元的加密方法，每個字元都被加密成四個 $0$ 或 $1$ 的數碼，對應如下：\n\n<table border=\"1\">\n    <tr> <th > <center> <code>A</code> </center> </th>  <th style=\"padding:8px;\"> <center> <code>B</code> </center> </th> <th style=\"padding:8px;\"> <center> <code>C</code> </center> </th> <th style=\"padding:8px;\"> <center> <code>D</code> </center> </th> <th style=\"padding:8px;\"> <center> <code>E</code> </center> </th> <th style=\"padding:8px;\"> <center> <code>F</code> </center> </th> </tr>\n    <tr><td style=\"padding:8px;\"><center> <code>0 1 0 1</code> </td></center> <td style=\"padding:8px;\"><center> <code>0 1 1 1</code> </center></td> </center> <td style=\"padding:8px;\"><center> <code>0 0 1 0</code> </center></td> </center> <td style=\"padding:8px;\"><center> <code>1 1 0 1</code> </center></td> </center> <td style=\"padding:8px;\"><center> <code>1 0 0 0</code> </center></td> </center> <td style=\"padding:8px;\"><center> <code>1 1 0 0</code> </center></td></tr>\n</table>\n\n<p></p>\n\n給你小雞和小鴨的密文，請你還原原本的字串，字串原文只會包含 `A B C D E F`。\n\n輸入第一行是一個正整數 $N$，表示有幾個字元被加密。\n接下來 $N$ 行每行四個 $0$ 或 $1$ 空白分隔的整數，一行代表被加密的一個字元。\n\n$50\\%$ 的輸入保證 $N = 1$。\n$50\\%$ 的輸入保證 $N \\le 4$。\n保證輸入一定可以被合法解密。\n\n輸出一行一個長度 $N$ 的字串表示解密後的文字。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; i++) {\n        int x = 0;\n        for(int j = 0; j < 4; j++) {\n            int y;\n            cin >> y;\n            x = x*2 + y;\n        }\n        switch (x) {\n            case 5:\n                cout << 'A';\n                break;\n            case 7:\n                cout << 'B';\n                break;\n            case 2:\n                cout << 'C';\n                break;\n            case 13:\n                cout << 'D';\n                break;\n            case 8:\n                cout << 'E';\n                break;\n            case 12:\n                cout << 'F';\n                break;\n        }\n    }\n    cout << endl;\n}\n"
  },
  {
    "id": "loop11",
    "instruction": "給你兩個數字 $n, m$ 並以空格分開，請輸出從 $nm$ 的指數表（左上角為 $0^0$，右下角為 $n^m$）。\n指數表的形式下面，如果 $n, m$ 分別是 $5, 5$，則請輸出以下的表。\n\n```\n1       0       0       0       0       0\n1       1       1       1       1       1\n1       2       4       8       16      32\n1       3       9       27      81      243\n1       4       16      64      256     1024\n1       5       25      125     625     3125\n```\n\n用 C++ 的形式來寫就是以下的表\n\n```\n\"1\\t0\\t0\\t0\\t0\\t0\\n\"\n\"1\\t1\\t1\\t1\\t1\\t1\\n\"\n\"1\\t2\\t4\\t8\\t16\\t32\\n\"\n\"1\\t3\\t9\\t27\\t81\\t243\\n\"\n\"1\\t4\\t16\\t64\\t256\\t1024\\n\"\n\"1\\t5\\t25\\t125\\t625\\t3125\\n\"\n```\n\n#### 小小官方提示\n\n你不覺得這跟九九乘法表 87% 像嗎？\n\n輸入只有一行，裡面只有兩個數字 $n, m$。\n* $0 \\le n, m \\le 10^5$，保證印出的最大數字在 `int` 的範圍之內。\n\n輸出對應的指數表，並且我們保證最大印出的數在 `int` 之內。\n",
    "output": "#include <iostream>\nusing namespace std;\nint main () {\n  int n, m;\n  cin >> n >> m;\n  for (int i=0; i<=n; i++) {\n    for (int j=0; j<=m; j++) {\n      // 想要印出 i^j\n      int x = 1;\n      for (int k=1; k<=j; k++) {\n        x *= i;\n      }\n      cout << x  << (j != m ? '\\t' : '\\n');\n    }\n  }\n}"
  },
  {
    "id": "loop12",
    "instruction": "\n#### 故事\n\n很久很久以前，有一個機器人。它有著一個深愛它的主人 Stanley。在 Stanley 小的時候，常常對它下 `WASD` 的指令來操控這個機器人，只要輸入指令 `W`，機器人就會往上一格，`A` 是往左一格，`S` 是往下一格，`D` 是往右一格。雖然這機器人的功能陽春，但小 Stanley 還是玩得不亦樂乎，與之度過了童年。\n\n#### 題目\n\n輸入 Stanley 箱子的長 $m$ 與寬 $n$，機器人的座標 $x, y$，以及接受到的指令數量 $Q$，請輸出每個指令接收後，箱子內部的樣子。\n需要注意的是，要是執行指令後機器人會超出箱子的範圍，那麼機器人會自動忽略這個指令，但即便忽略了指令也要輸出現在箱字內部的樣子。\n請用 `@` 表示機器人，`.` 表示空地。\n\n#### 範例測資解釋\n\n<center><img src=\"https://i.imgur.com/RbtCjwg.png\" width=\"90%\"></center>\n\n* 左邊的 `1 2 3` 是行號，不用輸出，對應的輸入輸出請見範例輸入輸出。\n\n輸入有兩行：\n* 第一行有五個數字，分別代表題目的 $n, m, x, y, Q$。\n    * $1 \\le n, m, Q$\n    * $0 \\le x < n$\n    * $0 \\le y < m$\n    * $1 \\le Qnm \\le 10^4$\n* 第二行有一個長度為 $Q$ 的字串，每個字元依序代表著機器人的指令。\n    * 字元只會有 `WASD`，分別代表機器人的指令為上左下右。\n對於每個指令，輸出其執行完後的箱字內部的狀態，請用 `@` 表示機器人，`.` 表示空地。\n\n",
    "output": "#include <iostream>\nusing namespace std;\nint main () {\n  int n, m, x, y, Q;\n  cin >> n >> m >> x >> y >> Q;\n  while (Q--) {\n    char cmd;\n    cin >> cmd;\n    if (cmd == 'W' && x != 0) x--;\n    else if (cmd == 'A' && y != 0)  y--;\n    else if (cmd == 'S' && x != n-1) x++;\n    else if (cmd == 'D' && y != m-1) y++; \n    for (int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n        if (i == x && j == y) \n          cout << '@';\n        else\n          cout << '.';\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "id": "loop13",
    "instruction": "先讓我們來看個影片。\n\n<center>\n<iframe width=\"1120\" height=\"600\" src=\"https://www.youtube.com/embed/f3MDGKw0wdg\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n<span style=\"color:gray;\">Music: Oshama Scramble!, Artist: t+pazolite</span>\n</center>\n\n奶貓みるく<img src=\"https://i.imgur.com/plaprAh.png\" width=40px/>為了想要跟黑貓しゃま<img src=\"https://i.imgur.com/mPIc19B.png\" width=40px>擁有一樣的身材，每天努力喝牛奶跟鍛鍊身體，希望有朝一日可以成功。（影片中雖然是有變成功但是這是靠黑貓しゃま<img src=\"https://i.imgur.com/mPIc19B.png\" width=40px>的魔法，不算數！）某天黑貓しゃま<img src=\"https://i.imgur.com/mPIc19B.png\" width=40px>就知道了自己可以<span style=\"background-color:black;\">難以描述所以就不寫了</span>的訣竅，就是喝一瓶牛奶，總共喝 $n$ 天就可以成功了！為了要讓奶貓みるく<img src=\"https://i.imgur.com/plaprAh.png\" width=40px/>可以知道自己還差多少天，貼心的你想要寫一個程式告訴他離目標還差多遠。這該怎麼時做呢？請在奶貓喝第 $k$ 瓶牛奶的時候，印出 $n-k$ 個 `_` 和 $k$ 個 `+` 來表示奶貓的進度條。（所以跑起來會很像是從左到右長的進度條。）\n\n不過一天一天印出來實在是有點浪費時間，所以你想要一次把第 $1$ 天到第 $n$ 天的進度條都印出來。舉例來說，如果 $n = 5$，那麼第一天你會印 `____+`，第二天你會印 `___++`，以此類推，你會印出像下面這樣子的文字：\n\n```\n____+\n___++\n__+++\n_++++\n+++++\n```\n\n想得很簡單做卻不好說，你能夠用程式實作出來嗎？\n\n<center>\n    <img src=\"https://i.imgur.com/Gc9LDkr.png\" width=\"70%\">\n    <span style=\"color:gray;\">奶貓問號</span>\n</center>\n\n#### 非常重要的註記\n\n影片中的歌曲《Oshama Scramble!》是出自於一款名為 maimai 的音樂遊戲，不是出自於 Cytus II<img src=\"https://i.imgur.com/Z4phOAY.jpg\" width=40px>，也不是出自於 Arcaea<img src=\"https://g.qoo-img.com/RjSbKHs2qd1Hid5FV_g7EhdI56mrOd-ipEx5ftFdFkId58djQMkf1WCNSnPKssDCvHs=w192\" width=40px>。\n\n\n輸入只有一個整數，表示題目的數字 $n$。\n* $1 \\le n \\le 1000$ ，且 $n$ 為整數。\n\n第 $1$ 天到第 $n$ 天的進度條都印出來，需要注意每天的進度條後都需要換行。\n",
    "output": "#include <iostream>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  for (int i=0; i<n; i++) {\n    for (int j=0; j<n; j++) {\n       if (i+j >= n-1)\n         cout << \"+\";\n       else\n         cout << \"_\";\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "id": "loop14",
    "instruction": "可視化方程式是個對於理解解析幾何頗有幫助的工具，今天大明想要做個工具來輔助他判斷他畫的方程式圖形是否正確，能請你幫他寫個程式幫幫他嗎？\n要完成的程式需求如下：\n對於一個二元二次不等式 $ax^2 + bxy + cy^2 + dx +ey  \\ge f$ 把 $(0,0)$ 到 $(n,m)$ 中滿足不等式的整數點（$x,y$ 值皆為整數的點）標上 `*` 號，不滿足的點留下空白。\n\n注意：本題的 $x$ 軸正向朝右邊，$y$ 軸正向朝上，也就是 $(0,0)$ 會在左下角，$(n,m)$ 會在右上角。\n\n#### 範例測資解釋\n\n![image](https://i.imgur.com/1gvZ92a.png)\n\n\n第一行有兩個正整數 $n,m$ 代表要計算的範圍。\n第二行有六個整數 $a,b,c,d,e,f$ 代表要計算的不等式為 $ax^2 + bxy + cy^2 + dx + ey  \\ge f$。\n\n- $1 \\le n,m \\le 100$\n- $-1000 \\le a,b,c,d,e,f \\le 1000$\n\n一個大小為 $(n+1)\\times (m+1)$，由 `*` 和空白組成的矩形，`*` 代表該點滿足不等式，空白代表該點不滿足。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint n,m;\n\tcin >> n >> m;\n\tint a,b,c,d,e,f;\n\tcin >> a >> b >> c >> d >> e >> f;\n\tfor(int i=0; i<=m; i++)\n\t{\n\t\tfor(int j=0; j<=n; j++)\n\t\t{\n\t\t\tint x = j;\n\t\t\tint y = m - i;\n\t\t\tif( a*x*x + b*x*y + c*y*y + d*x + e*y >= f)\n\t\t\t\tcout<<\"*\";\n\t\t\telse\n\t\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n"
  },
  {
    "id": "loop15",
    "instruction": "給一個正整數 $N$，請你由小到大輸出他的質因數分解。\n\n輸入只有一行一個正整數 $N$，表示要分解的整數。輸入保證 $2\\le N\\le 10^9$。\n\n輸出一行若干個質數 $P_1, P_2, \\dots, P_k$，整數間以空白分隔，且滿足 $N = P_1P_2 \\dots P_k$ 和 $P_1\\le P_2\\le \\dots \\le P_k$。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int N;\n    cin >> N;\n    int sq = sqrt(N);\n    bool space = 0;\n    while(N > 1) {\n        int t = N;\n        for(int i = 2; i <= sq; i++)  {\n            if(N%i == 0) {\n                if(space) cout << \" \";\n                space = 1;\n                cout << i;\n                N /= i;\n                break;\n            }\n        }\n        if(t == N) break;\n        sq = sqrt(N);\n    }\n    if(N > 1) {\n        if(space) cout << \" \";\n        cout << N << endl;\n    }\n}\n"
  },
  {
    "id": "loop16",
    "instruction": "小星很喜歡菱形，所以想請你寫個程式來印出星號 `*` 構成的大小為 $n$ 的菱形，菱形一共佔 $n$ 行，每一行的星號數量依序為 $1, 3,\\dots n-2, n, n-2,\\dots , 3, 1$，而每一行正中間的星號需要對齊，如需範例，請參考範例測資。\n\n一個奇數 $n$，代表要印出的菱形大小。\n\n- $1 \\le n \\le 100$\n\n一個橫軸長跟縱軸長都是 $n$ 的菱形，請見範例。\nNote：請使用半形空格來對齊星號的位置，不要輸出多餘的空格。\n\n",
    "output": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin >> n;\n\tint star_n = 1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<(n-star_n)/2;j++)\n\t\t\tcout<<\" \";\n\t\tfor(int j=0;j<star_n;j++)\n\t\t\tcout<<\"*\";\n\t\tif(i < n/2)\n\t\t\tstar_n+=2;\n\t\telse\n\t\t\tstar_n-=2;\n\t\tcout << endl;\n\t}\n}\n"
  },
  {
    "id": "loop17",
    "instruction": "老陳想來開一家店，但根據當地神奇的法規，正職員工和約聘員工的人數有以下限制：令正職員工有 $x$ 人，約聘員工有 $y$ 人，$x,y$ 需滿足以下三條關係式：\n1. $a_1 x + b_1 y \\le c_1$\n2. $a_2 x + b_2 y \\le c_2$\n3. $a_3 x + b_3 y \\le c_3$\n\n並且沒辦法聘超過 $1000$ 個正職員工或超過 $1000$ 個約聘員工。\n每位正職員工能帶來 $u_x$ 的產值，每位約聘員工能帶來 $u_y$ 的產值，請幫他計算最高能有多少的產值。\n\n第一行有兩個數字 $u_x,u_y$。\n接下來三行每行有三個數字 $a_i,b_i,c_i$。\n\n- $1 \\le u_x,u_y \\le 1000$\n- $0 \\le a_i,b_i,c_i \\le 1000\\ \\forall i$\n\n最高能達到多少的產值，如果他沒辦法聘用任何員工，請輸出 $0$。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint a1,a2,a3;\n\tint b1,b2,b3;\n\tint c1,c2,c3;\n\tint ux,uy;\n\tcin >> ux >> uy;\n\tcin >> a1 >> b1 >> c1;\n\tcin >> a2 >> b2 >> c2;\n\tcin >> a3 >> b3 >> c3;\n\tint max_u = 0;\n\tfor(int i=0; i<=1000; i++)\n\t{\n\t\tfor(int j=0; j<=1000; j++)\n\t\t{\n\t\t\tif( (a1*i + b1*j <= c1) &&\n\t\t\t\t(a2*i + b2*j <= c2) &&\n\t\t\t\t(a3*i + b3*j <= c3))\n\t\t\t\tmax_u = max(max_u, ux*i + uy*j);\n\t\t}\n\t}\n\tcout << max_u << endl;\n}\n"
  },
  {
    "id": "loop18",
    "instruction": "某天小明在數學課時覺得很無聊，便拿起筆在課本上畫畫。正當他覺得無聊而抬起頭的時候，碰巧老師正在介紹什麼是開根號。「哼，開根號這種東西日常生活中又用不到？我買菜會需要用到開根號嗎？到底學會這個做什麼？」\n\n這時數學老師走了過來，發現小明將課本畫得亂七八糟的，決定要出個作業給這位頑皮的學生，寫不出來就當掉！老師變跟小明說：「我明天會給你一個數字 $n$，請你在 1 秒鐘之內告訴我 $\\sqrt{n}$ 的正確值並無條件捨去至小數點後第五位。」\n\n偷懶的小明明當然沒有辦法正確的算出根號值，你能幫幫他寫出一個程式計算出結果嗎？\n\n輸入只有一行，包含一個整數 $n(0\\le n\\le 10000)$。\n\n輸出一行具有五位小數之浮點數，代表 $\\sqrt{n}$ 之值。若答案之小數不到五位也需補上 $0$。\n\n",
    "output": "// loop XX Sqrt\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tlong long n, x;\n\n    cin >> n;\n\n\tfor (x = 0; x <= 100; x++) {\n        if ((x+1)*(x+1) > n) {\n            break;\n        }\n    }\n\n    cout << x << '.';\n\n    for (int digit = 0; digit < 5; digit++) {\n        n *= 100;\n        x *= 10;\n        for (int i = 0; i <=9; i++) {\n            if ((x+i+1)*(x+i+1) > n) {\n                cout << i;\n                x += i;\n                break;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "id": "recursion01",
    "instruction": "請問警報器長鳴為一次需 $3$ 秒，短鳴一次需 $1$ 秒，每格鳴聲之間停 $2$ 秒。\n請問若鳴聲時間為 $t$ 秒，有多少種信號組合？\n\n* 開頭跟結尾必須是鳴聲，也就是從第一個鳴聲的開頭到最後一個鳴聲結尾總共 $t$ 秒。\n\n如果我們要求 $6$ 秒，則答案為 $2$，因為只有下面兩種組合長度為 $t$ 秒。\n\n![image](https://i.imgur.com/EkCvCh3.png)\n\n<center>\n<img src=\"https://i.imgur.com/EkCvCh3.png\" width=\"80%\"/>\n<span style=\"color:gray;\">6 秒鳴聲的唯二可能</span>\n</center>\n\n官方的小小提示：如果 $f(t)$ 代表的是 $t$ 秒鳴聲的組合總數，那麼下面公式成立。\n\n$$\nf(t)=\n\\begin{cases}\n1, \\text{if } t = 1\\text{, or }t = 3 \\newline\n0, \\text{if } t \\le 0 \\newline\nf(t-5)+f(t-3), \\text{otherwise}\n\\end{cases}\n$$\n\n#### 無關緊要的小提示\n\n你知道你電腦壞掉的時候，有時候會發出長鳴短鳴，那些其實都可以對應到你電腦是壞在哪裡。\n\n輸入只有一行，其包含一個整數 $t$，代表我們要求的是 $t$ 秒長的鳴聲組合數有幾種。\n\n- $1 \\le t \\le 100$ \n\n輸出一行一個整數，代表我們要求的是 $t$ 秒長的鳴聲組合數有幾種。\n\n- 保證答案可以使用 `int` 存起來。\n\n",
    "output": "#include <iostream>\n\nint f(int t) {\n  if (t == 1 || t == 3)\n    return 1;\n  else if (t <= 0)\n    return 0;\n  else\n    return f(t-5) + f(t-3);\n}\n\nint main() {\n    int t;\n    std::cin >> t;\n    std::cout << f(t) << std::endl;\n}\n"
  },
  {
    "id": "recursion02",
    "instruction": "現在 Peipei（裴裴）要請你做出一個漂亮的彩帶，每一段你可以選擇三種顏色，分別是紅，橘，藍三種。\n至於何為漂亮呢？漂亮的彩帶有以下的限制：\n\n* 不能有連續的紅色。\n* 橘色後面一定要接藍色。\n\n你可以告訴我們如果彩帶的長度為 $n$，有幾種可能的漂亮的彩帶嗎？\n\n舉例來說，如果題目輸入 $2$，你就必須輸出 $6$，因為答案有以下六種。\n\n![image](https://i.imgur.com/sT4cU1d.png)\n\n#### 官方提示\n\n* 遞迴的參數可以不只一個 $n$，再多設一個會好寫很多。\n\n輸入只有一行，表示題目的數字 $n$。\n\n* $1 \\le n \\le 50$，且 $n$ 為整數。\n\n輸出一行一個整數，表示長度 $n$ 的漂亮彩帶的可能數。\n",
    "output": "#include <iostream>\n#define MAXN 51\n#define MAXTYPE 3\n#define RED 0\n#define ORANGE 1\n#define BLUE 2\nusing namespace std;\n\nbool visit[MAXN][MAXTYPE];\nlong long DP[MAXN][MAXTYPE];\nlong long rec(int n, int type) {\n  if (n == 1)\n    return 1;\n  else if (visit[n][type])\n    return DP[n][type];\n  else if (type == RED)\n    DP[n][type] = rec(n-1, BLUE);\n  else if (type == BLUE)\n    DP[n][type] = rec(n-1, ORANGE) + rec(n-1, BLUE) + rec(n-1, RED);\n  else if (type == ORANGE)\n    DP[n][type] = rec(n-1, BLUE) + rec(n-1, RED);\n  else // Should not reach here.\n    return 0;\n  visit[n][type] = true;\n  return DP[n][type];\n}\nint main () {\n    int n;\n    cin >> n;\n    cout << rec(n, RED) + rec(n, ORANGE) + rec(n, BLUE) << endl;\n    return 0;\n}\n"
  },
  {
    "id": "recursion03",
    "instruction": "現在有 $n$ 個**正整數**，請問你可不可以從中間選幾個數字使其加總為 $k$？\n如果可以輸出 `YES`，否則輸出 `NO`。（數字不能重複選擇。）\n\n舉例來說，如果有五個數字，分別是 `[3, 7, 11, 9, 4]`：\n\n* 如果目標 $k$ 為 $16$，則要輸出 `YES`，因為 $9+7=16$。\n* 如果目標 $k$ 為 $17$，則要輸出 `NO`，因為不管怎麼選擇都無法讓加總變成 $17$。\n\n#### 官方小小提示\n\n* 如果現在可以選五個數字，分別是 `[3, 7, 11, 9, 4]`（也就跟上面的舉例一樣），那麼遞迴樹大概會長的像下面這張圖一樣，你可以用這張圖去思考你的遞迴該怎麼實作。\n\n<center>\n    <img src=\"https://i.imgur.com/PRyFLwF.png\" width=\"80%\"/>\n    <span style=\"color:gray;\">大致的遞迴樹長相</span>\n</center>\n\n\n一開始輸入一行，其有兩個正整數 $n,k$ 以一個空格間隔，分別代表你有幾個數字可以選擇，以及題目所給定的目標 $k$。\n\n接下來會在輸入一行，這行有 $n$ 個正整數 $x_i$，分別表示你可以選的數字。\n\n* $1 \\le n \\le 25$\n* $1 \\le k, \\sum_{i=0}^{n-1}x_i \\le 2^{32}-1$，這行的意思是指所有 $x_i$ 加總以及 $k$ 都不會超過 `int` 的大小。\n\n\n輸出一行 `YES` 或 `NO`，表示目標 $k$ 可不可以從題目所給的 $n$ 個數字中選幾個數字使其加總為 $k$。\n\n\n",
    "output": "#include <iostream>\n#define MAXN 25\nusing namespace std;\n\nint k, A[MAXN], n;\n\nbool rec (int i, int S) {\n  if (S > k)\n    return false;\n  if (i == n)\n    return S == k;\n  else\n    return rec(i+1, S+A[i]) || rec(i+1, S);\n}\n\nint main () {\n  cin >> n >> k;\n  for (int i=0; i<n; i++)\n    cin >> A[i];\n  cout << (rec(0, 0) ? \"YES\" : \"NO\") << endl;\n}"
  },
  {
    "id": "recursion04",
    "instruction": "每個人的生命中都有各自的拍數。\n假設大家的拍子都從第 $1$ 秒開始，請問下一次大家剛好在同個時間打拍子是什麼時候？\n\n- 保證答案在 `long long` 範圍內。\n\n\n\n舉例來說，如果有兩個人，分別為 A 和 B，A 和 B 的拍數分別為 $3$ 和 $4$，那麼下次同時打拍子，如下圖，會在第 $12$ 秒。因此答案為 $12$。\n\n![](https://i.imgur.com/jvH7z88.png)\n\n#### 官方的小提示\n\n* 提供一個很快的最大公因數函式，可以使用著個函式求解。\n\n```c++\nlong long GCD (long long a, long long b) {\n  if(a == 0 || b == 0)\n    return a + b;\n  return GCD(b, a % b);\n}\n```\n\n\n\n\n一開始輸入一行，其只有一個 $n$，表示接下來有幾個人的心跳拍子數。\n\n接下來輸入 $n$ 行，每行有一個數字 $p_i$，表示第 $i$ 個人的心跳拍子數。\n\n* $1 \\le n \\le 10^5$\n* $1 \\le p_i \\le 2^{63}-1$\n\n\n輸出一行一個整數，表示下一次大家剛好在同個時間打拍子在什麼時候。\n\n* 保證答案可以用 `long long` 保存，也就是答案會介於 $-2^{63}$ 和 $2^{63}-1$ 之間。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nlong long GCD(long long a, long long b) {\n  if(a * b == 0)\n    return a + b;\n  return GCD(b, a % b);\n}\n\nlong long LCM(long long a, long long b) {\n    return a / GCD(a, b) * b;\n}\n\nint main() {\n  long long n, ans = 1, x;\n  cin >> n;\n  for (int i=0; i<n; i++) {\n    cin >> x;\n    ans = LCM(ans, x);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "id": "recursion05",
    "instruction": "貝爾三角形是種符合以下特性的，數字組成的直角三角形：\n1. 每行的長度都比上一行多一。\n2. 每行的開頭是上一行的最後一個數字。\n3. 每行第二個以後的數字，會是它左邊跟左上角數字的和。\n現在，給你貝爾三角形的起始數字與高度，請輸出完整的貝爾三角形。\n\n第一行有兩個數字 $s,h$，代表起始數字與高度。\n\n- $1 \\le s \\le 10^9$\n- $1 \\le h \\le 1000$\n\n貝爾三角形，其中的數字可能很大，所以請輸出每一項除以 $10^9+7$ 的餘數。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n#define P 1000000007\nvector<int> gen(vector<int> last);\nint main() {\n\tint s,h;\n\tcin >> s >> h;\n\tvector<int> last(1,s);\n\tcout << s << endl;\n\tfor(int i=1; i<h;i++)\n\t{\n\t\tvector<int> cur = gen(last);\n\t\tfor(int j:cur)\n\t\t\tcout << j << \" \";\n\t\tcout << endl;\n\t\tlast = cur;\n\t}\n}\nvector<int> gen(vector<int> last)\n{\n\tint len = last.size() + 1;\n\tvector<int> ret(1,last.back());\n\tfor(int i=1; i<len; i++)\n\t\tret.push_back( (ret[i-1] + last[i-1]) % P );\n\treturn ret;\n}\n"
  },
  {
    "id": "recursion06",
    "instruction": "桌上有一盒積木，每個積木的大小都是 $1\\times 2$，而旁邊有一個大小為 $n\\times 3$ 的盒子，如果要用積木將盒子排滿，有幾種方法呢？\n\n舉例來說，如果 $n=2$，你就必須輸出 $3$，因為答案有以下三種。\n\n![](https://i.imgur.com/vMsSgac.png)\n\n而當 $n=4$ 時，就必須輸出 $11$，有以下十一種排法。\n\n![](https://i.imgur.com/nSQHGSF.png)\n\n* 提示：\n\n1. 一個 $4\\times 3$ 的盒子的最上面一排只有這三種排法\n\n![](https://i.imgur.com/jR2jedv.png)\n\n2. 而這個區域可以分為這兩種情形\n![](https://i.imgur.com/wwvihRJ.png)\n\n\n輸入只有一行，表示題目的數字 $n$。\n\n* $1 \\le n \\le 50$，且 $n$ 為偶數。\n\n輸出一行一個整數，表示排滿盒子的可能數。\n\n",
    "output": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nll A[100] = {0}, B[100] = {0};\n\nll find_A(int n);\n\nll find_B(int n);\n\nll find_A(int n) {\n    if (n == 1) return 1;\n    if (A[n]) return A[n];\n    return A[n] = find_A(n - 1) + find_B(n - 1);\n}\n\nll find_B(int n) {\n    if (n == 1) return 3;\n    if (B[n]) return B[n];\n    return B[n] = 2 * find_A(n) + find_B(n - 1);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << find_B(n/2) << endl;\n}\n\n/*\nType A:\n\n* *\nA1 = 1\n\n* *\n* * *\n* * *\nA2 = A1 + B1 = 4\n\n* *\n* * *\n* * *\n* * *\n* * *\nA3 = A2 + B2 = 15\n\nType B:\n\n* * *\n* * *\nB1 = 3\n\n* * *\n* * *\n* * *\n* * *\nB2 = 2 * A2 + B1 = 11\n\n* * *\n* * *\n* * *\n* * *\n* * *\n* * *\nB3 = 2 * A3 + B2 = 11\n\n*/"
  },
  {
    "id": "recursion07",
    "instruction": "水族箱像大海一樣，是非常冷酷無情的。魚吃飼料，魚吃魚是水中世界裡面絕對的規則。現在呢，就是想要模擬水族箱內的情況。為了簡化問題，水族箱內只有飼料和魚兩種東西，而各自都有各自的「飽滿值」。並且如果一隻魚 $a$ 依序吃了飽滿度為 $x, y, z$ 的東西之後，其飽滿度變成 $k$ 的話，則記為 $a(x, y, z) = k$。飽滿值的規則如下：\n\n- 對於飼料來說，它的飽滿度就是一個數字 $x$。\n- 魚有三種，分別分為 $f$ 魚、$g$ 魚、與 $h$ 魚（分別簡稱 $f, g, h$）。$f$ 只能吃一個東西，且它的規則為 $f(x) = (2x - 3) \\mod 998244353$。$g$ 魚可以吃兩樣東西，它的規則為 $g(x, y) = (2x + y - 7) \\mod 998244353$；$h$ 魚吃得最多，可以吃三樣東西，且它吃的規則為 $h(x, y, z) = (3x - 2y + z) \\mod 998244353$。請注意，吃東西的順序是有差的。\n\n我們可以將一天下來的相食關係表示為一串函數合成，如 `h(4, g(2, 4), f(g(3, 4)))` 或 `f(f(f(4)))`。現在，我們將所有的逗號和括弧都替換成空白輸入，請算出最後一條魚的飽滿值吧！\n\n\nTLDR：給你三個函數 $f(x) = 2x - 3$、$g(x,y) = 2x + y - 7$、$h(x, y, z) = 3x - 2y + z$，和一個去除括弧的函數合成式，請求這個式子的計算結果。\n\n輸入有兩行。第一行為一個數字 $N(1 \\leq N \\leq 1500)$ 代表項數。接下來，會有 $N$ 個以空白分隔的符號，可能為 `f`、`g`、`h`，或一個絕對值不超過 $1000$ 的整數。\n\n保證輸入是一個合法的式子（e.g. 不會有 `g 2` 這種輸入）。\n\n請輸出一個數字，代表答案。\n",
    "output": "#include <iostream>\n#include <string.h>\n#include <algorithm>\n#define int long long int\nusing namespace std;\n\nconst int M = 998244353;\n\ninline int f(int x){\n    return (M + 2 * x - 3) % M;\n}\n\ninline int g(int x, int y){\n    return (2 * x + y - 7 + M) % M;\n}\n\ninline int h(int x, int y, int z){\n    return (3 * x - 2 * y + z + 2 * M) % M;\n}\n\nint parse(){\n    string s;\n    cin >> s;\n    int x, y, z;\n    if(s == \"f\"){\n        x = parse();\n        return f(x);\n    } else if(s == \"g\"){\n        x = parse();\n        y = parse();\n        return g(x, y);\n    } else if(s == \"h\"){\n        x = parse();\n        y = parse();\n        z = parse();\n        return h(x, y, z);\n    } \n    return stoll(s);\n}\n\n\nsigned main() {\n    int n;\n    cin >> n;\n    cout << parse() << endl;    \n}\n"
  },
  {
    "id": "recursion08",
    "instruction": "在一個昏暗的晚上，佳佳走在馬路上，被一輛大卡車撞死了，然而他的人生沒有就此結束。佳佳帶著天分被送到了異世界，並成為了一名冒險者。在看公會委託板時，佳佳可以用他的鑑定眼看出達成委託的所需時間。但佳佳的數學能力已經被大卡車摧毀了，你能幫他算出他最多能賺多少錢嗎？\n\n註：一個委託只能完成一次\n\n輸入第一行有兩個正整數 $N, T\\ (1 \\leq N \\leq 20, 1 \\leq T \\leq 10^4)$，$N$ 代表委託數量，$T$ 代表佳佳有的時間。\n接下來有 $N$ 行，每一行有兩個數字 $t_i, m_i\\ (0 \\leq t_i \\leq 500, 1 \\leq m_i \\leq 10^{17})$ 分別代表委託所需時間與委託能賺的錢。\n\n請輸出一個整數代表佳佳最多能賺到的錢。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, tt;\nint t[20];\nlong long m[20];\nlong long ans;\n\nvoid solve (int index, int remain, long long money)\n{\n\tif (remain < 0)\n\t{\n\t\treturn;\n\t}\n\tif (index == n)\n\t{\n\t\tans = max(ans, money);\n\t\treturn;\n\t}\n\n\tsolve(index + 1, remain, money);\n\tsolve(index + 1, remain - t[index], money + m[index]);\n}\n\nint main ()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\t\n\tcin >> n >> tt;\n\tfor (int i = 0; i < n; i++) cin >> t[i] >> m[i];\n\n\tsolve(0, tt, 0);\n\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "id": "recursion09",
    "instruction": "失落的遺跡之中，有一個充滿陷阱的迷宮，在迷宮的終點藏有價值連城的寶藏，這個迷宮十分的脆弱，每一個地磚只能踩在上面一小段時間，所以規劃一個安全的路線是十分重要的，你將會得到一個空拍機從天空拍迷宮的照片，請你規劃一條沒有重複踩到的路線，取得寶藏吧！\n\n輸入有 $n+1$ 行，第一行包含兩個整數 $n,m$ 代表接下來地圖的長與寬\n\n接下來的 $n$ 行會有 0,1,2,3 這四種數字：\n\n0 代表可以走的地方， 1 代表不能走的牆壁， 2 代表起點， 3 代表終點\n\n$3\\le n,m \\le 50$\n\n若得到的路徑長度為 $l$ ，則輸出 $l+1$ 行，第一行只有一格數字 $l$ 代表路徑長度\n\n其餘每行包含兩個數字 $x$ 跟 $y$  代表路徑上的座標，以空格分隔，座標由0開始標\n\n輸出路徑包含起終點，並且每個踩過的座標都要輸出 (2 3=>3 2 不合格， 2 3=>3 3=>3 2 合格 )\n\n若不幸沒辦法走到寶藏之地，請輸出 \"0\\n\" ( 不用引號 )\n\n\n",
    "output": "#include <iostream>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <cstring>\nusing namespace std;\nbool **visit;\nint **map;\nvector< pair <int,int> > path;\nint dir[4][2]={\n    {0,1},\n    {1,0},\n    {0,-1},\n    {-1,0}\n};\nbool done = 0;\nvoid dfs(int x,int y){\n    int x_n,y_n;\n    for(int i = 0;i<4;i++){\n        x_n=x+dir[i][0];\n        y_n=y+dir[i][1];\n        if(visit[x_n][y_n] == 0){\n            if(map[x_n][y_n] == 0){\n                visit[x_n][y_n] = 1;\n                path.push_back(make_pair(x_n,y_n));\n                dfs(x_n,y_n);\n                if(done)\n                    return;\n                visit[x_n][y_n] = 0;\n                path.pop_back();\n            }else if(map[x_n][y_n] == 3){\n                path.push_back(make_pair(x_n,y_n));\n                done = 1;\n                return;\n            }\n\n        }\n    }\n}\nint main() {\n    int m,n;\n    scanf(\"%d%d\",&m,&n);\n    map = (int **)malloc(sizeof(int*)*m);\n    visit = (bool **)malloc(sizeof(bool*)*m);\n    int x,y;\n    for(int i=0;i<m;i++){\n        map[i]=(int *)malloc(sizeof(int)*n);\n        visit[i]=(bool *)malloc(sizeof(bool)*n);\n        memset(visit[i],0,n);\n    }\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            scanf(\"%d\",&map[i][j]);\n            if(map[i][j] == 2){\n                x=i;\n                y=j;\n                path.push_back(make_pair(x,y));\n            }\n        }\n    }\n    visit[x][y]=1;\n    dfs(x,y);\n    int le = path.size();\n    if(le==1){\n        printf(\"0\\n\");\n    }else{\n        printf(\"%d\\n\",le);\n        for(int i = 0;i<le;i++){\n            printf(\"%d %d\\n\",(path[i]).first,(path[i]).second);\n        }\n    }\n}\n"
  },
  {
    "id": "recursion10",
    "instruction": "孟孟發現了新型態的細菌，並把它命名為「$1205-\\alpha$」，為了取得更多的細菌樣本，孟孟把 $n$ 個菌株放入培養皿培育，已知每經過一秒，菌株的數量就會增加為 $m$ 倍。\n\n孟孟想知道經過 $k$ 秒之後可以獲得多少細菌樣本，於是便向你請求了協助，然而孟孟不喜歡太大的數字，所以請你告訴他模 $10^9+7$ 後的數字。\n\n輸入只有一行。\n\n輸入的第一行包含三個整數 $n, m, k\\ (1\\le n, m\\le 10^3,\\ 1\\le k\\le 2^{30})$，分別代表一開始始的菌株數、每秒鐘的成長倍率，以及培養的總時間。\n\n請輸出 $k$ 秒後的菌株數量除以 $10^9 + 7$ 的餘數。\n\n",
    "output": "#include <iostream>\n\n#define MODER 1000000007\n\nusing namespace std;\n\nlong long pow(int base, int up) {\n    if (up == 0) {\n        return 1;\n    }\n    long long half = pow(base, up / 2);\n    if (up % 2) {\n        return half * half % MODER * base % MODER;\n    }\n    else {\n        return half * half % MODER;\n    }\n}\n\nint main() {\n    long long n, m, k;\n    cin >> n >> m >> k;\n    long long multi = pow(m, k);\n    cout << n * multi % MODER << endl;\n}\n"
  },
  {
    "id": "recursion11",
    "instruction": "聽說 `std::sort()` 很快。\n\n但是，快還要更快！\n\n現在給你一個長度為 $n$ 的陣列 $a$ ，你有辦法在 $o(n \\log n)$ （嚴格小於 $n \\log n$ ）的時間內找出 $a$ 的第 $k$ 大嗎？\n\n---\n\n本題為一道互動題。在這個問題中，你需要和評測系統進行互動。\n\n一開始電腦會產生一個長度為 $n$ 的陣列 $a$ 及一個非負整數 $k$ ，並呼叫 `int solve(int n, int a[], int k)` ，你要實作這個函式，並使其回傳 $a$ 排序後的第 $k$ 項（從 $0$ 開始編號）。例如 $n = 5, a = [3, 1, 4, 1, 5], k = 2$ ，則需回傳 $3$ 。\n\n你可以呼叫 `int median(int b[])` 這個函式，他會回傳 $b$ 排序後的第 $\\lfloor \\frac{|b|}{2} \\rfloor$ 項（從 $0$ 開始編號）。\n\n---\n\n**實作細節**\n\n請在程式一開始引入標頭檔 `lib0299.h`。並實做下列函式，回傳陣列 $a$ 中第 $k$ 大的數字。\n\n- `int solve(int n, int a[], int k)`:\n    - `n`：代表陣列長度。\n    - `a`：陣列本身。\n    - `k`：你要找的第 $k$ 大。\n\n輸入分為兩行。\n\n第一行有兩個正整數 $n, k$，兩者以空白分隔，即為題目所述之 $n, k$。\n\n第二行有 $n$ 個整數，第 $i$ 個整數 $a_i$ 為陣列中的第 $i$ 項。\n\n- $0 < n \\le 1.5 \\times 10^7$\n- $0 \\le k < n$\n- $-10^6 \\le a_i \\le 10^6$\n\n輸出一個整數，代表陣列 $a$ 中第 $k$ 大的數字 (從 0 開始計算)。\n\n",
    "output": "#include \"recursion11.h\"\n\nint solve(int n, int a[], int k) {\n\tif (n == 1) return a[0];\n\tint m = median(a, n);\n  int idx = 0;\n\tif (k < n / 2) {\n    for (int i = 0; i < n; ++i)\n      if (a[i] < m) a[idx++] = a[i];\n    while (idx < n / 2) a[idx++] = m;\n\t\treturn solve(n / 2, a, k);\n\t} else {\n    for (int i = 0; i < n; ++i)\n      if (a[i] > m) a[idx++] = a[i];\n    while (idx < n - n / 2) a[idx++] = m;\n\t\treturn solve(n - n / 2, a, k - n / 2);\n\t}\n}\n"
  },
  {
    "id": "review01",
    "instruction": "如果一個正整數的每ㄧ位數都是奇數時，例如：$7,19,1759977$ 等，我們稱這種數字為完全奇數。對於輸入的一正整數 $N$，如果 $K$ 是最靠近 $N$ 的完全奇數，請寫一程式找出 $K$ 與 $N$ 之間差距的絕對值，也就是說，請計算並輸出 $|K – N|$。\n\n以 $N = 13256$ 為例，比 $13256$ 大的最小完全奇數是 $13311$，比它小的最大完全奇數是 $13199$，因為 $|13311 – 13256| = 55 < |13256 – 13199| = 57$，因此輸出 $55$。\n\n輸入只有一行，包含一個正整數 $N$。\n\n* $0\\lt N\\lt 10^{18}$\n請輸出 $N$ 其最近的完全奇數的差距。\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tstring s; cin >> s;\n\n\t// 第一個偶數的位置\n\tint evenIdx = -1;\n\tfor (int i = 0; i < (int)s.size(); i++) {\n\t\tif ((s[i] - '0') % 2 == 0) {\n\t\t\tevenIdx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (evenIdx == -1) {\n\t\t// 本身就是完全奇數，差距為零\n\t\tcout << \"0\\n\";\n\t\treturn 0;\n\t}\n\n\t// 找比 N 小的最大完全奇數\n\tstring s_pre = s; s_pre[evenIdx]--;\n\tfor (int i = evenIdx + 1; i < (int)s.size(); i++) {\n\t\ts_pre[i] = '9';\n\t}\n\tif (s_pre[evenIdx] < '0') {\n\t\ts_pre[evenIdx] = '9';\n\t\tfor (int i = evenIdx - 1; i >= 0; i--) {\n\t\t\t// s_pre[i] 只可能是 1, 3, 5, 7, 9\n\t\t\tif (s_pre[i] == '1') {\n\t\t\t\ts_pre[i] = '9';\n\t\t\t} else {\n\t\t\t\ts_pre[i] -= 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (s_pre[0] == '9') {\n\t\t\t// 把最前面的 digit 換成 0\n\t\t\t// 像是 99999 -> 09999\n\t\t\ts_pre[0] = '0';\n\t\t}\n\t}\n\n\t// 找比 N 大的最小完全奇數\n\tstring s_post = s; s_post[evenIdx]++;\n\tfor (int i = evenIdx + 1; i < (int)s.size(); i++) {\n\t\ts_post[i] = '1';\n\t}\n\n\tcout << min(abs(stoll(s) - stoll(s_pre)), abs(stoll(s) - stoll(s_post))) << '\\n';\t\n}\n"
  },
  {
    "id": "review02",
    "instruction": "給定 $N$ 個骰子排成一列，一開始都是點數 $1$ 朝上，點數 $3$ 朝前，點數 $2$ 朝右 (如下左圖所示)，另外骰子的展開圖如下右圖所示。\n\n<center>\n    <img src=\"https://i.imgur.com/8EdinFo.png\" width=\"60%\">\n</center>\n\n接下來有 $M$ 次修改操作，每個操作包含兩個整數 $a, b$：\n\n* 若 $a, b$ 都是正整數，交換編號 $a$ 與編號 $b$ 的骰子的位置。\n* 若 $b$ 為 $−1$，將編號 $a$ 的骰子向前旋轉。\n* 若 $b$ 為 $−2$，將編號 $a$ 的骰子向右旋轉。\n\n在 $M$ 次操作結束之後，依序輸出編號 $1$ 到編號 $N$ 的骰子朝上的點數。\n\n第一行包含兩個正整數 $N, M$。接下來 $M$ 行每行有兩個整數，第 $i$ 行的兩個用空白分隔的正整數 $a_i, b_i$ 表示第 $i$ 次操作。\n\n* $1\\le N\\le 20$\n* $1\\le M\\le 100$\n* $1\\le a_i\\le N$\n* $b_i = -1, -2, 1\\sim N$\n在一行輸出 $N$ 個以空格分隔數字，其中第 $i$ 個數字代表編號 $i$ 的骰子最後朝上的點數。\n",
    "output": "#include <iostream>\nusing namespace std;\n\nstruct Dice {\n\tint up, front, right;\n\n\tDice(int _up=0, int _front=0, int _right=0): \n\t\tup(_up), front(_front), right(_right) {}\n\n\tvoid flipForward() {\n\t\tint tmp = front; front = up; up = 7 - tmp;\n\t}\n\tvoid flipRightward() {\n\t\tint tmp = right; right = up; up = 7 - tmp;\n\t}\n} dice[20 + 5];\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tdice[i] = Dice(1, 3, 2);\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; cin >> a >> b;\n\t\tif (b < 0) {\n\t\t\tif (b == -1) dice[a - 1].flipForward();\n\t\t\telse dice[a - 1].flipRightward();\n\t\t} else {\n\t\t\tswap(dice[a - 1], dice[b - 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << dice[i].up << \" \\n\"[i == n - 1];\n\t}\n}\n"
  },
  {
    "id": "review03",
    "instruction": "大樂購物連鎖店一共有 $100$ 種不同的商品，從編號 $1$ 至 $100$，其中有編號為 $a, b$ 的商品是新商品。為了檢視這兩件新商品的銷售情形，大樂在每一台購物車內都安裝了感應器，能夠感應每一位客人將商品放入購物車或拿出購物車。感應器存放的紀錄為一串整數，在這串整數中，每一個正整數 $x$ 代表這位客人將一個編號為 $x$ 的商品放入購物車，每一個負數 $-x$ 代表這位客人將一個編號為 $x$ 的商品拿出購物車。每個購物紀錄最後都有一個結尾整數 $0$，代表這位客人已經將所有商品進行結帳。\n\n現在一共有 $n$ 位客人的購物紀錄，大樂想要紀錄一共有多少位客人同時買了編號為 $a, b$ 的新商品，請你寫一個程式完成任務。\n\n輸入第一行有兩個正整數 $a, b (1 \\leq a, b \\leq 100, a \\neq b)$。\n輸入第二行有一個正整數 $n (1 \\leq n \\leq 100)$。\n接下來 $n$ 行，每一行都有一串整數代表該位客人的購物紀錄，保證每一個數字的絕對值不超過 $100$，且最後一個數字為 $0$。\n輸入保證 $n$ 位客人將商品放入或移出購物車的次數不會超過 $2 \\times 10^5$ 次，且購物紀錄絕對不會出現不合理的狀況。\n\n請輸出一個整數代表同時購買兩件新商品的客人數量。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int a, b; cin >> a >> b;\n  int n; cin >> n;\n\n  int ans = 0;\n  for(int i = 0; i < n; i++) {\n    int x;\n    vector<int> cnt(101);\n    while(cin >> x && x) {\n      if(x > 0) cnt[x]++;\n      if(x < 0) {\n        x = -x;\n        assert(cnt[x]);\n        cnt[x]--;\n      }\n    }\n\n    ans += (cnt[a] > 0 && cnt[b] > 0);\n  }\n\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "review04",
    "instruction": "在小風國裡，一共有 $m$ 座城市，編號為 $0, 1, \\ldots, m - 1$，小風手上有 $n$ 臺伺服器，編號為 $0, 1, \\ldots, n - 1$， $Q_{i, j}$ 代表第 $i$ 臺伺服器需要傳送到第 $j$ 座城市中的用戶流量。由於城市間傳送資料需要錢，小風命令工程師們規劃伺服器安裝在不同城市的最佳方案，如果城市 $u$ 之中全部伺服器傳送至城市 $v$ 的流量總共為 $f$ ，所需的花費為：\n\n- 若為同城市內互打 $u = v$，則每單位的流量花費 $1$ 元。\n- 若為跨城市傳送 $u \\neq v$，不超過 $1000$ 單位的流量每單位 $3$ 元，超過 $1000$ 單位的流量每單位 $2$ 元。\n\n如果一座城市 $u$ 有多座伺服器都要傳送資料至城市 $v$，則會將所有伺服器的資料量加總再計算花費。工程師們一共列出了 $k$ 種方案，每種方案可以用 $c = (c_0, c_1, \\ldots, c_{n - 1})$ 來表示，其中 $c_i$ 代表第 $i$ 臺伺服器座落的城市。請幫小風計算出哪一種方案的花費最少。\n\n輸入第一行包含三個正整數 $n, m, k (1 \\leq n, m, k \\leq 50)$。\n接下來的 $n$ 行，每一行有 $m$ 個數字，第 $i$ 行的第 $j$ 個數字代表流量 $Q_{i, j} (1 \\leq Q_{i, j} \\leq 1000)$。\n接下來的 $k$ 行，每一行有 $k$ 個數字 $c_0, c_1, \\ldots, c_{n - 1}$，代表工程師設計的其中一種方案。\n\n請輸出一個整數代表這些方案中的最小花費。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int n, m, k; cin >> n >> m >> k;\n  vector<vector<int>> Q(n, vector<int>(m));\n  for(int i = 0; i < n; i++) {\n    for(int j = 0; j < m; j++) cin >> Q[i][j];\n  }\n\n  int ans = 1e9;\n  while(k--) {\n    vector<vector<int>> city(m);\n    for(int i = 0; i < n; i++) {\n      int x; cin >> x;\n      city[x].push_back(i);\n    }\n\n    int cost = 0;\n    for(int i = 0; i < m; i++) {\n      vector<int> flow(m);\n      for(int idx : city[i]) {\n        for(int j = 0; j < m; j++) flow[j] += Q[idx][j];\n      }\n\n      auto Cal = [&](int i, int j) {\n        if(i == j) return flow[j];\n        else if(flow[j] <= 1000) return 3 * flow[j];\n        else return 3 * 1000 + 2 * (flow[j] - 1000);\n      };\n      for(int j = 0; j < m; j++) cost += Cal(i, j);\n    }\n\n    ans = min(ans, cost);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "review05",
    "instruction": "假設 $n$ 是 $2$ 的冪次，也就是存在某個非負整數 $k$ 使得 $n=2^k$。將一個 $n \\times n$ 的黑白影像以下列遞迴方式編碼：\n\n* 如果每一格像素都是白色，我們用 $0$ 來表示；\n\n* 如果每一格像素都是黑色，我們用 $1$ 來表示；\n\n* 否則，並非每一格像素都同色，先將影像均等劃分為四個邊長為 $\\frac{n}{2}$ 的小正方形後，然後表示如下：先寫下 $2$，之後依續接上左上、右上、左下、右下四塊的編碼。\n\n輸入編碼字串 $S$ 以及影像尺寸 $n$，請計算原始影像中有多少個像素是 $1$。\n\n第一行是影像的編碼 $S$，字串長度小於 $10^6$。第二行為正整數 $n$，$1\\leq n\\leq 1024$，其中 $n$ 必為 $2$ 的冪次。\n\n輸出有多少個像素是 $1$。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nstring s;\nint pos = 0;\nint dfs(int n) {\n\tif (s[pos] == '0') {\n\t\tpos++;\n\t\treturn 0;\n\t}\n\tif (s[pos] == '1') {\n\t\tpos++;\n\t\treturn n * n;\n\t}\n\t// int ans = 0;\n\tpos++;\n\treturn  dfs(n / 2) + dfs(n / 2) + dfs(n / 2) + dfs(n / 2);\n}\nint main() {\n\tint n;\n\tcin >> s >> n;\n\tcout << dfs(n) << '\\n';\n}\n"
  },
  {
    "id": "review06",
    "instruction": "小緯很喜歡玩抽鬼牌，喜歡到研發了一種自己一人也能玩的玩法，甚至還因此網購了傳說中的無限撲克牌：\n\n- 每種卡牌有「花色」、「點數」兩項資訊，一共有 $4$ 種花色與 $13$ 種點數，共 $52$ 種正牌。\n- 四種花色分別為「黑桃」、「紅心」、「方塊」、「梅花」四種，其中黑桃與梅花是黑色、紅心與方塊則為紅色。\n- 除了正牌之外還有一種「小丑」卡牌。\n- 每一種牌都有無限多張。\n- 小緯一開始有 $N$ 張手牌，每一回合會進行「抽牌」與「被抽牌」之中的某一種操作。\n- 為了營造真實的抽鬼牌體驗，小緯手中有兩張點數、顏色相同且**花色不同**的卡牌時，就可以將他們從手牌移除。\n- 小丑牌不能與任何其他卡牌配對。\n- 因為是自己一個人玩，所以就算沒手牌了還是可以繼續玩。\n\n雖然你也許不想跟小緯一起玩抽鬼牌，但希望你至少可以幫助小緯模擬單人遊戲的過程。\n\n輸入的第一行包含兩個整數 $N\\ (1 \\le N \\le 13), M\\ (1\\le M\\le 10^3)$，代表小緯的起始手牌數以及遊戲的回合數，兩者以空白分隔。\n第二行包含 $N$ 個字串，代表小緯所有的卡牌資訊，卡牌資訊為三個字元所組成，第一個字元代表花色，`S`、`H`、`D`、`C` 分別代表黑桃、紅心、方塊、梅花，後面兩個字元代表點數，從 `01` 到 `13` 代表 $1$ 到 $13$ 點，小丑牌則是 `JKR`，每筆卡牌資訊之間以空格分隔。\n接下來的 $M$ 行之中，第 $i$ 行包含了一個整數以及一個字串，分別代表第 $i$ 回合操作的種類以及該操作所對應的卡牌 $C$，兩者以空格分隔：\n- 操作 `1`，抽入卡牌 $C$\n- 操作 `2`，手中的卡牌 $C$ 被抽走，如果此時手中沒有卡牌 $C$，則跳過這筆操作。\n\n請輸出遊戲結束時，小緯的手牌資訊，手牌資訊請按照點數大小，由小到大排列，若點數相同，則依照「梅花」、「方塊」、「紅心」、「黑桃」的順序排列，而小丑牌必定會放在最後面，每筆卡牌資訊之間以空格分隔。\n如果遊戲結束時，小緯手中沒有任何牌，就輸出 `empty`。\n\n",
    "output": "#include <bits/stdc++.h>\n\n#define CARD_CNT 53\n\nusing namespace std;\n\nbool card_cmp(string a, string b) {\n    if (a == \"JKR\") {\n        return 0;\n    }\n    if (b == \"JKR\") {\n        return 1;\n    }\n    int a_point = (a[1] - '0') * 10 + (a[2] - '0');\n    int b_point = (b[1] - '0') * 10 + (b[2] - '0');\n\n    if (a_point != b_point) {\n        return a_point < b_point;\n    }\n    return a[0] < b[0]; // C < D < H < S in ASCII\n}\n\nvoid swap(string &a, string &b) {\n    string tmp = a;\n    a = b;\n    b = tmp;\n}\n\nbool match(string a, string b) {\n    if (a[0] > b[0]) {\n        swap(a, b);\n    }\n\n    if (a[1] == b[1] and a[2] == b[2]) {\n        return (a[0] == 'C' and b[0] == 'S') or (a[0] == 'D' and b[0] == 'H');\n    }\n    return 0;\n}\n\nvoid draw(string hand_card[], string card, int &card_cnt) {\n    int is_match = 0;\n    for (int i = 0; i < card_cnt; ++i) {\n        if (match(card, hand_card[i])) {\n            swap(hand_card[i], hand_card[--card_cnt]);\n            is_match = 1;\n            break;\n        }\n    }\n    if (!is_match) {\n        hand_card[card_cnt++] = card;\n    }\n}\n\nint main() {\n    int init_card_cnt, turn_cnt;\n    cin >> init_card_cnt >> turn_cnt;\n\n    string hand_card[1013];\n    int card_cnt = 0;\n    for (int i = 0; i < init_card_cnt; ++i) {\n        string card;\n        cin >> card;\n        draw(hand_card, card, card_cnt);\n    }\n\n    while (turn_cnt--) {\n        int op;\n        string card;\n        cin >> op >> card;\n\n        if (op == 1) {\n            draw(hand_card, card, card_cnt);\n        }\n        if (op == 2) {\n            for (int i = 0; i < card_cnt; ++i) {\n                if (card == hand_card[i]) {\n                    swap(hand_card[i], hand_card[--card_cnt]);\n                    break;\n                }\n            }\n        }\n    }\n\n    sort(hand_card, hand_card + card_cnt, card_cmp);\n    for (int i = 0; i < card_cnt; ++i) {\n        cout << hand_card[i] << \" \";\n    }\n    if (card_cnt == 0) {\n        cout << \"empty\";\n    }\n    cout << endl;\n}\n"
  },
  {
    "id": "review07",
    "instruction": "$N$ 皇后是一個經典的演算法問題，給定一個 $N\\times N$ 的西洋棋棋盤，要將 $N$ 個皇后擺放在西洋棋盤上，並使得這 $N$ 個皇后不會互相攻擊。已知皇后可以在直線與斜線方向移動任意的步數，若西洋棋的規則新增一個新的角色「皇后 - PLUS」，其攻擊範圍與皇后相同，外加可以移動到以「皇后 - PLUS」為中心的 $5\\times 5$ 格子中。\n\n請你寫一個程式解出 $N$ 皇后 - PLUS 的題目：將 $N$ 個「皇后 - PLUS」放在 $N\\times N$ 的西洋棋棋盤上，使得這 $N$ 個「皇后 - PLUS」不會互相攻擊。若存在多組可能的放法，請輸出任意一組放法即可；若沒有可以在 $N\\times N$ 的棋盤上放 $N$ 個「皇后 - PLUS」的解，請輸出 QQ。\n輸入只有一個數字 $N$（$1 \\le N \\le 20$），代表棋盤的大小及要放上去的「皇后 - PLUS」數量。\n\n若此 $N$「皇后 - PLUS」問題有解，請輸出 $N$ 行，每行共有 $N$ 個以空白分隔的 0 或 1，1 代表該格有放皇后、0 代表該格為空。若此 $N$「皇后 - PLUS」問題無解，請輸出字串 \"QQ\"。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ans = 0, N;\n\ninline bool valid(int x, int y) {\n    return (0 <= x && x < N && 0 <= y && y < N);\n}\n\nbool check(vector<vector<int>> &b, int x, int y) {\n    for (int i = 0; i < N; i++) {\n        if (i != x && b[i][y]) return false;\n        if (i != y && b[x][i]) return false;\n    }\n    for (int i = 1; i < N; i++) {\n        if (valid(x+i, y+i) && b[x+i][y+i]) return false;\n        if (valid(x-i, y+i) && b[x-i][y+i]) return false;\n        if (valid(x+i, y-i) && b[x+i][y-i]) return false;\n        if (valid(x-i, y-i) && b[x-i][y-i]) return false;\n    }\n    if (valid(x-1, y+2) && b[x-1][y+2]) return false;\n    if (valid(x+1, y-2) && b[x+1][y-2]) return false;\n    if (valid(x+1, y+2) && b[x+1][y+2]) return false;\n    if (valid(x-1, y-2) && b[x-1][y-2]) return false;\n\n    if (valid(x-2, y+1) && b[x-2][y+1]) return false;\n    if (valid(x+2, y-1) && b[x+2][y-1]) return false;\n    if (valid(x+2, y+1) && b[x+2][y+1]) return false;\n    if (valid(x-2, y-1) && b[x-2][y-1]) return false;\n\n    return true;\n}\n\nbool solve(vector<vector<int>> &b, int r) {\n    // Try to fill chess at row r\n    if (r == N) {\n        ans++;\n        for (auto v: b) {\n            for (auto x:v) {\n                cout << x << ' ';\n            }\n            cout << endl;\n        }\n        return true;\n    }\n    for (int i = 0; i < N; i++) {\n        b[r][i] = 1;\n        if (check(b, r, i))\n            if (solve(b, r+1)) {\n                return true;\n            }\n        b[r][i] = 0;\n    }\n    return false;\n}\n\nint main() {\n    cin >> N;\n    vector<vector<int>> b(N, vector<int>(N, 0));\n    if (!solve(b, 0)) {\n        cout << \"QQ\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "id": "review08",
    "instruction": "小竹最近愛上了奇數，然而他覺得一般的奇數定義太膚淺了，他重新定義了一種「真奇數」，並規定每一位都是奇數的整數才能叫做「真奇數」。\n\n現在小竹想要把一些整數換成「真奇數」，請你幫小竹算出換成「真奇數」最少需要加多少或減多少。\n\n一個正整數 $N < 10^{18}$\n\n輸出一個正整數代表最少要加多少或減多少才能變成真奇數。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main ()\n{\n\tstring s;\n\tcin >> s;\n\n\tlong long n = stoll(s);\n\n\tint error = -1;\n\t\n\tfor (int i = 0; i < s.length(); i++)\n\t{\n\t\tif (s[i] & 1) continue;\n\t\telse\n\t\t{\n\t\t\terror = s.length() - i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error == -1)\n\t{\n\t\tcout << 0 << '\\n';\n\t\texit(0);\n\t}\n\n\tlong long MOD = 1;\n\tlong long one = 111111111111111111LL;\n\tfor (int i = 1; i < error; i++) MOD *= 10;\n\n\tlong long nxt = n - n % MOD + MOD + one % MOD;\n\t\n\tbool isodd = false;\n\tif (s[s.length() - error] == '0')\n\t{\n\t\terror++;\n\t\twhile (error < s.length() && s[s.length() - error] == '1')\n\t\t{\n\t\t\terror++;\n\t\t}\n\t\tisodd = s[s.length() - error] != '1';\n\t}\n\n\tMOD = 1;\n\tlong long nine = 99999999999999999LL;\n\tfor (int i = 1; i < error; i++) MOD *= 10;\n\n\tlong long prv = n - n % MOD - isodd * MOD - MOD + nine % MOD;\n\n\tcout << min(n - prv, nxt - n) << '\\n';\n}\n"
  },
  {
    "id": "string01",
    "instruction": "你知道三十六進位嗎？三十六進位是一種沒有人在用的進位方式，他使用 `0` 到 `9` 來代表數字 $0\\sim 9$，然後使用 `A` 到 `Z` 來代表數字 $10\\sim 35$。小明剛學會這個進位法，他想寫一個程式來把三十六進位的字元換成人看得懂的十進位，你能幫幫他嗎？\n\n輸入只有一行，代表需轉換的字元 $c$。\n\n* $c$ 為 `0` 到 `9` 或 `A` 到 `Z` 的其中一個字元\n\n請輸出轉換後的數字。\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tchar c; cin >> c;\n\t// 0 ~ 9\n\tif (c >= '0' && c <= '9') cout << c << '\\n';\n\t// A ~ Z -> 10 ~ 35\n\telse cout << (c - 'A' + 10) << '\\n';\n}\n"
  },
  {
    "id": "string02",
    "instruction": "在講題目之前，我們先來看戌神ころね告訴你什麼叫做回文。\n\n<center>\n<iframe width=\"1120\" height=\"600\" src=\"https://www.youtube.com/embed/kWPQyCIKTtk\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n<span style=\"color:gray;\">曾經有隻睿智的狗子說過：「ホタテ　テタホ。」</span>\n</center>\n\n回文，就是正讀反讀都一樣的句子，就例如影片中的「ホタテ テタホ」就是一個**非常經典**的回文例子。\n現在，請你寫出一個程式來判斷輸入的文字是不是回文，如果是輸出一行 `Yes`，否則輸出 `No`。\n\n\n輸入有一個只有小寫英文字母的字串，保證字串長度不超過 $10^5$，且不為空字串。\n如果輸入的字串是回文輸出一行 `Yes`，否則輸出 `No`。\n",
    "output": "#include <iostream>\n#include <cstring>\nusing namespace std;\nchar S[1000001];\nint main () {\n  cin >> S;\n  bool is_palin = true;\n  int len = strlen(S);\n  for (int i=0; i<len/2; i++) {\n    if (S[i] != S[len-i-1]) {\n      is_palin = false;\n      break;\n    }\n  }\n  cout << (is_palin ? \"Yes\" : \"No\") << endl;\n  return 0;\n}"
  },
  {
    "id": "string03",
    "instruction": "有個莫名其妙的國家，他們存了許多的英文文章檔案在中央電腦系統內。某天，一位工程師發現這些檔案都被病毒入侵了。不幸中的大幸是這些文章只有大小寫被病毒修改了。\n\n請你寫個程式幫忙復原這些英文檔案，使大小寫符合英文文法：句首單字開頭大寫，其餘單字皆為小寫，每句話皆為句點結尾。已知這些檔案內皆沒有專有名詞，不存在非句首卻大寫的情形。\n\n輸入只有一行長度為 $L(1\\le L \\le 1000)$ 的字串，包含大小寫的英文字元、標點符號 `,` 和 `.` 以及空格。\n\n輸出一行長度亦為 $L$ 的字串，符合英文文法大小寫規則。\n\n",
    "output": "#include <iostream>\n#include <ctype.h>\nusing namespace std;\n\nint main() {\n    char c;\n    int isFirst = 1;\n    c = getchar();\n    while (c != EOF) {\n        if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {\n            if (isFirst) {\n                cout << (char)toupper(c);\n                isFirst = 0;\n            }\n            else {\n                cout << (char)tolower(c);\n            }\n        }\n        else {\n            if (c == '.') {\n                isFirst = 1;\n            }\n            cout << c;\n        }\n        c = getchar();\n    }\n    return 0;\n}\n"
  },
  {
    "id": "string04",
    "instruction": "> 凱撒密碼（英語：Caesar cipher），是一種最簡單且最廣為人知的加密技術。凱撒密碼是一種替換加密技術，明文中的所有字母都在字母表上向後按照一個固定數目 $K$ 進行偏移後被替換成密文。例如，當偏移量是 `3` 的時候，所有的字母 `A` 將被替換成 `D` ，`B` 變成 `E`，`Y` 將變成 `B`，`Z` 將變成 `C`，以此類推。這個加密方法是以羅馬共和時期凱撒的名字命名的，據稱當年凱撒曾用此方法與其將軍們進行聯繫。\n>\n> —— 改編自維基百科\n\n舉例來說，如果密文是 `ABCDE` 且決定了 $K = 3$，則密文就會變成 `DEFGH`。現在，請寫一支程式，給定了一個僅由大寫字母所組成的明文 $S$ 與已知的偏移參數 $K$，請問你可以幫忙加密這份明文並輸出嗎？此外，你必須成功加密出 $N$ 個明文，才算通過。\n\n輸入有 $N + 1$ 行。第一行有一個數字 $N(1 \\le N \\le 10^5)$，代表接下來有幾個東西要你加密；接下來的第 $i$ 行有一個字串 $S_i(|S_i| \\leq 10^5)$ 與加密參數 $K_i(0 \\leq K < 26)$。\n\n此外，保證 $\\sum |S| \\leq 10^5$，且所有的 $S_i$ 皆由大寫字母組成。\n\n對於每一個輸入，請輸出加密後的密文。\n",
    "output": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\n\nint main() {\n\n\tint T, K;\n\tstring s;\n\tcin >> T;\n\twhile(T--){\n\t\tcin >> s >> K;\n\t\tfor(char c : s){\n\t\t\tcout << (char)(((c - 'A') + K) % 26 + 'A');\n\t\t}\n\t\tcout << endl;\n\t}\n}\n"
  },
  {
    "id": "string05",
    "instruction": "三十六進制，是一種利用 `0` 到 `9` 與 `A` 到 `Z` 組成的進位方式，其中 `A` 代表 10、`B` 代表 11，其他依此類推。相較於十進位與十六進位，三十六進制能夠以更短的字串來表示數字，進而省下更多的儲存空間。\n\n現在就來實作一個程式，能夠用它把三十六進制與十進制互相轉換。\n\n輸入有 $N + 1$ 行。第一行有一個數字 $N(1\\le N \\le 10^5)$，代表接下來有 $N$ 個指令，每個指令為一行。\n\n每個指令有以下兩種：\n1. `Base10 n` 代表一個十進制的整數 $n$，需要把它轉為三十六進制，輸出後換行。\n2. `Base36 s` 代表一個三十六進制的整數 $s$，需要把它轉為十進制的 $m$，輸出後換行。\n\n此外，保證 $0\\le m,n<2^{64}$，並且要求三十六進制中的英文字母皆為大寫。\n\n輸出共有 $N$ 行，對於每一個指令，請輸出對應的轉換結果。\n",
    "output": "#include <iostream>\nusing namespace std;\ntypedef unsigned long long ull;\n\n\nint toi(char c) {\n\tif ('A' <= c && c <= 'Z') {\n\t\treturn c - 'A' + 10;\n\t}\n\treturn c - '0';\n}\n\nchar toc(int n) {\n\tif (10 <= n && n < 36) {\n\t\treturn n -10 + 'A';\n\t}\n\treturn n + '0';\n}\n\null to_10(string s) {\n\tull ret = 0;\n\tfor(int i = 0; i < s.length(); i++) {\n\t\tret *= 36;\n\t\tret += toi(s[i]);\n\t}\n\treturn ret;\n}\n\nstring to_36(ull n) {\n\tif (n == 0) return \"0\";\n\tstring s;\n\twhile (n > 0) {\n\t\ts = (toc(n%36)) + s;\n\t\tn /= 36;\n\t}\n\treturn s;\n}\n\nint main() {\n\t//This is model solution\n\tint N;\n\tcin >> N;\n\tull n;\n\tstring cmd, s;\n\twhile (N--) {\n\t\tcin >> cmd;\n\t\tif (cmd == \"Base10\") {\n\t\t\tcin >> n;\n\t\t\tcout << to_36(n) << '\\n';\n\t\t}\n\t\telse {\n\t\t\tcin >> s;\n\t\t\tcout << to_10(s) << '\\n';\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "id": "string06",
    "instruction": "十里總是說：「我不會數學，我弱」。\n\n十里最近決定寫一支程式來幫他進行整數四則運算，並想藉此表示他連四則運算都不會，此時你不巧的遇見了他。\n\n「你可以幫我寫一支整數四則運算的程式嗎？因為我弱，所以不會寫」，就這樣你莫名其妙地背負了重大的任務。\n\n特別注意到，因為十里想表示他連四則運算的程式都寫不好，所以該程式的除法會直接捨去餘數的部分。\n\n輸入有一行，包含一個字串，該字串是僅以非負整數以及加減乘除四種運算子所組成的合法運算式，字串長度不超過 $10^4$，且整個運算過程所出現的數字都在 `int` 的範圍內。\n\n請輸出四則運算式的結果，如果計算過程中發生「除以零」的問題，請輸出 `Error`。\n\n要特別注意計算順序哦，先乘除後加減，且由左至右計算。\n\n",
    "output": "#include <bits/stdc++.h>\n\n#define MAX_SIZE 10000\n#define PLUS '+'\n#define MINUS '-'\n#define MULTI '*'\n#define DEVIDE '/'\n#define MAX_VAL 1000000000\n\nint calculate(int a, char op, int b) {\n    if (op == PLUS)\n        return a + b;\n    if (op == MINUS)\n        return a - b;\n    if (op == MULTI)\n        return a * b;\n    if (op == DEVIDE)\n        return a / b;\n    return 0;\n}\n\nusing namespace std;\n\nint main() {\n    string input;\n    cin >> input;\n    \n    vector<int> nums;\n    vector<char> ops;\n    int tmp = 0;\n    for (int i = 0; i < input.size(); ++i) {\n        if (isdigit(input[i])) {\n            tmp *= 10;\n            tmp += input[i] - '0';\n        }\n        else {\n            nums.push_back(tmp);\n            tmp = 0;\n            ops.push_back(input[i]);\n        }\n    }\n    nums.push_back(tmp);\n\n    int sum = 0;\n    char hold_op = '+';\n    int hold_num = nums[0];\n    int devide_zero = 0;\n    for (int i = 0; i < ops.size(); ++i) {\n        if (ops[i] == PLUS or ops[i] == MINUS) {\n            sum = calculate(sum, hold_op, hold_num);\n            hold_op = ops[i];\n            hold_num = nums[i + 1];\n        }\n        else {\n            if (ops[i] == '/' and nums[i + 1] == 0) {\n                devide_zero = 1;\n                break;\n            }\n            hold_num = calculate(hold_num, ops[i], nums[i + 1]);\n        }\n    }\n    if (devide_zero) {\n        cout << \"Error\\n\";\n    }\n    else {\n        sum = calculate(sum, hold_op, hold_num);\n\n        cout << sum << '\\n';\n    }\n}\n"
  },
  {
    "id": "string07",
    "instruction": "如何生成又長又好記的密碼一直是個亙古難題。其中有一個方法是從字典中隨機挑選四個單字以某個順序串接，記憶時便可編一個故事把四個字連結起來。現在你已挑選好了四個單字，並決定好了順序，請你寫一個程式把他們串接起來。\n\n\nRef: XKCD comics (https://imgs.xkcd.com/comics/password_strength.png)\n\n輸入第一行是 $4$ 個正整數 $a_1, a_2, a_3, a_4$ 代表串接順序，第 $a_i$ 個字串要被接在第 $i$ 個位置。\n接下來 $4$ 行每行一個字串，代表生成的單詞。\n\n輸入保證 $a_1, a_2, a_3, a_4$ 一定是 $1, 2, 3, 4$ 的排列，以及所有字串長不超過 $100$。但輸入並不保證字串一定是字典中的單詞。\n\n輸出一行一個串接好的密碼。\n\n",
    "output": "#include <stdio.h>\n#include <cstring>\nusing namespace std;\nchar s[5][100], ans[500];\nint main() {\n    int ord[5];\n    scanf(\"%d %d %d %d\", &ord[1], &ord[2], &ord[3], &ord[4]);\n    for(int i = 1; i <= 4; i++) scanf(\"%s\", s[i]);\n    for(int i = 1; i <= 4; i++) {\n        strncat(ans, s[ord[i]], strlen(s[ord[i]]));\n    }\n    printf(\"%s\\n\", ans);\n}\n"
  },
  {
    "id": "string08",
    "instruction": "小明最近迷上一個遊戲叫字串接龍，遊戲會給你許多字串，只要將字串按照順序接起來，就可以獲得遊戲加分，然而遊戲有時間限制，為了節省時間，小明會從當前字串結尾找到一段與下一個字串開頭的最長共同子字串，利用複製貼上的方式完成接龍。舉例來說，假設當前字串為 `aabbc` 且下一個字串是 `bbcab`，那麼 `bbc` 的部分為前者結尾與後者開頭的最長共同子字串，故小明只需要打 `aabbcab` 這幾個字，因為第二個 `bbc` 可以藉由複製貼上完成。\n\n為了拿到新高分，小明希望你能幫他找出最少必須打哪些字。\n\n輸入第一行為一個正整數 $N\\ (1 \\leq N \\leq 5000)$，代表字串的數量。\n接下來 $N$ 行每行都包含一個只由小寫英文字母所組成的字串 $s_i \\ (1 \\leq \\sum |s_i| \\leq 5000)$。\n輸出一行，代表小明最少需要打那些字。\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar s[1000005], a[1000005];\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int n,len = 0;\n    cin >> n;\n    for(;n--;){\n        cin >> a;\n        int k = 0;\n        for(int i=0;a[i] && i<len; i++){\n            if(!strncmp(s+len-i-1,a,i+1)) k = i+1;\n        }\n        int w = strlen(a) - k;\n        memcpy(s+len,a+k,w);\n        len += w;\n    }\n    cout << s << '\\n';\n}\n// s = abba, i = abbc -> s = abbabbc\n// s = abba i = bbac -> s = abbac\n"
  },
  {
    "id": "string09",
    "instruction": "將一個十進位正整數的奇數位數的和稱為 $A$，偶數位數的和稱為 $B$，則 $A$ 與 $B$ 的絕對差值 $\\mid A-B\\mid$ 稱為這個正整數的秘密差。\n例如：`263541` 的奇數位數的和 $A=6+5+1=12$，偶數位數的和 $B=2+3+4=9$，所以 `263541` 的秘密差是 $\\mid 12-9\\mid=3$。\n給定一個十進位正整數 $X$，請找出 $X$ 的秘密差。\n\n輸入為一行含有一個十進位表示法的正整數 $X$，$X$ 的位數不超過 $1000$ 位數，之後是一個換行字元。\n\n\n請輸出 $X$ 的秘密差 $Y$（以十進位表示法輸出），以換行字元結尾。\n\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int A[2] = {}, even = 0;\n    char c = getchar();\n    while (c != '\\n') {\n        A[even] += c - '0';\n        even = !even;\n        c = getchar();\n    }\n    if (A[0] - A[1] < 0) {\n        cout << A[1] - A[0];\n    }\n    else {\n        cout << A[0] - A[1];\n    }\n}\n"
  },
  {
    "id": "string10",
    "instruction": "一個字串如果全由大寫英文字母組成，我們稱為大寫字串；如果全由小寫字母組成則稱為小寫字串。字串的長度是他所包含字母的個數，在本題中，字串均由大小寫英文字母組成。假設 $k$ 是一個自然數，一個字串被稱為「$k$-交錯字串」，如果它是由長度為 $k$ 的大寫字串與長度為 $k$ 的小寫字串交錯串接組成。\n\n舉例來說，`StRiNg` 是一個 $1$-交錯字串，因為它是一個大寫一個小寫交替出現；而 `heLLow` 是一個 $2$-交錯字串，因為它是兩個小寫接兩個大寫再接兩個小寫。但不管 $k$ 是多少，`aBBaaa`、`BaBaBB`、`aaaAAbbCCCC` 都不是 $k$-交錯字串。\n\n本題的目標是對於給定 $k$ 值，在一個輸入字串找出最長一段連續子字串滿足 $k$-交錯字串的要求。例如 $k=2$ 且輸入 `aBBaaa`，最長的 $k$-交錯字串是 `BBaa`，長度為 $4$。又如 $k=1$ 且輸入 `BaBaBB`，最長的 $k$-交錯字串是 `BaBaB`，長度為 $5$。\n\n請注意，滿足條件的子字串可能只包含一段小寫或大寫字母而無交替，如範例二。此外，也可能不存在滿足條件的子字串，如範例四。\n\n輸入的第一行是 $k$，第二行是輸入字串，字串長度至少為 $1$，只由大小寫英文字母組成（也就是 `A` 到 `Z` 與 `a` 到 `z`）並且沒有空白。\n\n輸出輸入字串中滿足 $k$-交錯字串的要求的最長一段連續子字串的長度，以換行結尾。\n\n",
    "output": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint verify(char s[], int casekind[], int i, int f) {\n    for (int j = i+1; j <= f; j++) {\n        if (casekind[(int)s[j]] != casekind[(int)s[j-1]]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int k;\n    char s[100010];\n    int casekind[128];\n    cin >> k >> s;\n    int n = strlen(s);\n\n    for (int i = 'a'; i <= 'z'; i++) {\n        casekind[i] = 0;\n        casekind[i-'a'+'A'] = 1;\n    }\n\n    int i = 0, f = k-1;\n    while (!verify(s, casekind, i, f)) {\n        i++; f++;\n        if (f == n) {\n            cout << 0;\n            return 0;\n        }\n    }\n    // for (int j = i; j <= f; j++) {\n    //     cout << s[j] << \" \\n\"[j==f];\n    // }\n    int curkind = casekind[(int)s[i]], ans = k;\n    while (f < n) {\n        while (f+1 < n && verify(s, casekind, f+1, f+k) && casekind[(int)s[f+1]] != curkind) {\n            f += k;\n            curkind = !curkind;\n            // if(f-i+1 > ans) {\n            //     for (int j = i; j <= f; j++) {\n            //         cout << s[j] << \" \\n\"[j==f];\n            //     }\n            // }\n            ans = max(ans, f-i+1);\n        }\n        if (f == n-1) break;\n        i++;\n        f = i + k-1;\n        while (!verify(s, casekind, i, f) && f < n) {\n            i++; f++;\n        }\n        curkind = casekind[(int)s[i]];\n    }\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "id": "string11",
    "instruction": "謙謙最近迷上棒球，他想自己寫一個簡化的棒球遊戲計分程式。這個程式會讀入球隊中每位球員的打擊結果，然後計算出球隊的得分。\n\n這是個簡化版的模擬，假設擊球員的打擊結果只有以下情況：\n\n1. 安打：以 `1B`、`2B`、`3B` 和 `HR` 分別代表一壘打、二壘打、三壘打和全（四）壘打。\n2. 出局：以 `FO`、`GO` 和 `SO` 表示。\n\n這個簡化版的規則如下：\n\n1. 球場上有四個壘包，稱為本壘、一壘、二壘和三壘。\n2. 站在本壘握著球棒打球的稱為「擊球員」，站在另外三個壘包的稱為「跑壘員」。\n3. 當擊球員的打擊結果為「安打」時，場上球員（擊球員與跑壘員）可以移動；結果為「出局」時，跑壘員不動，擊球員離場，換下一位擊球員。\n4. 球隊總共有九位球員，依序排列。比賽開始由第 $1$ 位開始打擊，當第 $i$ 位球員打擊完畢後，由第 $(i+1)$ 位球員擔任擊球員。當第九位球員完畢後，則輪回第一位球員。\n5. 當打出 $K$ 壘打時，場上球員（擊球員和跑壘員）會前進 $K$ 個壘包。從本壘前進一個壘包會移動到一壘、接著是二壘、三壘，最後回到本壘。\n6. 每位球員回到本壘時可得 $1$ 分。\n7. 每達到三個出局數時，一、二和三壘就會清空（跑壘員都得離開），重新開始。\n\n<img src=\"https://i.loli.net/2021/07/13/MtOd6PJNavuSHE2.png\" alt=\"sc\" style=\"zoom:50%;\" />\n\n請寫出具備這樣功能的程式，計算球隊的總得分。\n\n\n\n**範例輸出一說明：**\n\n1B：一壘有跑壘員。\n1B：一、二壘有跑壘員。\nSO：一、二壘有跑壘員，一出局。\nFO：一、二壘有跑壘員，兩出局。\n1B：一、二、三壘有跑壘員，兩出局。\nGO：一、二、三壘有跑壘員，三出局。\n\n達到第三個出局數時，一、二、三壘均有跑壘員，但無法得分。因為 $b=3$，代表三個出局就結束比賽，因此得到 $0$ 分。\n\n\n\n**範例輸出二說明：**\n\n接續範例一，達到第三個出局數時未得分，壘上清空。\n1B：一壘有跑壘員。\nSO：一壘有跑壘員，一出局。\n3B：三壘有跑壘員，一出局，得一分。\n1B：一壘有跑壘員，一出局，得兩分。\n2B：二、三壘有跑壘員，一出局，得兩分。\nHR：一出局，得五分。\nFO：兩出局，得五分。\n1B：一壘有跑壘員，兩出局，得五分。\nGO：一壘有跑壘員，三出局，得五分。\n\n因為 $b=6$，代表要計算的是累積六個出局時的得分，因此在前 $3$ 個出局數時得 $0$ 分，第 $4\\sim6$ 個出局數得到 $5$ 分，因此總得分是 $0+5=5$ 分。\n\n每組測試資料固定有十行。\n\n第一到九行，依照球員順序，每一行代表一位球員的打擊資訊。每一行開始有一個正整數 $a(1\\le a\\le5)$，代表球員總共打了 $a$ 次。接下來有 $a$ 個字串（均為兩個字元），依序代表每次打擊的結果。資料之間均以一個空白字元隔開。球員的打擊資訊不會有錯誤也不會缺漏。\n\n第十行有一個正整數 $b(1\\le b\\le27)$，表示我們想要計算當總出局數累計到 $b$ 時，該球隊的得分。輸入的打擊資訊中至少包含 $b$ 個出局。\n\n\n計算在總計第 $b$ 個出局數發生時的總得分，並將此得分輸出於一行。\n\n",
    "output": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint run(int base[], int step) {\n    int score = 0;\n    for (int i = 2; i >= 0; i--) {\n        if (base[i]) {\n            if (i+step > 2) {\n                score++;\n            }\n            else {\n                base[i+step] = 1;\n            }\n            base[i] = 0;\n        }\n    }\n    if (step < 4)\n        base[step-1] = 1;\n    else\n        score++;\n    return score;\n}\n\nint main() {\n    string p[9][5];\n    int pn[9], b, base[3] = {}, score = 0, out = 0, done = 0;\n\n    for (int i = 0; i < 9; i++) {\n        cin >> pn[i];\n        for (int j = 0; j < pn[i]; j++) {\n            cin >> p[i][j];\n        }\n    }\n    cin >> b;\n\n    for (int j = 0; j < 5; j++) {\n        for (int i = 0; i < 9; i++) {\n            if (j >= pn[i]) {\n                done = 1;\n                break;\n            }\n            string hit = p[i][j];\n            if (hit == \"1B\" || hit == \"2B\" || hit == \"3B\") {\n                score += run(base, hit[0]-'0');\n            }\n            else if (hit == \"HR\") {\n                score += run(base, 4);\n            }\n            else if (hit == \"SO\" || hit == \"FO\" || hit == \"GO\") {\n                out++;\n                b--;\n                if (out >= 3) {\n                    for (int k = 0; k < 3; k++) {\n                        base[k] = 0;\n                    }\n                    out = 0;\n                }\n            }\n            if (b == 0) {\n                done = 1;\n                break;\n            }\n        }\n        if (done)\n            break;\n    }\n    cout << score << '\\n';\n}"
  },
  {
    "id": "string12",
    "instruction": "暑假的桃子真的太閒了，就連瘋狂的打出 `qwq` （請參考 dp34 ）也止不住寂寞。\n\n這天桃子又隨手打出了一個只由小寫英文字母組成的字串 $s$，他突發奇想，想試著利用一些操作來讓這個字串的字典序變的最小：\n- 從 `a` 到 `z` 選一個字母，並且將 $s$ 裡面所有的該字母通通置換為字典序上的前一個字母，舉例而言，把所有的 `c` 都替換為`b`；要特別注意的是，選擇 `a` 時會將所有的字母 `a` 通通替換為字母 `z`。\n\n但因為桃子有點睏了，剩下的時間只夠他進行最多 $k$ 次操作，你決定告訴桃子在進行不超過 $k$ 次的操作之後，所能獲得的最小字典序的字串為何，好讓桃子可以安心睡覺。\n\n輸入的第一行有一個整數 $t\\ (1\\le t\\le 10^4)$，代表測資的數量。\n\n每一筆測資的第一行有兩個整數 $n, k\\ (1\\le n\\le 2\\times 10^5, 1\\le k\\le 10^9)$，分別代表桃子打出來的字串長度以及最多可進行的操作數量，兩者之間以空格分隔。\n\n第二行則是一個長度為 $n$ 的字串 $s$，代表桃子打出來的字串，$s$ 只包含小寫字母。\n\n保證所有測資的 $n$ 的總和不超過 $2\\times 10^5$\n\n對於每筆測資請輸出一行，包含一個字串，代表 $s$ 在經過不超過 $k$ 次操作之後，所能獲得的最小字典序的字串。\n\n",
    "output": "#include <iostream>\n\n#define ALPHA_CNT 26\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        string s;\n        cin >> s;\n\n        char max_char = 'a';\n        for (int i = 0; i < n; ++i) {\n            if (s[i] > max_char) {\n                if (s[i] - 'a' <= k) {\n                    max_char = s[i];\n                }\n                else {\n                    int remain_op = k - (max_char - 'a');\n                    char up_bound = s[i];\n                    char low_bound = s[i] - remain_op;\n\n                    for (int j = 0; j < n; ++j) {\n                        if (s[j] > low_bound and s[j] <= up_bound) {\n                            s[j] = low_bound;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (s[i] <= max_char) {\n                s[i] = 'a';\n            }\n        }\n        cout << s << '\\n';\n    }\n}\n"
  },
  {
    "id": "string13",
    "instruction": "大河想要為他的新商品命名，為了讓他的新商品能最早的被人發現，大河希望他的新商品名稱的字典序越小越好。\n\n雖然說大河已經想到了一個名稱 $s$，但為了想要聽聽更多人的想法，便決定走訪知名的 $n$ 家設計公司尋求建議。\n\n每一家設計公司都會提供一個新的名稱 $s'$，如果新的名稱 $s'$ 的字典序比大河屬意的名稱還要小，那大河就會將心中屬意的名稱替換為 $s'$，並繼續向下一間設計公司詢問；但如果新的名稱的字典序大於或等於大河屬意的名稱，大河就會大聲的喊出新的名稱 $s'$ 並要求退費。\n\n注意，只要大河離開了某間設計公司，就再也沒辦法利用大喊該公司提供的命名的方式來要求退費了，也就是說，只有否決新的提案時，才需要大喊新的名稱並退費\n\n第一行有一個整數 $n\\ (1\\le n\\le 10^5)$ 跟一個字串 $s$，$s$ 的長度不超過 $60$，代表大河要走訪個設計公司數量以及一開始屬意的新商品名稱，兩者之間以空白分隔。\n\n接下來 $n$ 行之中，第 $i$ 有一個字串 $s'$ 代表第 $i$ 間設計公司提供的商品名稱，$s'$ 的長度不超過 $60$。\n\n保證所有的字串皆由大、小寫英文字母所組成。\n\n對於每一個設計公司提供的名稱 $s'$，如果 $s'$ 的字典序小於大河心中屬意的 $s$，就把大河屬意的 $s$ 替換為 $s'$，否則就輸出 $s'$ 並換行，代表喊出名稱並退費。\n\n最後一行請輸出最後大河屬意的商品名稱。\n\n",
    "output": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    string s;\n    cin >> n >> s;\n\n    while (n--) {\n        string new_s;\n        cin >> new_s;\n        if (new_s < s) {\n            s = new_s;\n        }\n        else {\n            cout << new_s << '\\n';\n        }\n    }\n    cout << s << '\\n';\n}\n"
  },
  {
    "id": "string14",
    "instruction": "有一天 APCSC 幼稚園的老師要帶著 $n$ 位小朋友們玩遊戲，幼稚園經過擴建之後變成超大型的幼稚園，最多可以容納 $5000$ 個人！遊戲規則仍然相同：由老師給小朋友們一人一張上面寫著**小寫英文字母**的卡片，並要求小朋友們排成一列。超大型幼稚園的小朋友們都很聰明，知道什麼是迴文字串。只要有小朋友們手上的字卡在隊伍中組成一個**長度大於1**的迴文字串，則這些組成迴文字卡的小朋友**總共**可以獲得一塊小蛋糕（組內所有人分一塊蛋糕喔！不是一人一塊）。\n\n幼稚園改建之前，老師還勉強可以使用超強的心算與記憶力統計出蛋糕的數量。但改建後人數過多，因此老師想請你寫一個程式幫老師計算這次遊戲總共要發出幾塊蛋糕？\n輸入只有一行，包含一個長度為 $n$ 的字串代表手拿字卡的小朋友所排成的隊伍，$1 \\le n \\le 5000$。其中每張字卡皆為小寫英文字母（a-z）。\n\n輸出一行一個整數代表老師總共要發出的小蛋糕數量。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    string s;\n    int ans = 0;\n\n    cin >> s;\n    int N = s.length();\n    for (int i = 0, k; i < N; i++) {\n        k = 1;\n        while (i-k >= 0 && i+k < N) {\n            if (s[i-k] != s[i+k])\n                break;\n            ans++;\n            k++;\n        }\n        if (i+1 < N && s[i]==s[i+1]) {\n            ans++;\n            k = 1;\n            while (i-k >= 0 && i+1+k < N) {\n                if (s[i-k] != s[i+1+k])\n                    break;\n                ans++;\n                k++;\n            }\n        }\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "id": "string15",
    "instruction": "身為均值理論（Mean Value Theorem）的支持者，賽先生生活的一切都跟均衡脫不了關係：吃肯O雞永遠不會只點蛋塔、打麻將永遠都是平均放槍給另外三家、APCSC 更是每年都參加，絕不偏袒任何一年。\n\n最近賽先生看到了朋友桃子寄給他、且只由字母 `x` 跟 `y` 組成的字串 $s$，基於均值理論，賽先生相信這個字串一定也跟均衡有所關係：他認為字串中的某個區間裡，字母 `x` 跟字母 `y` 的出現次數會相等，此時這個區間稱作「均衡」，但因為賽先生的數學真的太爛了，所以決定請你來幫忙他找出一段均衡的區間。\n\n輸入的第一行有一個正整數 $t\\ (1\\le t\\le 1000)$ 代表測試資料的數量。\n\n每一筆測試資料有兩行，第一行包含一個正整數 $n\\ (1\\le n\\le 50)$，代表桃子寄來的字串長度。\n\n第二行包含一個長度為 $n$ 的字串，代表桃子寄來的字串，字串內容僅由 `x` 跟 `y` 兩種字母組成。\n\n對於每一筆測資請輸出一行，如果該字串中存在均衡區間，請輸出區間左、右界的索引值（區間包含左右界，從 $1$ 開始算），兩者之間以空格分隔，如果有多個區間，輸出任意一組區間即可；如果不存在均衡區間，請輸出 `-1 -1`。\n\n",
    "output": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n\n    for (int i = 0; i < t; ++i) {\n        vector<pair<int, int>> ans;\n        pair<int, int> true_ans = {-2, -2};\n        int n;\n        cin >> n;\n        string input;\n        cin >> input;\n\n        for (int j = 0; j < n; ++j) {\n            for (int k = j; k < n; ++k) {\n                int x_cnt = 0, y_cnt = 0;\n                for (int l = j ; l <= k; ++l) {\n                    if (input[l] == 'x')\n                        x_cnt++;\n                    if (input[l] == 'y')\n                        y_cnt++;\n                }\n\n                if (x_cnt == y_cnt) {\n                    true_ans = make_pair(j, k);\n                    if (k > j + 1)\n                        ans.push_back(make_pair(j, k));\n                }\n            }\n        }\n\n        if (ans.empty()) {\n            cout << true_ans.first + 1 << ' ' << true_ans.second + 1<< '\\n';\n        }\n        else {\n            int size = ans.size();\n            pair<int, int> ret = ans[(size - (i % size) + size) % size];\n            cout << ret.first + 1 << ' ' << ret.second + 1<< '\\n';\n        }\n    }\n}\n"
  },
  {
    "id": "string16",
    "instruction": "有一天 APCSC 幼稚園的老師要帶著 $n$ 位小朋友們玩遊戲：老師給小朋友們一人一張上面寫著**小寫英文字母**的卡片，並要求小朋友們排成一列。APCSC 幼稚園的小朋友們都很聰明，知道什麼是迴文字串。只要有小朋友們手上的字卡在隊伍中組成一個**長度大於1**的迴文字串，則這些組成迴文字卡的小朋友**總共**可以獲得一塊小蛋糕（組內所有人分一塊蛋糕喔！不是一人一塊）。請你寫一個程式幫老師計算這次遊戲總共要發出幾塊蛋糕？\n輸入只有一行，包含一個長度為 $n$ 的字串代表手拿字卡的小朋友所排成的隊伍，$1 \\le n \\le 100$。其中每張字卡皆為小寫英文字母（a-z）。\n\n輸出一行一個整數代表老師總共要發出的小蛋糕數量。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    string s;\n    int ans = 0;\n\n    cin >> s;\n    for (int i = 0; i < (int)s.length(); i++) {\n        for (int j = i+1; j < (int)s.length(); j++) {\n            bool is_palindrome = true;\n            for (int k = 0; k < (j-(i-1))/2; k++) {\n                if (s[i+k] != s[j-k]) {\n                    is_palindrome = false;\n                    break;\n                }\n            }\n            if (is_palindrome) {\n                ans++;\n            }\n        }\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "id": "string17",
    "instruction": "本題請實作 $N$ 位數 $\\overline{a_{N-1}a_{N-2}\\dots a_0}$ 和 $M$ 位數 $\\overline{b_{M-1}b_{M-2}\\dots b_0}$ 的加法、減法以及乘法。保證運算結果仍為正整數。\n\n輸入第一行是三個空白分隔的正整數 $N, M, op$，分別代表第一和第二個數的位數，以及操作種類。當 $op = 0$ 時執行大數加法，當 $op = 1$ 時執行減法，當 $op = 2$ 時執行乘法。\n第二行有一個長度 $N$ 的字串，即 $N$ 為整數。\n第二行有一個長度 $M$ 的字串，即 $M$ 為整數。\n\n輸入保證 $1\\le N, M\\le 1000$，$0\\le a_i, b_i\\le 9$，$a_{N-1}, b_{M-1}\\ne 0$。\n\n輸出一行一個字串表示運算結果，字串不得有前導 $0$。\n\n",
    "output": "#include <iostream>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nint a[maxn], b[maxn], ans[maxn];\nstring s, t;\nint main() {\n    int N, M, op = 0;\n    cin >> N >> M >> op;\n    cin >> s >> t;\n    for(int i = 0; i < N; i++) a[N-1-i] = s[i]-'0';\n    for(int i = 0; i < M; i++) b[M-1-i] = t[i]-'0';\n    if(op == 0) {\n        for(int i = 0; i < max(N, M); i++) ans[i] = a[i]+b[i];\n        for(int i = 0; i < N+M; i++) {\n            if(ans[i] >= 10) {\n                ans[i] -= 10;\n                ans[i+1]++;\n            }\n        }\n    }\n    if(op == 1) {\n        for(int i = 0; i < max(N, M); i++) ans[i] = a[i]-b[i];\n        for(int i = 0; i < N+M; i++) {\n            if(ans[i] < 0) {\n                ans[i] += 10;\n                ans[i+1]--;\n            }\n        }\n    }\n    if(op == 2) {\n        for(int i = 0; i < N; i++)\n            for(int j = 0; j < M; j++)\n                ans[i+j] += a[i]*b[j];\n        for(int i = 0; i < N+M+10; i++) {\n            ans[i+1] += ans[i] / 10;\n            ans[i] %= 10;\n        }\n    }\n    int digit = N+M+10;\n    while(ans[digit] == 0) {\n        digit--;\n    }\n    for(int i = digit; i >= 0; i--) cout << ans[i];\n    cout << endl;\n}\n"
  },
  {
    "id": "struct01",
    "instruction": "APCS 營隊為了方便處理學生的資料，因此他們條列出了一些學生個人資料的必要欄位，並希望你實作出一個結構，可以用來儲存這些資料好滿足他們的需求。\n\n詳細的說，你被要求設計出一個結構，請在程式碼的**最後一行**引入標頭檔 `struct01.h`，並實作出含有以下資訊的結構：\n\n- `struct` 的名稱為 `student`\n- 一個 `string` 變數名叫 `name`，用來儲存學生的名字\n- 一個 `string` 變數名叫 `number`，用來儲存學生的學號\n- 一個 `char` 變數名叫 `group`，用來辨識學生的組別\n- 一個 `int` 變數名叫 `score_concept`，用來儲存學生 APCS 模擬賽內觀念題的成績\n- 一個大小為 4 的 `int` 陣列名叫 `score_implement`，`score_implement[i]` 用來儲存學生 APCS 模擬賽內第 $i$ 題實作題的成績\n\n注意請勿在你的程式碼宣告主函式 `main()` 以及進行任何輸入輸出的動作，你同時也不需要實作任何除了結構以外的函式，幫結構內部的變數賦予值，宣告任何不必要的變數，或宣告任何的全域變數，否則將會發生不可預期的結果。\n\n若你的結構實作不符合需求，除了獲得 `Wrong Answer` 之外，你更有可能獲得 `Compile Error` 或 `Runtime Error`。\n\n提示：你可能會需要 `include` 需要的標頭檔來迴避 `Compile Error`。\n\n如果還是不確定該如何進行，可以複製以下的程式碼進行修改：\n\n```C++\nstruct student {\n\t//your code here\n};\n\n#include \"struct01.h\"\n```\n\n本題沒有輸入，隨意輸入將會得到不可預期的結果。\n\n本題沒有輸出，隨意輸出將會得到不可預期的結果。\n\n",
    "output": "#include <string>\n\nstruct student {\n    std::string name;\n    std::string number;\n    char group;\n    int score_concept;\n    int score_implement[4];\n};\n\n#include \"struct01.h\"\n"
  },
  {
    "id": "struct02",
    "instruction": "APCS 營隊為了方便處理學生的資料，因此他們條列出了一些學生個人資料的必要欄位，並希望你實作出一個結構，可以用來儲存這些資料好滿足他們的需求。\n\n詳細的說，你被要求設計出一個結構，請在程式碼的**最後一行**引入標頭檔 `struct02.h`，並實作出含有以下資訊的結構：\n\n- `struct` 的名稱為 `student`\n- 一個 `string` 變數名叫 `name`，用來儲存學生的名字\n- 一個 `string` 變數名叫 `number`，用來儲存學生的學號\n- 一個 `char` 變數名叫 `group`，用來辨識學生的組別\n- 一個 `int` 變數名叫 `score_concept`，用來儲存學生 APCS 模擬賽內觀念題的成績\n- 一個大小為 4 的 `int` 陣列名叫 `score_implement`，`score_implement[i]` 用來儲存學生 APCS 模擬賽內第 $i$ 題實作題的成績\n\n除此之外，我們還需要一個「輸出」的函數。請重載 `<<` 的運算子，讓測試的程式碼可以執行。假設這個人的名字為 `Gooruh`、`number` 為 `123456`、`group`為 `E`、`score_concept` 為 `92`、 `score_implement` 為 `[50, 80, 70, 100]`，則請輸出三行，每一行最後有換行：\n\n```\nGooruh: #123456, Group E\nConcept Score: 92\nImplementation Scores: 50, 80, 70, 100\n\n```\n\n此外，一筆測資將會呼叫這個函式 $N(N \\leq 5000)$ 次，所以也請注意一下執行時間。\n\n注意請勿在你的程式碼宣告主函式 `main()` 以及進行任何輸入輸出的動作，你同時也不需要實作任何除了結構以外的函式，幫結構內部的變數賦予值，宣告任何不必要的變數，或宣告任何的全域變數，否則將會發生不可預期的結果。\n\n若你的結構實作不符合需求，除了獲得 `Wrong Answer` 之外，你更有可能獲得 `Compile Error` 或 `Runtime Error`。\n\n提示：你可能會需要 `include` 需要的標頭檔來迴避 `Compile Error`。\n\n如果還是不確定該如何進行，可以複製以下的程式碼進行修改：\n\n```C++\nstruct student {\n\t//your code here\n};\n\n#include \"struct02.h\"\n```\n\n本題沒有輸入，隨意輸入將會得到不可預期的結果。\n\n本題沒有輸出，隨意輸出將會得到不可預期的結果。\n\n",
    "output": "#include <string>\n#include <iostream>\nusing namespace std;\n/*\nGooruh: #123456, Group E\nConcept Score: 92\nImplementation Scores: 50, 80, 70, 100\n*/\n\nstruct student {\n    std::string name;\n    std::string number;\n    char group;\n    int score_concept;\n    int score_implement[4];\n};\n\nostream& operator<<(ostream& os, const student& s)\n{\n\tos << s.name << \": #\" << s.number << \", Group \" << s.group << endl;\n\tos << \"Concept Score: \" << s.score_concept << endl;\n\tos << \"Implementation Scores: \" << s.score_implement[0] << \", \" << s.score_implement[1] << \", \" << s.score_implement[2] << \", \" << s.score_implement[3] << endl;\n    return os;\n}\n\n#include \"struct02.h\"\n"
  },
  {
    "id": "struct03",
    "instruction": "相信在上兩題裡面你已經學會如何建立一個 Struct 來處理一個學生的資料了！現在我們要請你一次處理多個學生資料，並回答一些問題。\n\n具體來說，你需要讀入 $N$ 位學生的資訊，每位學生有五個資訊：\n\n* `name`：學生的名字，由小寫英文字母組成。\n* `number`：學生的學號，由數字組成。\n* `group`：學生的組別，由一個小寫英文字元（`char`）組成\n* `score_concept`：學生的觀念題成績。\n* `score_implement_i`：學生第 $i$ 題上機題目的分數；總共會有四題。\n\n然後，你需要回答 $Q$ 筆詢問，格式如下：\n\n* `i 1`：請回答第 $i$ 位學生的名字（`name`)。\n* `i 2`：請回答第 $i$ 位學生的學號（`number`）。\n* `i 3`：請回答第 $i$ 位學生的組別（`group`）。\n* `i 4`：請回答第 $i$ 位學生的觀念題成績（`score_concept`）。\n* `i 5 j`：請回答第 $i$ 位學生的第 $j$ 題上機題成績（`score_implement_j`）\n\n**我們建議你使用 Struct 陣列 + 輸入運算子重載來解決這題！**\n\n第一行有一個數字 $N$，代表學生的數量。接下來 $N$ 行每一行都有學生的資訊，其中第 $i$ 行有第 $i$ 位學生的資訊，格式如下：\n\n```\nname number group score_concept score_implement_1 score_implement_2 score_implement_3 score_implement_4\n```\n\n接者一行有一個數字 $Q$，代表詢問的數量。接下來 $Q$ 行每一行都有一個詢問，格式如題述所述。\n\n* $1 \\le N \\le 1000$\n* $1 \\le Q \\le 10000$\n* `name` 由小寫英文字母組成的字串，長度介於 $1$ 至 $10$ 之間\n* `number` 由數字組成，範圍介於 $1$ 至 $2147483647$ 之間\n* `group` 由一個小寫英文字母組成\n* `score_concept` 為一個介於 $0$ 到 $100$ 之間的數字\n* `score_implement_i` 為一個介於 $0$ 到 $100$ 之間的數字\n\n對於每一個詢問，請將回答輸出於獨立的一行（所以你總共需要輸出 $Q$ 行）。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nstruct student {\n    string name;\n    string number;\n    char group;\n    int score_concept;\n    int score_implement[4];\n} Students[1005];\n\nistream& operator>>(istream& is, student& s) {\n\tis >> s.name >> s.number >> s.group >> s.score_concept;\n\tfor (int i = 0; i < 4; i++) {\n\t\tis >> s.score_implement[i];\n\t}\n\treturn is;\n}\n\nint main() {\n\tint N; cin >> N;\n\tfor (int i = 0; i < N; i++) cin >> Students[i];\n\tint Q; cin >> Q;\n\twhile (Q--) {\n\t\tint id, op; cin >> id >> op;\n\t\tid--;\n\t\tif (op == 1) {\n\t\t\tcout << Students[id].name << '\\n';\n\t\t} else if (op == 2) {\n\t\t\tcout << Students[id].number << '\\n';\n\t\t} else if (op == 3) {\n\t\t\tcout << Students[id].group << '\\n';\n\t\t} else if (op == 4) {\n\t\t\tcout << Students[id].score_concept << '\\n';\n\t\t} else {\n\t\t\tint probId; cin >> probId; probId--;\n\t\t\tcout << Students[id].score_implement[probId] << '\\n';\n\t\t}\n\t}\t\n}\n"
  },
  {
    "id": "struct04",
    "instruction": "承上題，你現在會一次存 $N$ 筆學生的資料了，並處理相關的詢問了！現在我們要做一些更厲害的操作。\n\n具體來說，你需要讀入 $N$ 位學生的資訊，每位學生有五個資訊：\n\n* `name`：學生的名字，由小寫英文字母組成。\n* `number`：學生的學號，由數字組成。\n* `group`：學生的組別，由一個小寫英文字元（`char`）組成\n* `score_concept`：學生的觀念題成績。\n* `score_implement_i`：學生第 $i$ 題上機題目的分數；總共會有四題。\n\n接者，你要將他們按照觀念題的分數排序；若觀念題分數相同，要按照上機四題的分數和排序；若觀念題和上機四題的分數和都相通，就按照名字的字典序排序。\n\n然後，你需要回答 $Q$ 筆詢問，每次詢問包含一個數字 $i$，代表你要輸出排序後從小往上數第 $i$ 位學生的成績，格式如下：\n\n```\nStudent [i]\nname = [學生姓名]\nnumber = [學生學號]\ngroup = [學生組別]\nscore_concept = [學生觀念題]\nscore_implement = [學生四題上機題目分數，用空白分隔]\n```\n\n若對於上述輸出不了解，請參考範例輸入輸出。\n\n**我們建議你使用 Struct 陣列 + 運算子重載來解決這題！**\n\n第一行有一個數字 $N$，代表學生的數量。接下來 $N$ 行每一行都有學生的資訊，其中第 $i$ 行有第 $i$ 位學生的資訊，格式如下：\n\n```\nname number group score_concept score_implement_1 score_implement_2 score_implement_3 score_implement_4\n```\n\n接者一行有一個數字 $Q$，代表詢問的數量。接下來 $Q$ 行每一行都有一個詢問，格式如題述所述。\n\n* $1 \\le N \\le 1000$\n* $1 \\le Q \\le 10000$\n* `name` 由小寫英文字母組成的字串，長度介於 $1$ 至 $10$ 之間。保證所有的同學姓名相異。\n* `number` 由數字組成，範圍介於 $1$ 至 $2147483647$ 之間\n* `group` 由一個小寫英文字母組成\n* `score_concept` 為一個介於 $0$ 到 $100$ 之間的數字\n* `score_implement_i` 為一個介於 $0$ 到 $100$ 之間的數字\n\n對於每一個詢問，請輸出對應的答案（所以你總共需要輸出 $Q\\times 6$ 行，每行學生的輸出有 $6$ 行）。\n\n",
    "output": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct student {\n    string name;\n    string number;\n    char group;\n    int score_concept;\n    int score_implement[4];\n\n    bool operator<(const student& s) {\n    \tif (score_concept != s.score_concept) {\n    \t\treturn score_concept < s.score_concept;\n    \t}\n\n    \tint sum[2] = {0};\n    \tfor (int i = 0; i < 4; i++) {\n    \t\tsum[0] += score_implement[i];\n    \t\tsum[1] += s.score_implement[i];\n    \t}\n    \tif (sum[0] != sum[1]) {\n    \t\treturn sum[0] < sum[1];\n    \t}\n\n    \treturn name < s.name;\n    }\n} Students[1005];\n\nistream& operator>>(istream& is, student& s) {\n\tis >> s.name >> s.number >> s.group >> s.score_concept;\n\tfor (int i = 0; i < 4; i++) {\n\t\tis >> s.score_implement[i];\n\t}\n\treturn is;\n}\nostream& operator<<(ostream& os, const student& s) {\n\tos << \"name = \" << s.name << '\\n';\n\tos << \"number = \" << s.number << '\\n';\n\tos << \"group = \" << s.group << '\\n';\n\tos << \"score_concept = \" << s.score_concept << '\\n';\n\tos << \"score_implement =\";\n\tfor (int i = 0; i < 4; i++) {\n\t\tos << ' ' << s.score_implement[i];\n\t}\n\tos << '\\n';\n\treturn os;\n}\n\nint main() {\n\tint N; cin >> N;\n\tfor (int i = 0; i < N; i++) cin >> Students[i];\n\tsort(Students, Students + N);\n\tint Q; cin >> Q;\n\twhile (Q--) {\n\t\tint id; cin >> id;\n\t\tcout << \"Student \" << id << '\\n';\n\t\tcout << Students[id-1];\n\t}\t\n}\n"
  },
  {
    "id": "struct05",
    "instruction": "小 K 在上數學課，而數學老師正在教複數的概念，聰明的小 K 想到了可以使用程式來解決問題，希望你能夠幫助他實作出一個結構，可以用來處理虛數的問題。\n\n需要設計出一個結構，請在程式碼的**最後一行**引入標頭檔 `struct05.h`，並實作出含有以下資訊的結構：\n\n- `struct` 的名稱為 `complex`\n- 一個 `double` 變數名叫 `real`，用來儲存複數的實部\n- 一個 `double` 變數名叫 `imaginary`，用來儲存複數的虛部\n\n注意請勿在你的程式碼宣告主函式 `main()` 以及進行任何輸入輸出的動作，你同時也不需要實作任何除了結構以外的函式，幫結構內部的變數賦予值，宣告任何不必要的變數，或宣告任何的全域變數，否則將會發生不可預期的結果。\n\n若你的結構實作不符合需求，除了獲得 `Wrong Answer` 之外，你更有可能獲得 `Compile Error` 或 `Runtime Error`。\n\n提示：你可能會需要 `include` 需要的標頭檔來迴避 `Compile Error`。\n\n如果還是不確定該如何進行，可以複製以下的程式碼進行修改：\n\n```C++\nstruct complex {\n\t//your code here\n};\n\n#include \"struct05.h\"\n```\n\n本題沒有輸入，隨意輸入將會得到不可預期的結果。\n\n本題沒有輸出，隨意輸出將會得到不可預期的結果。\n\n",
    "output": "struct complex {\n    double real;\n    double imaginary;\n};\n\n#include \"struct05.h\"\n"
  },
  {
    "id": "struct06",
    "instruction": "小 K 在上數學課，而數學老師正在教複數的概念，聰明的小 K 想到了可以使用程式來解決問題，希望你能夠幫助他實作出一個結構，可以用來處理虛數的問題。\n\n需要設計出一個結構，請在程式碼的**最後一行**引入標頭檔 `struct05.h`，並實作出含有以下資訊的結構：\n\n- `struct` 的名稱為 `complex`\n- 一個 `double` 變數名叫 `real`，用來儲存複數的實部\n- 一個 `double` 變數名叫 `imaginary`，用來儲存複數的虛部\n\n除此之外，我們還需要處理加、減、乘、除。請重載 `+`,`-`,`*`,`/` 的運算子，讓測試的程式碼可以執行四則運算。\n\n\n一個複數可以用 $a + bi$ 表示，其中 $a$ 為此虛數的實部， $b$ 為此虛數的虛部，$i=\\sqrt{-1}$。\n如果有兩個虛數 $A = a + bi, B = c + di$，那麼他的四則運算如下：\n加法：$A+B = (a+bi) + (c+di) = (a+c) + (b+d)i$ \n減法：$A-B = (a+bi) + (c+di) = (a-c) + (b-d)i$ \n乘法：$A\\times B = (a+bi)(c+di) = ac+bci+adi+bdi^{2}=(ac-bd)+(bc+ad)i$。\n除法：$A\\div B = \\frac{a+bi}{c+di} = \\frac{(a+bi)(c-di)}{(c+di)(c-di)} = \\frac{ac+bci-adi-bdi^2}{c^2-(di)^2}=\\frac{(ac+bd)+(bc-ad)i}{c^2+d^2}$\n\n注意請勿在你的程式碼宣告主函式 `main()` 以及進行任何輸入輸出的動作，你同時也不需要實作任何除了結構以外的函式，幫結構內部的變數賦予值，宣告任何不必要的變數，或宣告任何的全域變數，否則將會發生不可預期的結果。\n\n若你的結構實作不符合需求，除了獲得 `Wrong Answer` 之外，你更有可能獲得 `Compile Error` 或 `Runtime Error`。\n\n提示：你可能會需要 `include` 需要的標頭檔來迴避 `Compile Error`。\n\n如果還是不確定該如何進行，可以複製以下的程式碼進行修改：\n\n```C++\nstruct complex {\n\t//your code here\n};\n\n#include \"struct06.h\"\n```\n\n本題沒有輸入，隨意輸入將會得到不可預期的結果。\n\n本題沒有輸出，隨意輸出將會得到不可預期的結果。\n\n",
    "output": "#include <string>\n#include <iostream>\nusing namespace std;\n\nstruct complex {\n    double real;\n    double imaginary;\n};\n\ncomplex operator-(const complex& cp1, const complex& cp2)\n{\n    complex c;\n    c.real = cp1.real - cp2.real;\n    c.imaginary = cp1.imaginary - cp2.imaginary;\n    return c;\n}\n\ncomplex operator+(const complex& cp1, const complex& cp2)\n{\n    complex c;\n    c.real = cp1.real + cp2.real;\n    c.imaginary = cp1.imaginary + cp2.imaginary;\n    return c;\n}\n\ncomplex operator*(const complex& cp1, const complex& cp2)\n{\n    complex c;\n    c.real = cp1.real*cp2.real - cp1.imaginary*cp2.imaginary;\n    c.imaginary = cp1.real*cp2.imaginary + cp1.imaginary*cp2.real;\n    return c;\n}\n\ncomplex operator/(const complex& cp1, const complex& cp2)\n{\n    complex c;\n    double tmp = cp2.real*cp2.real + cp2.imaginary*cp2.imaginary;\n    c.real = cp1.real*cp2.real + cp1.imaginary*cp2.imaginary;\n    c.imaginary = cp1.imaginary*cp2.real - cp1.real*cp2.imaginary;\n    c.real /= tmp;\n    c.imaginary /= tmp;\n    return c;\n}\n\n#include \"struct06.h\""
  },
  {
    "id": "struct07",
    "instruction": "小 K 現在有太多的複數了，所以希望你能夠幫助他把現有的複數儲存起來，在請求資料時再回覆。\n\n請在程式碼**最前面**引入標頭檔 `struct07.h`，並實作以下功能：\n\n- 多載運算子 `>>`，使得讀取一個複數 `cpx` 可以由 `cin >> cpx.real >> cpx.imaginary` 改為 `cin >> cpx`\n- 主程式\n  會需要用到以下兩種函式：\n  `Init(int &N, int &Q, complex_number*& cpx, Query*& queries)`\n    * $N$ 代表複數的個數\n    * $Q$ 代表 Query 的次數(Query等等會說明)\n    * $cpx$ 代表複數的指標\n    * $queries$ 代表 Query 的指標\n  `Answer(double ans)`\n    * $ans$ 代表請求的資料\n  一開始請先宣告好需要的變數，再透過 `Init` 讀取資料。接著需要呼叫 $Q$ 次 `Answer` 依序回答 `queries[0] ~ queries[N-1]` 所要求的資料，而 `Query` 含有以下的內容：\n  - `queries[i].index` 代表要回答的是第幾個複數\n  - `queries[i].type` 是一個 enum，代表要回答的是實部還是虛部\n    - 如果 `queries[i].type == real` 的話就是實部\n    - 如果 `queries[i].type == imaginary` 的話就是虛部\n\ncomplex 和 Query 都已經定義在 `struct07.h`，不需要額外實作。\n\n注意此題不需要任何的輸入或輸出，否則將會發生不可預期的結果。\n\n若你的結構實作不符合需求，除了獲得 `Wrong Answer` 之外，你更有可能獲得 `Compile Error` 或 `Runtime Error`。\n\n提示：你可能會需要 `include` 需要的標頭檔來迴避 `Compile Error`。\n\n如果還是不確定該如何進行，可以參考以下的程式碼進行修改：\n\n```C++\n#include \"struct07.h\"\n\nint main(){\n    int N, Q;\n    Query* queries;\n    complex_number* cpx;\n    Init(N, Q, cpx, queries);\n    for(int i = 0; i < Q; i++){\n        double ans = 0;\n        if (queries[i].type == real){\n            // TODO\n        }\n        if (queries[i].type == imaginary){\n            // TODO\n        }\n        Answer(ans);\n    }\n}\n```\n\n本題沒有輸入，隨意輸入將會得到不可預期的結果。\n\n本題沒有輸出，隨意輸出將會得到不可預期的結果。\n\n",
    "output": "#include \"struct07.h\"\n\nistream& operator>>(istream& is, complex_number& cpx){\n    is >> cpx.real >> cpx.imaginary;\n    return is;\n}\n\nint main(){\n    int N, Q;\n    Query* queries;\n    complex_number* cpx;\n    Init(N, Q, cpx, queries);\n    for(int i = 0; i < Q; i++){\n        int idx = queries[i].index;\n        if(queries[i].type == real)\n            Answer(cpx[idx].real);\n        else\n            Answer(cpx[idx].imaginary);\n    }\n}"
  },
  {
    "id": "struct08",
    "instruction": "小 K 現在有太多的複數了，所以希望你能夠幫助他把部份的複數儲存起來並依照絕對值由小而大排序（若絕對值相同時則以實部排序）。\n> 一個虛數 $a + bi$ 的絕對值為 $\\sqrt {a^2 + b^2}$\n\n請在程式碼**最前面**引入標頭檔 `struct08.h`，並實作以下功能：\n\n- 主程式\n  會需要用到以下三種函式：\n\n    - `Init(int& Q);`\n        - $Q$ 代表詢問的次數\n    - `Get_Query(int& N, complex_number*& cpx);`\n        - $N$ 代表複數的個數\n        - $cpx$ 代表複數的指標\n    - `Answer(int N, complex_number* cpx)`\n        - $N$ 代表複數的個數\n        - $cpx$ 代表複數的指標\n    - 一開始要透過 `Init` 得知要作 $Q$ 次詢問。接著在每次詢問中，需要先透過 `Get_Query` 得知要排序的複數個數及內容，並藉由 `Answer` 回覆。\n\nHint: 可以多載運算子 `<` 來協助排序。\n\n注意此題不需要任何的輸入或輸出，否則將會發生不可預期的結果。\n\n若你的結構實作不符合需求，除了獲得 `Wrong Answer` 之外，你更有可能獲得 `Compile Error` 或 `Runtime Error`。\n\n提示：你可能會需要 `include` 需要的標頭檔來迴避 `Compile Error`。\n\n如果還是不確定該如何進行，可以參考以下的程式碼進行修改：\n\n```C++\n#include \"struct08.h\"\n\nint main(){\n    int Q;\n    Init (Q);\n    while(Q--){\n        int N;\n        complex_number* cpx;\n        Get_Query(N, cpx);\n        // TODO (do some sorting)\n        Answer(N, cpx);\n    }\n}\n```\n\n本題沒有輸入，隨意輸入將會得到不可預期的結果。\n\n本題沒有輸出，隨意輸出將會得到不可預期的結果。\n\n",
    "output": "#include \"struct08.h\" \n#include <algorithm>\nint main(){\n    int Q;\n    Init (Q);\n    for(int i = 0; i < Q; i++){\n        int N;\n        complex_number* cpx;\n        Get_Query(N, cpx);\n\n        sort(cpx, cpx+N, [&](complex_number a, complex_number b){\n            return a.real*a.real + a.imaginary*a.imaginary == b.real*b.real + b.imaginary*b.imaginary?\n            (a.real < b.real) : (a.real*a.real + a.imaginary*a.imaginary < b.real*b.real + b.imaginary*b.imaginary);\n        });\n\n        Answer(N,cpx);\n    }\n}"
  },
  {
    "id": "timecomplexity01",
    "instruction": "電皇思朋有很多奇怪的興趣，其中一個興趣就是喜歡出奇怪的練習題羞辱同學。\n\n你已被電皇羞辱。現在給你一個小寫英文字母組成的字串 $S$，求最短的子字串包含所有小寫英文字母。\n\n輸入只有一行，為電皇給你的字串 $S$，其中保證 $S$ 只由小寫英文字母 `a` 到 `z` 組成，且 $S$ 的長度不超過 $10^6$。\n\n輸出一行，為包含所有的小寫字母中最短的子字串。如果有多個最短的子字串，請輸出第一次出現的。如果這種子字串不存在，請輸出 `QQ`。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint cnt[26];\n\nunsigned int flag;\n\nvoid init() {\n    for (int i = 0; i < 26; i++) {\n        flag |= (1 << i);\n    }\n}\n\nvoid inc(char c) {\n    int x = c - 'a';\n    ++cnt[x];    \n    flag &= ~(1 << x);\n}\n\nvoid dec(char c) {\n    int x = c - 'a';\n    if (! --cnt[x]) {\n        flag |= (1 << x);\n    }\n}\n\nbool is_valid() {\n    return !flag;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    init();\n    // input\n    string s;\n    cin >> s;\n\n    // solve\n    int l = 0, r;\n    int ans_l = -2000000, ans_r = 0;\n    for (r = 0; r < s.length(); r++) {\n        inc(s[r]);\n        while(is_valid()) {\n            if (r - l < ans_r - ans_l) {\n                ans_l = l;\n                ans_r = r;\n            }\n            dec(s[l++]);\n        }\n    }\n\n    // output\n\n    if (ans_r == 0) {\n        cout << \"QQ\\n\";\n    }\n    else {\n        for (int i = ans_l; i <= ans_r; i++) {\n            cout << s[i];\n        }\n        cout << '\\n';\n    }\n    \n    return 0;\n}\n"
  },
  {
    "id": "timecomplexity02",
    "instruction": "東周年間，孔子的得意門生顏淵有一個很特別的技能：如果有人給他一個字串 $S$，他就可以以極快的速度找到這個字串的最長回文子字串！在一個「字串」、「回文」、「子字串」這些名詞都還沒被定義的年代，這是一件極為了不起的事情。比較不為人知的事，這也是顏淵又名「顏回」的原因。\n\n一些名詞定義：如果一個字串被反過來之後，它還是長得一樣，則他就稱為一個回文。舉例來說，`cabac`、`唧唧復唧唧` 都是回文，但是 `abcde`、`木蘭當戶織` 則都不是。如果一個字串 $A$ 能夠刪除頭尾若干連續的字元而得到 $B$，則稱 $B$ 為$A$ 的子字串。\n\n論語中記載著：\n> 哀公問：「弟子孰為好學？」孔子對曰：「有顏回者好學，不遷怒，不貳過。不幸短命死矣！今也則亡，未聞好學者也。」\n\n在顏回去世後的兩千年，科技已經有了極大的進步，可以重新複製顏回那時候的技能了！請你寫一支程式來找到一個字串 $S$ 的最長回文子字串吧！\n輸出只有一行，就是需要在其中搜尋的字串 $S(1 \\leq |S| \\leq 5000)$，且保證 $S$ 只由小寫英文字母組成。\n\n第一行請輸出一個數字 $L$，代表 $S$ 當中的最長子字串的長度。第二行請輸出兩個數字 $l,r(1 \\leq l \\leq r \\leq |S|$，且 $r - l + 1 = L)$，代表 $S_lS_{l + 1}\\dots S_{r}$ 為 $S$ 的最長回文子字串。如果有多組答案，則輸出任何一者皆可。詳細的格式請參照範例。\n\n",
    "output": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nint main() {\n    string s;\n\tint mxlen = 0, l, r;\n    cin >> s;\n    int N = s.length();\n    for(int i = 0; i < N; i++){\n        //even length: compare s[i - k] and s[i + 1 + k]\n        int k = 0;\n        while((i - k >= 0) && (i + 1 + k < N) && (s[i - k] == s[i + 1 + k])) k++; \n        if(mxlen < 2 * k){\n            mxlen = 2 * k;\n            l = i - k + 1;\n            r = i + k;\n        }\n        //odd length \n        k = 0;\n        while((i - k >= 0) && (i + k < N) && (s[i + k] == s[i - k])) k++;\n        if(mxlen < 2 * k - 1){\n            mxlen = 2 * k - 1;\n            l = i - k + 1;\n            r = i + k - 1;\n        }\n    }\n    cout << mxlen << endl;\n    cout << l + 1 << \" \" << r + 1 << endl;\n}\n"
  },
  {
    "id": "timecomplexity03",
    "instruction": "學姐最近突然迷上搜集質數，所以她開始問你一個正整數是不是質數，請寫一支程式幫忙回答學姐的提問吧！\n輸入第一行有一個正整數 $T$，代表學姐的問題數量。接下來 $T$ 行，每一行都是一個學姐的提問，第 $i$ 行包含一個正整數 $X_i$，代表第 $i$ 個問題是 $X_i$ 是不是質數。\n\n- $1 \\le T \\le 100$\n- $1 \\le X_i \\le 10^{10}$\n\n輸出有 $T$ 行，每一行都是 `YES` 或 `NO`，代表那次詢問的正整數是不是質數。\n\n",
    "output": "/*input\n1\n1\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\n\nvector<int> p;\nbool isp[maxn];\n\nvoid solve(){\n\tlong long n;\n\tcin>>n;\n\tif(n == 1){\n\t\tcout<<\"NO\\n\";\n\t\treturn;\n\t}\n\tfor(int i:p){\n\t\tif(n % i == 0 && n != i){\n\t\t\tcout<<\"NO\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<\"YES\\n\";\n\treturn;\n}\n\nint main(){\n\t// linear seive until sqrt(C)\n\tfor(int i = 2; i < maxn; i++){\n\t\tif(!isp[i]) p.push_back(i);\n\t\tfor(int j = 0; i * p[j] < maxn; j++){\n\t\t\tisp[i * p[j]] = 1;\n\t\t\tif(i % p[j] == 0) break;\n\t\t}\n\t}\n\n\tint T;\n\tcin>>T;\n\twhile(T--) solve();\n\treturn 0;\n}\n"
  },
  {
    "id": "timecomplexity04",
    "instruction": "合太資料工廠的某位基層員工 - 衣櫃惡徒，喜歡把他的奇怪收藏藏在他的衣櫃裡面，其中他的一大宗收藏便是所謂的「神奇數列」。\n「神奇數列」的定義很簡單，只要是一個不包含重複數字的數列，都是一個神奇數列。\n現在你因為某些神奇的原因，需要檢查衣櫃惡徒的衣櫃，但你打開衣櫃的你卻只發現一個沒那麼神奇的數列，裡面包含了許多重複數字。\n為了滿足衣櫃惡徒的神奇癖好，你需要從裡面提煉出最長的神奇數列。請你找出這個沒那麼神奇數列中最長的神奇數列，並且這個神奇數列在原本的數列中要是連續的。\n\n舉例來說，在數列 $1\\;2\\;3\\;4\\;3\\;4\\;5$ 中，$1\\;2\\;3\\;4$ 為最長的連續神奇數列，但 $1\\;2\\;3\\;4\\;5$ 不是，因為他不是原數列中的連續子數列。\n\n輸入第一行有數字 $N$ ，代表這個沒那麼神奇數列的長度。\n第二行會有 $N$ 個數字 $a_i$ ，為這個沒那麼神奇數列的內容。\n\n* $0 < N \\leq 10^6$\n* $0 \\leq a_i \\leq 10^6$\n\n輸出一行，為所求的最長連續神奇數列，數字之間以空白分隔。若有多個這種子數列，輸出最早出現的最長連續神奇數列。\n\n",
    "output": "#include <iostream>\n#define MAXNUM 1000050\n#define MAXN 1000050\n\nusing namespace std;\n\nint cnt[MAXNUM];\nint repeated_cnt;\n\nvoid inc(int x) {\n    if (++cnt[x] == 2) {\n        repeated_cnt++;\n    }\n}\n\nvoid dec(int x) {\n    if (--cnt[x] == 1) {\n        repeated_cnt--;\n    }\n}\n\nbool is_valid() {\n    return repeated_cnt == 0;\n}\n\nint a[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    repeated_cnt = 0;\n    // input\n\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    // solve\n    int l, r = 0;\n    int ans_l = 0, ans_r = 0;\n    for (l = 0; l < n; l++) {\n        while(is_valid() && r <= n) {\n            inc(a[r]);\n            if (r - l > ans_r - ans_l) {\n                ans_l = l;\n                ans_r = r;\n            }\n            r++;\n        }\n        dec(a[l]);\n    }\n\n    // output\n    for (int i = ans_l; i < ans_r; i++) {\n        cout << a[i] << \" \\n\"[i == ans_r - 1];\n    }\n    \n    return 0;\n}\n"
  },
  {
    "id": "timecomplexity05",
    "instruction": "柴犬老師是一個生活非常無趣的人，他的生活圍繞著柴犬、壽司以及 lab，因此他身邊的人都叫他老師。\n柴犬老師實在是強到不行，他加了超級多 lab ，他身邊的人為了衡量他的強度，定義了一個指標：$m$- 強強強指數。\n現在我們給柴犬老師的 lab 做編號，並把他最近去過得 $n$ 個 lab 列成一個數列，如果在一個長度 $m$ 的區間內，他去的 $m$ 個 lab 都不一樣，則會有一分的 $m$- 強強強指數。\n如果有 $x$ 個這種區間，他的 $m$- 強強強指數就是 $x$。\n現在給定 $n$, $m$, 以及柴犬老師最近去過的 lab ，請求出柴犬老師的 $m$- 強強強指數。\n\n第一行有兩個數字 $n$ 和 $m$。\n第二行有 $n$ 個數字，代表柴犬老師最近去過的 lab 編號 $a_i$ ， 數字之間以空白分隔。\n\n* $0 < m \\leq n \\leq 200000$\n* $0 \\leq a_i \\leq 1000000$\n\n##### subtasks\n* $20\\%$ $m \\leq n \\leq 50$，$a_i \\leq 250$\n* $40\\%$ $m \\leq n \\leq 1000$, $a_i \\leq 5000$\n* $100\\%$ 無特別限制\n\n輸出柴犬老師的 $m$- 強強強指數 $x$。\n\n",
    "output": "#include <iostream>\n#define MAXN 2000050\n\nusing namespace std;\n\nint cnt[MAXN];\nint repeated_cnt;\n\nvoid inc(int x) {\n    if (++cnt[x] == 2) {\n        repeated_cnt++;\n    }\n}\n\nvoid dec(int x) {\n    if (--cnt[x] == 1) {\n        repeated_cnt--;\n    }\n}\n\nbool is_valid() {\n    return repeated_cnt == 0;\n}\n\nint a[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    repeated_cnt = 0;\n    // input\n\n    int m, n;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    // solve\n    int ans = 0;\n    for (int i = 0; i < m; i++) {\n        inc(a[i]);\n    }\n\n    if (is_valid()) {\n        ans++;\n    }\n\n    for (int i = 0; i < n - m; i++) {\n        dec(a[i]);\n        inc(a[i+m]);\n        \n        if (is_valid()) {\n            ans++;\n        }\n    }\n\n    // output\n    cout << ans << '\\n';\n    \n    return 0;\n}\n"
  },
  {
    "id": "timecomplexity06",
    "instruction": "小 Y 經營著一間工廠，該工廠有兩條生產線，兩條生產線都被切成 $n$ 格，分別有各自的能量係數 $a_1, a_2, \\ldots, a_n$ 及 $b_1, b_2, \\ldots, b_n$，整間工廠的產能為\n$$\n  \\sum_{i = 1}^n a_ib_i.\n$$\n\n小 Y 可以反轉第一條生產線 $a_1, a_2, \\ldots, a_n$ 中某個子區間的能量係數 ( 也可以選擇不反轉 )，讓總產能最大化，請幫小 Y 計算最大的產能為多少。\n\n\n輸入的第一行包含一個正整數 $n (1 \\leq n \\leq 5000)$。\n第二行包含 $n$ 個整數 $a_1, a_2, \\ldots, a_n (1 \\leq a_i \\leq 10^7)$。\n第三行包含 $n$ 個整數 $b_1, b_2, \\ldots, b_n (1 \\leq b_i \\leq 10^7)$。\n\n請輸出一個整數，代表小 Y 工廠的最大產能。\n\n",
    "output": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(nullptr);\n  int n; cin >> n;\n\n  vector<int> a(n + 1), b(n + 1);\n  for(int i = 1; i <= n; i++) cin >> a[i];\n  for(int i = 1; i <= n; i++) cin >> b[i];\n\n  vector<long long> prv(n + 1);\n  for(int i = 1; i <= n; i++) prv[i] = prv[i - 1] + 1LL * a[i] * b[i];\n\n  long long ans = prv[n];\n  for(int o = 1; o <= n; o++) {\n    long long cur = 1LL * a[o] * b[o];\n    for(int l = o - 1, r = o + 1; l >= 1 && r <= n; l--, r++) {\n      cur += 1LL * a[l] * b[r] + 1LL * a[r] * b[l];\n      ans = max(ans, cur + prv[l - 1] + (prv[n] - prv[r]));\n    }\n\n    cur = 0;\n    for(int l = o, r = o + 1; l >= 1 && r <= n; l--, r++) {\n      cur += 1LL * a[l] * b[r] + 1LL * a[r] * b[l];\n      ans = max(ans, cur + prv[l - 1] + (prv[n] - prv[r]));\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "id": "timecomplexity07",
    "instruction": "迷上搜集質數的學姐收到了你給她能回答「一個正整數是不是質數」的程式後很開心，開始頻繁的使用他，但學姐用久了便發現這支程式回答所花的時間有點久，就算他能夠回答到大至 $10^{10}$ 的數字，學姐也不需要問到這麼大的數字。因此，學姐降低了詢問的數字範圍，並希望你能再寫一支程式更快速的回答她的問題。\n\n輸入第一行有一個正整數 $T$ ，代表學姐的問題數量。接下來 $T$ 行，每一行都是一個學姐的提問，第 $i$ 行包含一個正整數 $X_i$ ，代表第 $i$ 個問題是 $X_i$ 是不是質數。\n\n- $1 \\le T \\le 10^6$\n- $1 \\le X_i \\le 10^{6}$\n\n輸出有 $T$ 行，每一行都是 `YES` 或 `NO`，代表那次詢問的正整數是不是質數。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXC = 1000000;\nint not_prime[MAXC + 5] = {1, 1};\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    for (int i = 2; i * i <= MAXC; ++i)\n        if (!not_prime[i])\n            for (int j = i * i; j <= MAXC; j += i)\n                not_prime[j] = 1;\n    int T;\n    cin >> T;\n    while (T--) {\n        int x;\n        cin >> x;\n        if (not_prime[x])\n            cout << \"NO\\n\";\n        else\n            cout << \"YES\\n\";\n    }\n}\n"
  },
  {
    "id": "timecomplexity08",
    "instruction": "小 P 現在打算在他家後院蓋秘密基地，因為他很喜歡三角形，\n所以他希望能用後院的木材蓋出一個周長最長的三角形秘密基地\n現在給你後院每一個木材的長度，你請幫忙小 P 挑出該用哪三個木材，\n才能圍出周長最長的三角形秘密基地。\n輸入第一行有一個正整數 $N$ ，代表後院木材的數量。\n第二行包含 $N$ 個數字，以空白隔開，第 $i$ 個正整數 $X_i$ 代表第 $i$ 個木材的長度。\n\n- $3 \\le N \\le 10^6$\n- $1 \\le X_i \\le 10^{9}$\n\n輸出由小到大的三個數字並以空白隔開，代表組成秘密基地要用到的三根木材的長度。\n若無解請輸出 `-1` 。\n\n",
    "output": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n; cin >> n;\n    vector<int> v(n);\n    for(int i=0;i<n;i++) cin >> v[i];\n    sort(v.begin(),v.end());\n    while(v.size()>=3){\n        if(v[v.size()-3] + v[v.size()-2] <= v.back()) v.pop_back();\n        else break;\n    }\n    if(v.size()>=3) cout << v[v.size()-3] << ' ' << v[v.size()-2] << ' ' << v.back() << '\\n';\n    else cout << -1 << '\\n';\n}"
  },
  {
    "id": "timecomplexity09",
    "instruction": "給定一個數列 $a$，由從 $1$ 到 $N$ 編號的 $N$ 個整數組成。\n\n讓我們將數組的 $k$- 區間完全數 定義為 為出現在所有長度為 $k$ 的子陣列 (子陣列在這裡是連續的，恰好包含 k 個元素) 的交集中，最小的那個數。\n如果沒有數字滿足在所有長度為 $k$ 的子陣列中都有該數字，則此數列的 $k$- 區間完全數 為 $-1$。\n\n假設數列為 `1 2 3 4 5`, $k = 4$，長度為 $k$ 的子陣列有 `1 2 3 4` 和 `2 3 4 5` 其中 $2$ 是在所有子陣列的交集中，最小的數字\n\n現在小 U 希望找出 $k$ 從 $1$ 到 $N$ 的每一個 $k$- 區間完全數。\n\n輸入第一行有一個正整數 $N$，代表數列 $X$ 的長度。第二行有 $N$ 個數字以空白隔開，為數列 $X$ 的第 $i$ 個數。\n\n- $1 \\le N \\le 10^6$\n- $1 \\le X_i \\le N$\n\n輸出 $N$ 個數字並以空白隔開，依序代表 $k$ 從 $1$ 到 $N$ 的 $k$-區間完全數 \n",
    "output": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1000005;\nint in[N];\nint mp[N],mx[N];\nint ans[N];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    for(int i=1;i<=n;i++) {\n        cin >> in[i];\n        mx[i] = mp[i] = 0;\n        ans[i] = -1;\n    }\n    for(int i=1;i<=n;i++) {\n        mx[in[i]] = max(mx[in[i]], i - mp[in[i]]);\n        mp[in[i]] = i;\n    }\n    for(int i=1;i<=n;i++) \n        mx[in[i]] = max(mx[in[i]], n+1 - mp[in[i]]); \n    for(int i=1;i<=n;i++) if(ans[mx[i]] == -1){\n        for(int j=mx[i]; j<=n && ans[j]==-1; j++)\n            ans[j] = i;\n    }\n    for(int i=1;i<=n;i++) cout << ans[i] << \" \\n\"[i==n];\n}"
  },
  {
    "id": "timecomplexity10",
    "instruction": "有 $n$ 個人，他們各為自己國家的元首，編號 $1$~$n$，有 $q$ 次操作。\n操作1：$a$ 國吞并了 $b$ 國，並且 $a$ 成為新國度的元首。（保證 $a$、$b$ 都是元首）\n操作2：請輸出以 $x$ 為首的國家有多少人（若 $x$ 非元首則輸出 $-1$）。\n最後請輸出剩下的每個國家的元首跟成員組合。\n\n第一行包含兩個正整數 $n$, $q$ 以空白隔開，代表有 $n$ 個人，接下來有 $q$ 次操作。\n第 $2$ 行至第 $q+1$ 行，每行有可能為:\n1. `1 a b` 代表操作 $1$\n2. `2 x` 代表操作 $2$\n\n$n, q \\le 10^5$\n$1 \\le a,b,x \\le n$\n對於每個操作 $2$，輸出一個整數並換行\n最後請由小到大輸出剩下的每個國家的元首跟成員組合。\n每一行請輸出 `x_i: y_1 y_2 y_3...` \n代表該國家的元首為 $x_i$，成員組合為 $y_1,\\ y_2,\\ \\dots$\n請由小到大輸出國家元首，再由小到大輸出其成員組合（包含元首）。\n",
    "output": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nvector<int> v[N];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, q, cmd, a, b;\n    cin >> n >> q;\n    for(int i=1;i<=n;i++) v[i].emplace_back(i);\n    for(int i=1;i<=q;i++) {\n        cin >> cmd;\n        if(cmd == 1){\n            cin >> a >> b;\n            if(v[a].size() < v[b].size()) v[a].swap(v[b]); // O(1) \n            v[a].insert(v[a].end(), v[b].begin(), v[b].end()); // O(min(|a|,|b|))\n            v[b][0] = -1;\n        }else{\n            cin >> a;\n            if(v[a][0] > 0) cout << v[a].size() << '\\n';\n            else cout << -1 << '\\n';\n        }\n    }\n    for(int i=1;i<=n;i++) if(v[i][0] > 0){\n        sort(v[i].begin(), v[i].end());\n        cout << i << \":\";\n        for(int j : v[i]) cout << ' ' << j;\n        cout << '\\n';\n    }\n}"
  },
  {
    "id": "timecomplexity11",
    "instruction": "小 y 家裡有 $N$ 枝籤，每一支上面都寫了一個正整數。\n他最喜歡抽籤了。\n昨天小明作夢的時候夢到兩個數字，分別是 $4, X$，小明便好奇，有沒有可能抽四次籤，上面寫的數字加起來恰好等於 $X$ 呢？\n註：小明每次抽完籤都會把籤放回去籤筒裡面。\n\n輸入的第一行有兩個正整數 $N, X(1 \\leq N \\le 1000, 0 \\leq X \\le 4 \\cdot 10^9$ 以一個空格隔開。\n第二行有 $N$ 個正整數以一個空格隔開，代表 $A_0, A_1, \\ldots, A_{N-1}(1 \\leq A_i \\le 10^9)$\n\n如果有可能的話，輸出 `Yes`，否則輸出 `No`。\n\n",
    "output": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n\tll N, X;\n\tcin >> N >> X;\n\tvector<ll> a(N);\n\tfor (auto &i : a) cin >> i;\n\tvector<ll> b;\n\tfor (auto i : a) for (auto j : a)\n\t\tb.push_back(i + j);\n\n\tsort(begin(b), end(b));\n\n\tfor (int i = 0, j = (int)b.size() - 1;i < b.size();++i) {\n\t\twhile (j && b[i] + b[j] > X) --j;\n\t\tif (j && b[i] + b[j] == X)\n\t\t\treturn cout << \"Yes\\n\", 0;\n\t}\n\tcout << \"No\\n\";\n}\n"
  },
  {
    "id": "variable01",
    "instruction": "歡迎來到 APCSCamp 語法班！恭喜您在學程式的路上成功踏出了第一步。現在，在您繼續往下探索神秘的 C 語言之前，先透過輸出 `Hello APCSCamp!` 來跟 APCSCamp 所有的學員和工作人員打聲招呼吧！\n本題沒有輸入。\n請輸出一行 `Hello APCSCamp!`。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tcout << \"Hello APCSCamp!\" << endl;\n}\n"
  },
  {
    "id": "variable02",
    "instruction": "小 K 跟小 L 在玩一個遊戲，他們會各自想出一個整數 $A$ 和 $B$ ，並且把他們加起來，得到一個整數 $C$ ，聰明的你能夠找出得到的結果是什麼嗎?\n輸入只有一行，包含兩個以單一空格隔開的整數 $A,B(-2^{31}\\le A,B<2^{31})$，分別代表小 K 和小 L 給出的數字。\n輸出一行一個整數 $C=A+B$，代表得到的結果。\n",
    "output": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tll a, b;\n\tcin >> a >> b;\n\tcout << a + b << endl;\n}\n"
  },
  {
    "id": "variable03",
    "instruction": "在一個風和日麗的下午，園丁小 K 想要將他的圓形花圃用柵欄圍起來。但他只知道這個圓形花圃的半徑 $R$，聰明的你可以幫他計算繞他的花圃一圈會用到多長的柵欄嗎？\n\n> 圓周率請使用 $\\pi=3.1415$ 計算\n\n\n輸入只有一行，包含一個正整數 $R$（其中 $1\\le R\\le 10^7$）代表該圓形花圃的半徑。\n請輸出一個浮點數 $L$ 四捨五入至小數點以下後 $2$ 位（小數點後只顯示兩位數），代表花圃的周長。\n",
    "output": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main() {\n\tdouble a;\n\tcin >> a;\n\tcout << fixed << setprecision(2) << 2*a*3.1415 << endl;\n\treturn 0;\n}\n"
  },
  {
    "id": "variable04",
    "instruction": "本題是變數與運算式練習，你必須讀入 $4$ 個正整數 $a,b,c,d$，之後計算以下五個運算式\n\n- $(a + b \\times c) \\mod d$\n- $a / b + c / d$\n- $\\sin((a-b)^\\circ)\\cos((c-d)^\\circ)$\n- $\\sqrt{|ab - cd|}$\n- $\\log_{10}(abcd)$\n\n輸入只有一行四個以空白分隔的數字 $a,b,c,d$。\n\n保證 $1\\le a,b,c,d\\le 1000$。\n\n輸出五行，分別代表五個算式的答案。\n其中第一個算式答案一定是整數，請輸出一個整數。對於其他算式，請輸出答案四捨五入到小數點後六位的結果，若小數點後不足六位則補 $0$ 補到六位為止。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1);\nint main() {\n    long long a, b, c, d;\n    cin >> a >> b >> c >> d;\n    cout << setprecision(6) << fixed;\n    cout << (a + b * c) % d << endl;\n    cout << (double) a / b + (double) c / d << endl;\n    double angle1 = (double)(a-b) / 360 * PI * 2, angle2 = (double)(c-d) / 360 * PI * 2;\n    cout << sin(angle1) * cos(angle2) << endl;\n    cout << sqrt(abs(a*b - c*d)) << endl;\n    cout << log10(a*b*c*d) << endl;\n}\n"
  },
  {
    "id": "variable05",
    "instruction": "小 F 在實驗室做實驗，實驗室只有華氏溫標的溫度計，但是他必須紀錄攝氏溫度。\n\n能夠寫一支程式把華氏溫度轉換成攝氏溫度嗎？\n\n> 轉換公式：$c = \\frac{5\\times(f-32)}{9}$\n> 其中 $c$ 表示攝氏溫度，$f$ 表示華氏溫度\n\n輸入只有一行，其中含有一個非負整數 $F(0\\le F \\le 200)$，代表要轉換的華氏溫度。\n\n輸出一個浮點數 $C$ 四捨五入至小數點後 $2$ 位（小數點後只顯示兩位數），代表轉換出的攝氏溫度。\n\n",
    "output": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main() {\n    double f;\n    cin >> f;\n    cout << fixed << setprecision(2) << 5*(f-32)/9 << endl;\n}\n"
  },
  {
    "id": "variable06",
    "instruction": "給你兩個整數 $a$ 和 $M$，請計算出 $a$ 除以 $M$ 的餘數。\n注意：餘數要取最小的非負整數，例如 $-5$ 除以 $3$ 的餘數應該要取 $1$ 而不是 $-2$。\n\n輸入只有一行，包含兩個整數 $a$ 和 $M$，以空白分隔。\n\n* $-10000 \\leq a \\leq 10000$\n* $1 \\leq M \\leq 10000$\n\n輸出 $a$ 除以 $M$ 的餘數。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint a, m;\n\tcin >> a >> m;\n\tcout << (a % m + m) % m << '\\n';\n}\n"
  },
  {
    "id": "variable07",
    "instruction": "恭喜你踏入了 C++ 的第一步。現在，就來練習第一個作業，輸出 `Welcome to APCS Camp!` 並且換行，證明你在今天學習的成果吧！\n本題無輸入內容。\n\n輸出指定文字內容：`Welcome to APCS Camp!`，輸出後換行。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    cout << \"Welcome to APCS Camp!\" << endl;\n}\n"
  },
  {
    "id": "variable08",
    "instruction": "阿明是阿號的追隨者，但是阿明一直在模仿阿號，阿號覺得很煩，所以想出了一個點子來證明他們的差距，他們決定各自想好一個整數，阿明給出 $A$ 阿號給出 $B$，相減得到 $C$ 就是他們的差距。\n\n你可以寫一支程式來計算他們的差距嗎？\n\n輸入只有一行，包含兩個以單一空格隔開的整數 $A,B(-2^{31}\\le A,B<2^{31})$，分別代表阿明和阿號給出的數字。\n\n輸出一行一個整數 $C=A-B$，代表他們的差距。\n\n",
    "output": "#include <iostream>\n\nint main() {\n    long long a, b;\n    std::cin >> a >> b;\n    std::cout << a - b << std::endl;\n}\n"
  },
  {
    "id": "variable09",
    "instruction": "給你一個圓的半徑，請問你可以計算出其面積嗎？\n\n如果不記得的話，假設圓的半徑是 $R$，則其面積 $A$ 可以表示為一個無限級數的根號：\n\n$$ A = \\sqrt{\\sum_{k = 1}^{\\infty} \\frac{6R^4}{k^2}} $$\n\n\n輸入只有一個正整數 $R$（$1 \\leq R \\leq 10^5$），代表圓的半徑。\n請輸出一個浮點數，代表圓的面積。假設正確答案是 $A$，則你的答案 $A'$ 與 $A$ 的相對誤差必須少於 $10^{-9}$ 才會獲得 `AC`。\n\n\n兩個數字 $a$ 和 $b$ 的相對誤差定義為 $\\min(|a - b|, \\frac{|a - b|}{|b|})$。\n",
    "output": "#include <iostream>\n#include <math.h>\n#include <iomanip>\nusing namespace std;\n\nconst long double PI = acos(-1);\n\nint main() {\n    int r;\n    cin >> r;\n    cout << setprecision(10) << PI * r * r << endl;\n}\n"
  },
  {
    "id": "variable10",
    "instruction": "如果給你一個秒數，你能夠把它轉換成以`小時`,`分鐘`,`秒`表示的格式嗎？\n比如說 `3662 秒`就可以轉換成 `1 小時 1 分鐘 2 秒`\n\n輸入只有一行一個非負整數 $a$，代表要轉換的秒數。\n\n* $0 \\le a < 86400$\n\n輸出三行非負整數。\n\n第一行為轉換出的小時數 $h$。\n第二行為轉換出的分鐘數 $m$。\n第三行為轉換出的秒數 $s$。\n必須符合 $0 \\le m,s < 60$。\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint a;\n\tcin >> a ;\n\tcout << a / 3600 << endl;\n\ta %= 3600;\n\tcout << a / 60 << endl;\n\tcout << a % 60 << endl;\n\treturn 0;\n}\n"
  },
  {
    "id": "variable11",
    "instruction": "Peipei（裴裴）在他的一生中，都是被平凡人等（如出這題的人 QQ）稱為「電神」。「電神」是什麼呢？以下我們引用網路上關於「電神」的定義。\n\n![](https://i.imgur.com/5s9xJnG.png)\n\n> 截圖自：https://memes.tw/dict/define?q=%E9%9B%BB\n\n身為平凡人的你，想窺見 Peipei（裴裴）電神具體來說究竟有多「電」。於是你透過某種不可名狀的方法得知了的 Peipei （裴裴）物理，化學，生物成績後，開始向其他人推廣 Peipei（裴裴）有多「電」。不過，為了方便推廣，直接向別人說 Peipei （裴裴）的三科成績似乎很冗，講出這三科成績的平均數以及總分就足夠證明 Peipei（裴裴）的「電度」了。\n\n\n因此這題的題目為，請寫一個程式給定 Peipei（裴裴）物理，化學，生物成績，算出這三科成績的平均數以及總分。\n\n輸入只有一行，其包含三個整數，分別為 Peipei（裴裴）的物理，化學，生物成績。\n\n* 這三科的成績皆為介於 $0$ 到 $100$ 的整數。（包含 $0$ 和 $100$ 。）\n\n請輸出兩行。\n\n* 第一行為一個浮點數，代表 Peipei（裴裴）這三科的平均分數。\n  * 平均分數有可能有小數點，因此請以四捨五入至平均分數的小數點後第二位再輸出。\n  * 如果分數為 $100$ 整，你也應該要輸出 $100.00$ 。\n\n* 第二行為一個整數，代表Peipei（裴裴）這三科的加總分數。\n\n\n",
    "output": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main() {\n    int a, b, c;\n    cin >> a >> b >> c;\n    cout << fixed << setprecision(2) <<(double)(a+b+c) / 3 << endl;\n    cout << (a+b+c) << endl;\n}\n"
  },
  {
    "id": "variable12",
    "instruction": "小明，一個正在教學生除法的老師，出了很多題目要學生回家練習。但因為題目太多，加上老師自己也不確定他算出的答案是不是正確的，因此希望你能告訴他每題的答案，讓他確定他的答案是正確的。\n\n輸入只有兩個數字 $a,b(0 \\le a \\le 10^9,1 \\le b\\le 10^9)$ 分別代表這題的被除數與除數。\n\n請輸出一行文字如下 `a/b=c...d`。\n其中 $a,b$ 是題目所給定的數字，$c,d$ 分別是 $a$ 除以 $b$ 的商數及餘數。\n\n",
    "output": "#include <stdio.h>\nusing namespace std;\n\nint main()\n{\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    printf(\"%d/%d=%d...%d\\n\",a,b,a/b,a%b);\n    return 0;\n}\n"
  },
  {
    "id": "variable13",
    "instruction": "緯緯因為亂打人被老師罰抄，然而緯緯不想寫，所以你要幫他罰抄（如果你不幫他抄就會被打）。\n\n輸入可以是任意內容。\n\n請輸出以下三行文字。\n\n```\nI will be friendly to others.\nI won't hit classmates again.\nThis script is written by me.\n```\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main ()\n{\n\tcout << \"I will be friendly to others.\\nI won't hit classmates again.\\nThis script is written by me.\\n\";\n}\n"
  },
  {
    "id": "variable14",
    "instruction": "桃子要把一些有日期的資料送進一個日誌系統裡，然而這個破系統只吃西元年，請你幫桃子把民國年換成西元年。\n\n輸入有一個整數，範圍介於 1 到 111 之間。\n\n請輸出對應的西元年。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main ()\n{\n\tint a;\n\tcin >> a;\n\tcout << a + 1911 << '\\n';\n}\n"
  },
  {
    "id": "variable15",
    "instruction": "慶仔最討厭零錢了，因為當零錢太多時，總金額就會難以計算，現在慶仔的錢包裡有 $N$ 枚五元硬幣、 $M$ 枚十元硬幣，且只有這兩種貨幣，聰明的你可以幫幫慶仔算一算他一共有多少錢嗎？\n\n輸入只有一行。\n輸入的第一行包含了兩個整數 $N, M\\ (0 \\le N, M \\le 10^{6})$，分別代表慶仔擁有的五元與十元硬幣的數量。\n\n請輸出一個整數，代表慶仔一共有多少錢。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    cout << N * 5 + M * 10 << endl;\n}\n"
  },
  {
    "id": "variable16",
    "instruction": "小明有 $N$ 個一元硬幣，因為太多了不方便，所以小明打算換成越多個十元硬幣越好，請問它可以換成幾個十元硬幣呢？同時接下來會剩下幾個一元硬幣呢？\n\n輸入只有一行，包含一個正整數 $N(N \\le 10^9)$，代表小明有多少一元硬幣。\n\n輸出一行兩個整數以一個空白隔開，分別代表換了幾個十元硬幣，及剩下幾個一元硬幣。\n\n",
    "output": "#include <iostream>\n\nint main() {\n    long long n;\n    std::cin >> n;\n    std::cout << n / 10 << ' ' << n % 10 << '\\n';\n}\n"
  },
  {
    "id": "variable17",
    "instruction": "小癸、小亥、小Z、小下四個人是常常一起被當的好夥伴，多年被當的經驗讓他們得出一個結論：小亥的成績總是比小癸多 $3$ 分，小Z的成績則都是小癸的 $2$ 倍少 $5$ 分，而小下的分數的十位數與小Z相同、個位數都與小亥相同。\n\n今天小癸考了 $n$ 分，你可以依據前面提到的規則來找出小下的成績嗎？\n\n輸入只有一行，包含一個整數 $n\\ (0\\le n\\le 99)$，代表小癸的成績，由於四個人的成績都不好，所以保證四人的成績都不到 $100$。\n\n請輸出小下的成績（保證小下的成績為一個非負整數）。\n\n",
    "output": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int score;\n    cin >> score;\n    int a = score + 3;\n    int b = score * 2 - 5;\n    cout << b / 10 * 10 + a % 10 << endl;\n}\n"
  },
  {
    "id": "variable18",
    "instruction": "緯緯發現他的錢太多了，用一般的單位「元」沒辦法簡單地看出他的存款變化。他定義 1A 等於 600 元。給定一個以元為單位的金額，請你算出總共可以換成多少 A，以及換成 A 之後剩下多少元。\n\n輸入有一個整數，範圍介於 $1$ 到 $10^9$ 之間。\n\n請輸出兩個數字：輸入的金額最多能換成多少 A，以及換完後剩下的金額。\n兩個數字以空格分隔。\n\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main ()\n{\n\tint a;\n\tcin >> a;\n\tcout << a / 600 << ' ' << a % 600 << '\\n';\n}\n"
  }
]